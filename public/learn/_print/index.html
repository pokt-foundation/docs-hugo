<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.0.3+tip">
    <meta name="description" content="">
    <title>Learn Pocket - Pocket Network</title>
    <link href="/learn/" rel="canonical" type="text/html" title="Pocket Network">
    <link href="/learn/index.xml" rel="alternate" type="application/rss+xml" title="Pocket Network">
    <link href="/images/favicon.svg?1658922678" rel="icon" type="image/svg+xml">
    
    <link href="/css/fontawesome-all.min.css?1658922678" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="/css/featherlight.min.css?1658922678" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="/css/auto-complete.css?1658922678" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <noscript>
      <link href="/css/fontawesome-all.min.css?1658922678" rel="stylesheet">
      <link href="/css/featherlight.min.css?1658922678" rel="stylesheet">
      <link href="/css/auto-complete.css?1658922678" rel="stylesheet">
    </noscript>
    <link href="/css/perfect-scrollbar.min.css?1658922678" rel="stylesheet">
    <link href="/css/nucleus.css?1658922678" rel="stylesheet">
    <link href="/css/fonts.css?1658922678" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="/css/theme.css?1658922678" rel="stylesheet">
    <link href="/css/theme-blue.css?1658922678" rel="stylesheet" id="variant-style">
    <link href="/css/ie.css?1658922678" rel="stylesheet">
    <link href="/css/variant.css?1658922678" rel="stylesheet">
    <link href="/css/print.css?1658922678" rel="stylesheet">
    <script src="/js/variant.js?1658922678"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="/index.json";
      var root_url="/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/docs.pokt.network/';
      variants.init( [ 'blue' ] );
    </script>
    <script src="/js/jquery.min.js?1658922678" defer></script>
  </head>
  <body class="mobile-support print" data-url="/learn/">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="/learn/vision/" title="Vision (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="/pokt/wpokt/" title="🎁 Wrapped POKT (wPOKT) (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="/learn/_print/">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span class="links">
              Learn Pocket
            </span>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
    
          <article class="chapter">
<div class="article-subheading">Chapter 4</div>
<h1>Learn Pocket</h1>


            <footer class="footline">
            </footer>
          </article>

          <section>
    
          <article class="default">
<h1>Vision</h1>

<h2 id="decentralizing-web3-access">Decentralizing Web3 Access</h2>
<p>Web3 is built on incentives.</p>
<p>Blockchains enable unstoppable validation of transactions by incentivizing validator nodes, with mining/staking rewards, to confirm transactions. However, while this ensures an unstoppable history of transactions, it doesn&rsquo;t ensure unstoppable access to read the history or to write new transactions to the history.</p>
<p>Many blockchain communities have <a href="https://ethresear.ch/t/incentives-for-running-full-ethereum-nodes/1239">debated incentivizing the RPC nodes</a> that provide this access to the blockchain. Facing quite a complex challenge though, they have <a href="https://eips.ethereum.org/EIPS/eip-908">rejected on-chain solutions</a>, expecting that altruists would run RPC nodes for the good of the network.</p>
<p>However, in the name of convenience, as RPC nodes have grown more expensive to maintain and developers more specialized, Web3 RPC access has consolidated around centralized gatekeepers. When you use MetaMask to sign transactions in your favorite game or NFT marketplace, assuming you haven&rsquo;t already <a href="/learn/vision/../use/public-rpc">switched your custom RPC to Pocket Network</a>, your data is flowing through a centralized cluster of RPC nodes. This means you are vulnerable to <a href="https://blog.infura.io/infura-mainnet-outage-post-mortem-2020-11-11/">outages</a>.</p>
<p>Pocket Network solves this critical flaw in the Web3 stack by incentivizing a network of RPC nodes to relay your data to any blockchain. DApps send their RPC requests to the nodes, who relay the requests and use Zero-Knowledge Range Proofs to validate the Relay Evidence that determines their POKT block reward. As well as making Web3 access unstoppable, this has the side effect of making Web3 infrastructure cheaper, by eliminating rent-seeking intermediaries, and more private, since each RPC node relays only a fraction of your data.</p>
<p><a href="/learn/vision/protocol/README.md"><strong>Learn more about Pocket Network&rsquo;s current protocol</strong></a>.</p>
<p><a href="/learn/vision/future/README.md"><strong>Learn more about v1</strong></a>, the future of Pocket Network&rsquo;s protocol.</p>
<h2 id="how-pokt-incentivizes-rpc-nodes">How POKT Incentivizes RPC Nodes</h2>
<p>Pocket Network&rsquo;s unstoppable Web3 access is powered by the POKT utility token.</p>
<p>Applications stake POKT to lock in an RPC relay allowance, then transfer value to nodes through dilution of their stake proportional to the number of relays they request. Meanwhile, RPC nodes are participating in a perpetual fair-launch economy in which tokens are continuously rewarded to the nodes who do the most work.</p>
<p>This economic model has the following benefits:</p>
<ul>
<li><strong>Minimizes the number of transactions needed to coordinate the network, enabling cheaper RPC access</strong>. Per-relay micro-transaction payment models, on the other hand, would needlessly congest block space.</li>
<li><strong>Provides extra incentive to apps to be early adopters of Pocket Network.</strong> When using Pocket Network, RPC infrastructure becomes an asset, literally. Apps make an upfront investment by staking POKT, which means they don&rsquo;t need to worry about monthly bills and their cost-per-relay approaches zero the more relays they use. This makes Pocket Network&rsquo;s RPC service very attractive compared to the competition in the long run.</li>
</ul>
<p>Once the POKT ecosystem is mature, when apps can frictionlessly top-up their stakes, and we no longer need bootstrapping incentives, the protocol has a dormant burning mechanism that the DAO can activate to burn app stakes proportional to the number of relays they request. This will have the effect of transforming Pocket Network&rsquo;s business model into a standard credit system and making POKT deflationary.</p>
<p>Learn more about <a href="/learn/vision/economics/README.md">Pocket Network&rsquo;s economics</a> and also <a href="/learn/vision/future/README.md">the future of Pocket with v1</a>.</p>
<h2 id="-decentralizing-infrastructure">💸 Decentralizing Infrastructure</h2>
<p>We posit that application-specific blockchains like Pocket Network have the ability to design greater cost efficiencies at the base protocol layer of the Web3 stack while enhancing security and censorship resistance.</p>
<p>Pocket achieves this through an incentive design that rewards Service Nodes for collectively achieving economies of scale:</p>
<ol>
<li>Load balancing at the protocol level incentivizes decentralization and minimizes the need for buffers</li>
<li>Staking and inflation enables more efficient resource allocation</li>
<li>Low marginal costs reduce barriers to entry, allowing anyone to participate at any scale</li>
</ol>
<h3 id="load-balancing-at-the-protocol-level">Load balancing at the protocol level</h3>
<p>Due to the protocol using pseudo-random mechanisms to load balance work evenly across all nodes in the network, the optimal deployment strategy for node providers is to horizontally scale the number of Service Nodes they run (rather than to scale vertically by increasing the POKT stake of the Service Nodes they already have) to increase the probability that they&rsquo;ll receive work. By decreasing the average work per Service Node, participants of all scales are encouraged to provision their computing power to Pocket Network. This aspect of Pocket&rsquo;s system design means Pocket Network&rsquo;s node counts will increase as it scales.</p>
<p>To minimize the marginal cost of each Service Node, it will ultimately become more profitable to run nodes out of homes and local data centers, which will, over time, create a lower-cost, more efficient decentralized network.</p>
<p>Pocket&rsquo;s distributed nature makes it redundant-by-design, removing the need for node operators to provision extra infrastructure to handle surges in user traffic. Web2 cloud-powered infrastructure requires large buffers of redundant server capacity, which can increase the costs of coordination borne by Web3 users by up to 50%. Conversely, instead of one entity providing all the work, Pocket Network naturally splits demand up amongst Service Nodes through its Session data structure, tumbling new, pseudo-random nodes every Session to give all Service Nodes the opportunity to provide work. As a result, the buffer that each Service Node must provide is significantly lower. Additionally, because Applications must stake POKT to access the service, Service Nodes can account for all potential requests paid for in aggregate, using Application Stake as a gauge of network capacity.</p>
<h3 id="staking-and-inflation">Staking and inflation</h3>
<p>For a decentralized infrastructure service like Pocket Network, on-chain payments via Bitcoin, ETH, or DAI would be inefficient due to the frequency of Relay requests. While state channel implementations do improve the cost of coordination for micropayments, Pocket matches Applications with 5 pseudo-random Service Nodes every 25 blocks for security purposes; creating and breaking on-chain state channels to communicate with each of these nodes would make the cost of coordination impractically high.</p>
<p>Pocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of <a href="https://grassfed.network/mining/">generalized mining</a> or <a href="https://eprint.iacr.org/2017/203.pdf">useful proofs of work</a>, where inflation is directly tied to work validated by the network. Applications stake just once to access the protocol (assuming they don&rsquo;t change their throughput), using the native cryptocurrency POKT which is tied for single-use to the Pocket blockchain. Service Nodes batch all requests received in a Session to one Pocket blockchain transaction, a &ldquo;Proof-of-Relay&rdquo; that Applications can validate client-side and other nodes can validate in block production, removing the need for Applications to pay constant transaction fees for this work. Once those Proofs-of-Relays are validated by the network, a new block is confirmed, then POKT is minted and issued to the relevant Service Nodes as a reward for their work.</p>
<p>Pocket&rsquo;s staking and inflation mechanisms enable a more efficient resource allocation structure by limiting the number of transactions (and thus block validation costs) to one-time staking transactions. All nodes are able to focus primarily on servicing and validating Relay requests by Applications, with minimal energy spent on block validation. By being <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventually consistent</a> and tying rewards directly to inflation, Service Nodes are in effect, receiving micropayments for work validated by two parties without the need for constant on-chain fee payments.</p>
<h3 id="low-marginal-costs-and-participation">Low marginal costs and participation</h3>
<p>The marginal cost of running an individual Service Node is only as high as your electricity and bandwidth costs, ensuring a low barrier to entry for new Service Node operators. Because work is load balanced evenly across the protocol, the stake, size, or capabilities of the Service Node does not increase the probability of receiving work, which enables hobbyists and small providers to participate and contribute alongside major infrastructure providers. As smaller Service Node operators scale up, they can then choose to bear the costs of hardware, equipment, and salaries needed to add more Service Nodes to their operation.</p>
<p>While the bulk of work will most likely be serviced by professional infrastructure providers, Pocket also enables a long tail of individuals to participate and increase the resilience of the protocol, with potential for upward mobility for those who choose to purchase more Service Nodes.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="chapter">
<div class="article-subheading">Chapter 6</div>
<h1>⛓ Protocol</h1>

<p>The Pocket Network is comprised of 3 components: Applications, Nodes and the Network Layer.</p>
<p>An Application submits Relays, or API requests meant to be routed to any public database node. Nodes service these Relays, by submitting them to the public databases they are meant for, and sending the response (if any) back to the Application. The Network Layer is comprised of all the rules, protocols and finality storage that serve as the backbone of the interactions between Applications and Nodes, including (but not limited to), configuration, record tracking, governance and economic policy.</p>
<p>The mechanism the Network uses to regulate the interactions between Applications and Nodes are Sessions. Sessions are a data structure that are generated following the established Session Generation Algorithm, which uses data from the finality storage layer of the network to pseudo-randomly group one Application with a set of Nodes which will provide service to it for a limited timeframe.</p>
<p><img src="/images/mainnet-architecture.png" alt="">
To dive deeper, start by learning more about <a href="/learn/protocol/servicing.md">Sessions</a>.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
          <article class="default">
<h1>🤝 Servicing</h1>

<h2 id="overview">Overview</h2>
<p>The Pocket Network’s Servicing layer is comprised of 2 main actors: Applications and Servicers. An Application submits a Relay Request, or an API requests to be routed to any Relay Chain. A Servicer ‘services’ the Application, by routing the Relay Request to the Relay Chain and forwarding the response to the Application. This interaction between an Application and a Servicer is the fundamental utility of Pocket Network.</p>
<h3 id="basic-lifecycle">Basic Lifecycle</h3>
<ol>
<li>To <em>register</em> for decentralized infrastructure, an Application must stake the native cryptocurrency POKT in the network.</li>
<li>The amount of the sanctioned throughput (per request) is determined by the amount the Application stakes in the network.</li>
<li>To <em>register</em> to provide decentralized infrastructure, a Servicer must stake the native cryptocurrency POKT in the network.</li>
<li>After the subsequent staking, an Application is paired with Servicer(s), during which time the servicing interaction takes place.</li>
<li>For providing the decentralized infrastructure, Servicer receives an amount of the native cryptocurrency POKT proportional to the amount of throughput (in requests) served.</li>
<li>Once an Application or Servicer unstakes, they are <em>unregistered</em> from Pocket Network and the stake is returned to their account.</li>
</ol>
<h2 id="sessions">Sessions</h2>
<h3 id="distribution">Distribution</h3>
<p>The Servicer(s) that are paired to service an Application in a Session are <em>equally</em> distributed among all of the Servicers in the network.</p>
<p>Meaning that every Servicer theoretically serves the same amount as their peers and every Application theoretically will be evenly serviced by each Servicer over time.</p>
<h3 id="generation">Generation</h3>
<p>The generation of a Session is key to the equal distribution property.</p>
<p>Equally distributed sessions are generated with <em>pseudorandom</em> seed data:</p>
<ul>
<li><strong>BlockHash</strong>: Hash of the last Session Block</li>
<li><strong>AppPubKey</strong>: The Application&rsquo;s public key</li>
<li><strong>RelayChain</strong>: The identifier of the Relay Chain</li>
</ul>
<p>The result of using this seed data is unique sessions for every Relay Chain of Application at any given Session period.</p>
<p>The Servicers over time that will serve each Application at any given time are extrapolated using this data, meaning any actor with the following blockchain data is able to generate the proper serving Servicers.</p>
<p>A single <strong>Dispatch</strong> API call to any full node on Pocket Network will provide an Application client with the ServiceURI of their Session period Servicers.</p>
<h3 id="tumbling">Tumbling</h3>
<p>Tumbling is the act of regenerating a Session with new seed data.</p>
<p>Sessions are <em>tumbled</em> periodically every predetermined (by governance) quantity of blocks.</p>
<p>The tumbling mechanism allows for much greater Application security, as the same Validator(s) will only service the Application for a certain amount of time.</p>
<h3 id="throughput">Throughput</h3>
<p>The max Application throughput (in number of requests) is proportional to the amount staked.</p>
<p>The maximum a Servicer in a Session can service for a certain Application is determined using the following formula:</p>
<p><code>max_app_relays = base_throughput / (# of Servicers in Session * # of relay_chains staked for)</code></p>
<h2 id="relays">Relays</h2>
<h3 id="payload"><strong>Payload</strong></h3>
<p>The request payload is the body of the RPC request</p>
<ul>
<li><strong>Data</strong>: The actual request body to be forwarded to the Relay Chain
<ul>
<li>e.g. <code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;web3_clientVersion&quot;,&quot;params&quot;:[],&quot;id&quot;:67}</code></li>
</ul>
</li>
<li><strong>Method</strong>: The HTTP CRUD method
<ul>
<li>e.g. <code>POST</code></li>
</ul>
</li>
<li><strong>Path</strong>: Path variable for REST support
<ul>
<li>e.g: <code>&quot;/v1/query/block&quot;</code></li>
</ul>
</li>
<li><strong>Headers</strong>: HTTP Headers
<ul>
<li>e.g. <code>Content-Type: application/json</code></li>
</ul>
</li>
</ul>
<h3 id="metadata"><strong>Metadata</strong></h3>
<p>The Relay Metadata is Protocol level descriptive information that is needed for servicing.</p>
<ul>
<li><strong>BlockHeight</strong>: The Pocket Network block height when the request was made</li>
</ul>
<p>The metadata mechanism allows for a configurable <em>client syncronization</em> module, enabling the <strong>Servicer</strong> to reject out of sync clients.</p>
<p>Since the Metadata is grouped into the request hash, this mechanism is a protection against Client level synchronization attacks where the Client is able to challenge single <strong>Servicers</strong> by requesting chain data at a different time than the majority.</p>
<h3 id="proof-of-relay-evidence"><strong>Proof of Relay (Evidence)</strong></h3>
<p>A <strong>Proof of Relay</strong> is the portion of a Relay Request that is used for verification of the atomic work completed.</p>
<p>For each Application of each Session, a Servicer collects Relay Evidence in the form of a <strong>Proof of Relay</strong>. The amount of Relay Evidence is completely proportional to the amount of Relays serviced, meaning for each Relay successfully completed, the Servicer stores one piece of <strong>Relay Evidence</strong>.</p>
<h4 id="structure-of-the-proof-of-relay">Structure of the <strong>Proof of Relay</strong></h4>
<ul>
<li><strong>RequestHash</strong>: <em>The SHA3-256 hash of the request payload</em>
<ul>
<li>Connects the specific payload with the proof</li>
<li>Needed for the <strong>Application Challenge Mechanism</strong></li>
</ul>
</li>
<li><strong>Entropy</strong>: <em>A unique nonce (random number) that ensures uniqueness</em>
<ul>
<li>Unique Relays are a requirement of Pocket Network for Claim/Proof Submission</li>
<li>Collisions are rejected by the Servicers</li>
</ul>
</li>
<li><strong>SessionBlockHeight</strong>: <em>The block height of the session when the Relay was serviced</em>
<ul>
<li>Needed to verify the participants of Session</li>
</ul>
</li>
<li><strong>ServicerPubKey</strong>: <em>The ED25519 Public Key of the servicer</em>
<ul>
<li>Needed to identify the servicer</li>
</ul>
</li>
<li><strong>RelayChain</strong>: <em>The identifier of the &lsquo;relayed to&rsquo; blockchain</em>
<ul>
<li>Ex: 0021 (Eth mainnet)</li>
</ul>
</li>
<li><strong>AAT</strong>: <em>The Application Authentication Token for the client serviced</em>
<ul>
<li>Includes both App Public Key and Client Public Key</li>
<li>Needed for protocol level verification (app node pairings, client permissions, etc.)</li>
</ul>
</li>
<li><strong>ClientSignature</strong>: <em>The Elliptic Curve Digital Signature of the client</em>
<ul>
<li>Preserves the integrity of the Relay data</li>
<li>Needed at Proof/Claim verification level</li>
</ul>
</li>
</ul>
<h3 id="response">Response</h3>
<h4 id="response-payload"><strong>Response Payload</strong></h4>
<p>The response payload is the body of the RPC response:</p>
<ul>
<li><strong>Response</strong>: String representation of the HTTP response</li>
</ul>
<h4 id="servicer-signature"><strong>Servicer Signature</strong></h4>
<p>The servicer signature completes the signature exchange needed to verify all parties in the servicing protocol.</p>
<ul>
<li><strong>Signature</strong>: preserves the integrity by signing the hash of the <strong>Proof of Relay</strong> and the response payload.</li>
</ul>
<h2 id="claimproof-lifecycle">Claim/Proof Lifecycle</h2>
<p>In order to participate in the network economic incentive mechanism, the Servicer must first <strong>Claim</strong> and then <strong>Prove</strong> the completed work. For each Application of each Session, after servicing is complete and Relay Evidence is collected, the Servicer must send two subsequent transactions:</p>
<ol>
<li><strong>Claim Transaction</strong>
<ul>
<li>Merkle Root of Relay Evidence</li>
<li>Number of Relays serviced</li>
<li>Evidence Type (Relay or Challenge)</li>
</ul>
</li>
<li><strong>Proof Transaction</strong>
<ul>
<li>Selected Relay</li>
<li>Corresponding Merkle Proof for selected Relay</li>
<li>Evidence Type (Relay or Challenge)</li>
</ul>
</li>
</ol>
<p>Upon successful completion of BOTH transactions, the Servicer is minted reward directly to their address.</p>
<h3 id="merkle-tree">Merkle Tree</h3>
<p>Pocket Network requires a specific Merkle tree implementation that ensures no two leafs of the Merkle tree are identical (for Relay replay protection). <a href="https://plasma-core.readthedocs.io/en/latest/specs/sum-tree.html">Plasma-Core&rsquo;s</a> Merkle sum tree satisfies this property.</p>
<p>By using the hash of the Relay data (integrity is validated by verifying the Application Client Signature) in conjunction with the replay protection from the Plasma tree, Pocket Network can probabilistically guarantee work completed without the Servicer actually transmitting the entirety of its Relay Evidence to the rest of the network.</p>
<p>A fancier name for this is a <em>Zero Knowledge Range Proof</em>.</p>
<h3 id="zero-knowledge-range-proof">Zero Knowledge Range Proof</h3>
<p>In order to complete a successful ZKRP in Pocket Network, the following steps must be executed by each Servicer for each Session:</p>
<ol>
<li>Generate the Merkle Tree using the SHA3-256 hash of the Relay Evidence as the leafs</li>
<li>Submit a <strong>Claim Transaction</strong> to preserve the integrity of the local Merkle tree and corresponding Relay Evidence, as well as inform the protocol of the <em>range</em> or number of leafs possible to select from</li>
<li>After a protocol wide waiting period (determined by governance), the Servicer generates the selected leaf (using the latest block hash as <em>pseudorandom entropy</em> to prevent knowledge of the selection during claim generation) and subsequently creates a <strong>Merkle Proof</strong> (branch) for the <em>pseudorandomly selected</em> leaf.</li>
<li>The Servicer submits a <strong>Proof Transaction</strong> containing the selected leaf (Relay Evidence) and the corresponding <strong>Merkle Proof</strong> (branch)</li>
<li>The protocol verifies the Merkle proof against the previously submitted Merkle root (in the <strong>Claim Transaction</strong>), verifies the session (proper app/node pair, not overserviced etc.), and then verifies the client signature against the <strong>Proof of Relay</strong> (integrity check)</li>
<li>All of the Validators confirm the validity of the <strong>Proof Transaction</strong>, completing the <strong>Zero Knowledge Range Proof</strong></li>
<li>Tokens are minted to the address of the Servicer proportional to the amount of Relays served.</li>
</ol>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>🛡 Security</h1>

<p>By enforcing POKT to be staked from both the Applications and the Validators, the protocol is able to economically penalize either actor participating in servicing</p>
<h2 id="session-security">Session Security</h2>
<p>The probability due to randomized selection without replacement is:</p>

<span class="math align-center">$$
P (A∩B) = P (A) P (B|A)
$$</span><p>Thus the probability of selecting any combination of Validators at any given Session in Pocket Network is:</p>

<span class="math align-center">$$
1 / (allvals  (allvals-1)  (allvals - 2) ... * (allvals - valspersession))
$$</span><p>Meaning, the more Validators in the network, the higher level of randomization and by extension security.</p>
<p>The deterministic yet unpredictable properties of the block hash seed data in Session Generation, ensure that no malicious actors will be able to determine Application and Validator pairings. This is a common security mechanism used in Pocket Network.</p>
<h2 id="application-security">Application Security</h2>
<p>The Application Authentication Token is the key mechanism for Applications to balance the security of their stake and UX of clients during servicing. Through the AAT, the Application is able to sanction clients to access their throughput via <strong>Digital Signature</strong>. Future implementations of the AAT include enforcing a lifecycle through expiration and other <em>client access configurations</em> such as Relay Chain specification.</p>
<p><em>Application Distribution Configuration</em> is the recommended practice of distributing an Application &rsquo;s throughput over multiple Application stakes (or identities) to ensure the highest level of data accuracy, uptime, and data privacy.</p>
<p><em>Client Side Validation</em> is the recommended practice of redundantly sending the same request to multiple Validators. <em>CSV</em> allows the client to come to a majority consensus on the Relay Responses. This configuration ensures the highest level of data accuracy and enables the Application to use the <strong>Application Challenge Mechanism</strong> of the protocol, where corresponding minority Validator(s) providing invalid data are economically penalized.</p>
<h2 id="validator-security">Validator Security</h2>
<p><em>A Validator will not receive mint for any service they provided while breaking the servicing protocol rules.</em></p>
<p>These rules are enforced by the Validators by verifying all the work reported to the network.</p>
<p>Examples of breaking the <strong>Servicing Rules</strong> include:</p>
<ul>
<li>Overservicing an Application</li>
<li>Incorrect App/Validator Pairing</li>
<li>Incorrect Relay Chain</li>
<li>Non-Unique <strong>Proof of Relays</strong></li>
<li>Invalid Merkle Root / Proof pairings</li>
<li>Invalid Application Authentication Token</li>
<li>A minority Validator in <strong>Client-Side Validation</strong></li>
<li>Invalid Servicer in Proof</li>
<li>Below minimum Relay count</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
          <article class="chapter">
<div class="article-subheading">Chapter 7</div>
<h1>🪙 Economics</h1>

<h2 id="tldr">TL;DR</h2>
<p>Pocket Network requires both developers and nodes to stake its native utility token, POKT, to participate in the network. Nodes earn rewards for fulfilling API requests for developers on a per request basis. POKT is permanently inflationary, but total supply will be capped through a burning mechanism put in place by the DAO, who controls the monetary policy. The final total supply of POKT will be dictated by the DAO.</p>
<h2 id="overview">Overview</h2>
<p>Pocket Network uses a native cryptocurrency (POKT) to create a permissionless, two-sided market between node providers who run full nodes and developers that want to query data from a blockchain for their application/service. POKT is purchased and staked by both developers and node providers to participate in the network. Due to the unique incentives on each side of the market, staking differs between the parties.</p>
<p>Developers, requiring reliable infrastructure and relay amounts for their applications, stake POKT a single time for a guaranteed amount of relays per session for the life of the stake. The amount of POKT required to be staked is directly proportional to the number of relays required. The number of relays allowed per session can be adjusted for price fluctuations of the POKT token through governance mechanisms.</p>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>The current price per relay is called <code>BaseRelaysPerPOKT</code>, and you can find the current value on the <a href="/learn/economics/../protocol-parameters.md#baserelaysperpokt">Protocol Parameters</a> page.</p>
    </div>
</div>
<p>While paying upfront for infrastructure appears to be burdensome at first glance, it has strong advantages and stickiness that help grow network adoption. The use of a token eliminates recurring payments to legacy infrastructure providers, vastly reducing the cost of infrastructure over the lifecycle of an application - <em>bringing your cost-basis closer to zero the longer the service is used</em>. Further, the upfront purchase of POKT can be viewed as a recoverable expense because the stake can be sold to another user if the service is no longer required helping to recover any costs associated with the network&rsquo;s use. Instead of recurring payments, developers’ stakes are diluted over time through the inflation of the supply of POKT.</p>
<p>Node Providers also stake POKT but do so on a per-node basis. In exchange for servicing relays for applications, nodes are compensated in POKT. Unlike most traditional block rewards, Pocket Network’s is dynamic; POKT rewards are directly proportional to the number of relays and transaction fees in a given block. A node receives a certain amount of POKT per relay fulfilled and proved, minus certain percentages for both the block producer and the DAO.</p>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>The current block producer percentage is called <code>ProposerAllocation</code>, and you can find the current value on the <a href="/learn/economics/../protocol-parameters.md#proposerallocation">Protocol Parameters</a> page.</p>
<p>Furthermore, the DAO allocation of block rewards is called <code>DAOAllocation</code>, and that also can be found on the <a href="/learn/economics/../protocol-parameters.md#daoallocation">Protocol Parameters</a> page.</p>
    </div>
</div>
<p>All nodes in the network have an opportunity to produce a block, but their chances are proportional to their stake.</p>
<p>Because of the way that nodes are incentivized, the Pocket Network economic model is inflationary during the Growth Phase, where the monetary policy is intentionally designed to encourage adoption. At network maturity, the Maturity Phase, a burn rate will initiate for application stakes that will offset the creation of newly minted POKT, stabilizing the total supply of POKT. This economic model encourages early network participation and reduces coordination costs.</p>
<p>At launch, the optimal economic strategy for node operators is to replicate as many nodes as possible with the amount of POKT held. By spreading their stake across multiple nodes, node operators maximize their chances of being chosen in as many sessions as possible, providing them with the most opportunity to serve relays within the network. These incentives promote further decentralization, redundancy, and increase the number of nodes available for each blockchain network supported by Pocket Network.</p>
<p>Maintaining a balance between both sides of the market will be critical to the long-term success of the network. To maintain and secure the future of the protocol, Pocket Network will be run by the Pocket DAO. To accomplish its mission, the DAO receives a certain percentage of block rewards to reinvest in the network. In addition to protocol upgrades, the DAO will dictate the economic policy, making every effort to create sustainable economics that caters to both sides of the market through built-in governance mechanisms. These governance mechanisms allow the DAO to maintain an equilibrium between the two sides of the market and ensure accessibility to new participants.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
          <article class="default">
<h1>🪙 Token Economics</h1>

<h2 id="the-purpose-of-pokt">The Purpose of POKT</h2>
<p>POKT is not a transactional cryptocurrency. The Pocket Network blockchain is not meant to have sub-5-second block times, provide 10,000 transactions per second, facilitate direct payments (generally speaking), or act as a smart contract platform. The majority of the transactions occurring will be staking by Applications and Service Nodes, Proof-of-Relay batches by Service Nodes, and block reward payments to Service Nodes for facilitating Relay requests, which all POKT holders will pay for via inflation.</p>
<p>This is in contrast to most layer 1 chains, which will eventually need to rely predominantly on transaction fees. At network maturity, Pocket will become a simple fee market with the demand side (Applications) burning POKT and the supply side (Service Nodes) receiving newly minted POKT via the block reward inflation mechanism. This allows for the transfer of value without using direct fees and incurring further costs of coordination.</p>
<p>By building a set of crypto-economic mechanisms to ensure the validation of Proofs-of-Relays, Pocket’s architecture can provide blockchain infrastructure at an order-of-magnitude lower cost than other options by virtue of being a permissionless, non-rent-seeking, and open marketplace for anyone to participate. Pocket Network uses these validated Proofs-of-Relays to reward Service Nodes through inflation.</p>
<p>Both Applications and Service Nodes must stake POKT to access or provide work to Pocket Network. For Applications utilizing the Pocket network, POKT represents an ongoing right to an allocation of the network’s throughput, whereas, for Service Nodes, POKT represents a right to provide ongoing work on the network and the future inflation rewards for performing that work.</p>
<h2 id="useful-proofs-of-work">Useful Proofs of Work</h2>
<p>Pocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of generalized mining or &ldquo;useful proofs of work.&rdquo; Submitting proofs of work mints POKT in proportion to the amount of work completed increasing the overall supply of POKT. How this affects the overall supply is determined by the monetary policy.</p>
<p>Our current monetary policy is broken down into two phases: the Growth Phase and the Maturity Phase. During the Growth Phase, applications stake just once to access the protocol (assuming they don’t change their throughput) attracting new applications to use the service due to the low cost of service - only paying through their initial stake and through inflation. At network maturity (the Maturity Phase), Pocket will become a simple fee market with the demand side (Applications) stakes are burned in proportion to the amount of POKT minted by the supply side (Nodes) - eliminating the growth in total supply of POKT. This allows for the transfer of value without using direct fees and incurring further costs of coordination.</p>
<p>For more information, read our page on Pocket <a href="/learn/economics/token/monetary-policy.md">monetary policy</a>.</p>
<h2 id="transactions">Transactions</h2>
<p>Leader-elected nodes are rewarded for facilitating P2P transfers of POKT on the Pocket blockchain via a transaction fee. This is required for the security of the network in order to prevent spam or “dust” attacks. A transaction fee is paid by the individual or entity making a transaction, 99% of which is burned, and the remaining 1% is awarded to the leader-elected node for including transactions in the relevant block. The 1% fee provides an incentive for block producers to include transactions in the next block.</p>
<h2 id="-token-staking">🌱 Token Staking</h2>
<p>There are two distinct types of stake functions within Pocket: <code>StakeApp()</code> and <code>StakeNode()</code>. Both stake functions use the POKT cryptocurrency.</p>
<h3 id="application-staking">Application Staking</h3>
<p>Applications pay for the service in advance by staking POKT. When they invoke the <code>StakeApp()</code> function, the minimum staking period is 21 days. By incurring the minimum unstaking period, Applications forego the potential of using their resources,  POKT in this case, for other alternatives as an opportunity cost. Additionally, Applications pay through dilution, where each time a Relay is serviced and validated by the network, a specific sum of POKT is awarded to the relevant Service Nodes in the next block reward.</p>
<p>The protocol limits the number of Relays an Application may access based on the number of POKT staked in relation to the Protocol Throttling Formula (as defined below). Once an Application stakes POKT, the Maximum Relays (MaxRelays) it can use is locked in perpetuity unless the Application re-stakes that POKT or their stake is burned.</p>
<h3 id="node-staking">Node Staking</h3>
<p>Like with applications, when nodes invoke the <code>StakeNode()</code> function, the minimum staking period is 21 days. The minimum stake at launch required to become a Service Node is 15,000 POKT. This node stake keeps nodes honest and incentivized to provide high quality service. Additionally, a node sufficient stake allows nodes to participate in PoS consensus as a Validator Node. Per the changes in <a href="https://forum.pokt.network/t/pip-4-consensus-rule-change-0-6-0/834">R.C.0.6.0</a>, not all nodes are validators, but all validators are service nodes. To become a Validator Node, you must be in the top 1,000 node stakes (subject to change on DAO parameter vote) on the network. Validator Nodes can claim the block reward for submitting the block which is equal to the value of the <a href="/learn/economics/token/../../protocol-parameters.md#proposerallocation"><code>ProposerAllocation</code></a> parameter.</p>

<div class="box notices cstyle danger">
    <div class="box-label"></div>
    <div class="box-content">
<p>While the Minimum Node Stake is 15,000 POKT, we highly recommend staking an amount greater than 15,000 the minimum in case of burning that may be caused by misconfiguration. Node runners have reported a stake of 15,100 POKT is a best practice.</p>
    </div>
</div>
<h2 id="-pokt-denominations">🔟 POKT Denominations</h2>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>The current denomination used by the protocol is defined by the <code>StakeDenom</code> parameter. When using the Pocket CLI or PocketJS library to send transactions to the network, you will need to use this denomination.</p>
    </div>
</div>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">Denomination</th>
<th style="text-align:left">Level</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">10^24</td>
<td style="text-align:left">EPOKT</td>
<td style="text-align:left">ExaPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^21</td>
<td style="text-align:left">PPOKT</td>
<td style="text-align:left">PetaPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^18</td>
<td style="text-align:left">TPOKT</td>
<td style="text-align:left">TeraPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^15</td>
<td style="text-align:left">GPOKT</td>
<td style="text-align:left">GigaPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^12</td>
<td style="text-align:left">MPOKT</td>
<td style="text-align:left">MegaPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^9</td>
<td style="text-align:left">KPOKT</td>
<td style="text-align:left">KiloPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^6</td>
<td style="text-align:left">POKT</td>
<td style="text-align:left">POKT</td>
</tr>
<tr>
<td style="text-align:left">10^3</td>
<td style="text-align:left">mPOKT</td>
<td style="text-align:left">MiliPOKT</td>
</tr>
<tr>
<td style="text-align:left">10^0</td>
<td style="text-align:left">uPOKT</td>
<td style="text-align:left">Micro or ‘you’POKT</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Upper Bound = 9,223,372,036,854,775,807,000,000 STAKED uPOKT
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>💻 App Economics</h1>

<h2 id="important-initial-application-parameters">Important Initial Application Parameters</h2>
<table>
<thead>
<tr>
<th>Item</th>
<th>Initial Parameter</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum Application Stake</td>
<td>1 POKT</td>
</tr>
<tr>
<td>Minimum Unbonding Period (Apps)</td>
<td>21 days</td>
</tr>
<tr>
<td>BaseRelaysPerPOKT</td>
<td>1.67 relays per session</td>
</tr>
<tr>
<td>Stability Adjustment</td>
<td>0</td>
</tr>
<tr>
<td>Participation Rate Active</td>
<td>False</td>
</tr>
<tr>
<td>Block Time</td>
<td>15 minutes</td>
</tr>
<tr>
<td>Session Time</td>
<td>4 blocks (60 minutes)</td>
</tr>
<tr>
<td>Session Node Count</td>
<td>5 nodes</td>
</tr>
<tr>
<td>Max Chains per Stake</td>
<td>15</td>
</tr>
</tbody>
</table>
<h2 id="application-economics">Application Economics</h2>
<p>Pocket Network is a developer-driven protocol, with demand from Applications driving the rewards the Service Nodes earn. Applications use Pocket Network to retrieve data and write state to and for their blockchain applications. Each Relay that is created by an Application results in the creation of newly-minted POKT as a reward for the Service Nodes facilitating such Relays. Applications stake just once to access the protocol (assuming they don&rsquo;t change their throughput), using the native cryptocurrency POKT which is tied for single-use to the Pocket blockchain.</p>
<p>The protocol limits the number of Relays an Application may access based on the number of POKT staked in relation to the Protocol Throttling Formula (as defined below). Once an Application stakes POKT, the Maximum Relays (<code>MaxRelays</code>) it can use is locked in perpetuity unless the Application re-stakes that POKT or their stake is burned.</p>
<p>Due to the oracle problem, the protocol cannot infer external factors that might influence the market price of POKT, or therefore account for these factors in the Protocol Throttling Formula. This introduces a risk to the demand side of the protocol, where fluctuations in the market price of POKT may affect the price Applications must pay for Relays.</p>
<p>We aim to allow the market to find a $USDPerRelay Target for POKT, to ensure the real price borne by Applications is within a relatively stable and acceptable range. This $USDPerRelay Target is not an on-chain variable, but a publicly agreed price that the DAO will target with its monetary policy, by adjusting variables in the Protocol Throttling Formula.</p>
<h2 id="calculating-throughput">Calculating Throughput</h2>
<p>When Applications stake POKT, their rate for the number of Relays they may access (MaxRelays) is locked in for the entire length of the stake. Due to the oracle problem, the protocol cannot infer external factors that might influence the market price of POKT, or therefore account for these factors in the Protocol Throttling Formula. This introduces a risk to the demand side of the protocol, where fluctuations in the market price of POKT may affect the price Applications must pay for Relays.</p>
<p>We aim to allow the market to find a $USDPerRelay Target for POKT, to ensure the real price borne by Applications is within a relatively stable and acceptable range. This $USDPerRelay Target is not an on-chain variable, but a publicly agreed price that the DAO will target with its monetary policy, by adjusting variables in the Protocol Throttling Formula.</p>
<p>When Applications stake POKT, their rate for the number of Relays they may access (MaxRelays) is locked in for the entire length of the stake. We use the following simple formula to calculate the amount of Relays Applications are entitled to per Session.</p>

<span class="math align-center">$$
MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput)
$$</span><p>These three variables, <code>StabilityAdjustment</code>, <code>ParticipationRate</code>, and <code>BaseThroughput</code> aim to dynamically reflect POKT&rsquo;s usage and ensure that Applications will be able to enter the ecosystem adjusting to changes in the market price of POKT.</p>
<p>To keep the real $USDPerRelay price as close to the $USDPerRelay Target as possible, the Protocol Throttling Formula multiplies <code>BaseThroughput</code> by the total <code>ParticipationRate</code> of the protocol to reflect any changes in demand for Relays, then the DAO will use the <code>StabilityAdjustment</code> in the short-term to correct deviations from the $USDPerRelay Target that are most likely attributed to short-term changes inherent in the random walk of the cryptocurrency/FOREX markets. If the StabilityAdjustment persists above/below zero without resetting, we can attribute the deviation from the $USDPerRelay Target to a more permanent change in POKT&rsquo;s market value, at which point the DAO will update BaseRelaysPerPOKT and reset StabilityAdjustment to zero.</p>
<p>Learn more about each variable below.</p>
<h2 id="stability-adjustment">Stability Adjustment</h2>
<p>The <code>StabilityAdjustment</code> parameter helps smooth out pricing for applications because there is a <a href="https://en.m.wikipedia.org/wiki/Menu_cost">menu cost</a> associated with changing <code>BaseRelaysPerPOKT</code> too often. Applications will be reliant on a relatively stable real <code>$USDPerRelay</code> price to access throughput. Community resources and consistent communication will help them make decisions about how much POKT to stake at any given moment.</p>
<p>Pocket&rsquo;s price target optimization problem will rely on off-chain data about a given currency&rsquo;s current exchange rate with POKT, e.g. using <code>$USDPerPOKT</code> to measure how close the real <code>$USDPerRelay</code> price is to the DAO&rsquo;s current <code>$USDPerRelay</code> Target. Short-term fluctuations will therefore be arbitrary depending on which currency has been chosen to anchor the DAO&rsquo;s price target against and what is happening day-to-day in the crypto and FOREX markets; today <code>$USDPerPOKT</code> might change by 5% but <code>€EURPerPOKT</code> only changes by 1%. It is important that we don&rsquo;t let short-term fluctuations impact the stability and accessibility of the network.</p>
<p>We can therefore use the <code>StabilityAdjustment</code> to dynamically adjust the <code>MaxRelays</code> computed in the Protocol Throttling Formula, while only changing our “menu price” (<code>BaseRelaysPerPOKT</code>) when there is a long-term deviation that can be more assuredly attributed to long-term changes in POKT&rsquo;s value.</p>
<p>The <code>StabilityAdjustment</code> will be updated at the discretion of the DAO.</p>
<h2 id="participation-rate">Participation Rate</h2>
<p>Not implemented initially, the <code>ParticipationRate</code> is a tool to dynamically adjust max relays for applications without the intervention of the DAO as network usage changes. <code>ParticipationRate</code>acts as a proxy for utilization of the network and is reflected on a block by block basis, adjusting an Application’s <code>MaxRelays</code> dynamically based on the growth or decline in network-wide stake rates. Participation Rate is calculated by:</p>

<span class="math align-center">$$
ParticipationRate = (appStakedPOKT + nodeStakedPOKT) / TotalPOKT
$$</span><p>The StabilityAdjustment and BaseRelaysPerPOKT help calibrate the natural ParticipationRate. Changes to the $USDPerRelay Target will be made by the Pocket DAO using a proposal system similar to MakerDAO’s <a href="https://community-development.makerdao.com/makerdao-mcd-faqs/faqs/stability-fee">Stability fee votes</a>.</p>
<p>As the protocol matures, the market will dictate what price Applications should be paying for Relays, reflected by the Pocket DAO deciding on the $USDPerRelay Target. As the on-chain MaxRelays for Applications adjusts over time, existing Applications with locked-in rates for MaxRelays will be faced with two scenarios:</p>
<ul>
<li>In a downside scenario, where the rate for MaxRelays drops below an Application’s current locked-in rate, Applications are incentivized to keep their POKT staked to continue receiving throughput at an above market rate.</li>
<li>In an upside scenario, where the rate for MaxRelays rises above an Application’s current locked-in rate, Applications will be incentivized to unstake and restake their POKT to receive more Relays for the same amount of POKT.</li>
</ul>
<p>Regardless of the scenario, applications are able to benefit from shifts in the market for POKT making the most of their stake.</p>
<h2 id="base-throughput">Base Throughput</h2>
<p>BaseThroughput is the baseline number of Relays we aim for an Application to get per POKT staked, assuming no external factors influencing POKT. This is calculated as:</p>

<span class="math align-center">$$
BaseThroughput = BaseRelaysPerPOKT * StakedPOKT
$$</span><p><code>BaseRelaysPerPOKT</code> is a uint64, governed by the Pocket DAO, which describes the baseline number of Relays the Pocket DAO aims for each Application to receive per POKT staked. As a multiplier, changing this number more significantly impacts MaxRelays than changing <code>StabilityAdjustment</code>. For further granularity, <code>BaseRelaysPerPOKT</code> can be expressed as:</p>

<span class="math align-center">$$
BaseRelaysPerPOKT = BaseRelaysPerPOKTNumerator / BaseRelaysPerPOKTDenominator
$$</span><p>This allows the protocol to express decimals in the form of fractional integers, enabling more granularity for the BaseRelaysPerPOKT number.</p>
<p>Due to the oracle problem, it is not possible to automatically adjust BaseRelaysPerPOKT based on the market price of POKT. The DAO will track indicators (such as ParticipationRate as well as the rate of change of new POKT being staked on the demand side), and adjust Pocket’s economic levers, as necessary, to ensure that Relays remain affordable for Applications.</p>
<p>To keep the real <code>$USDPerRelay</code> price as close to the <code>$USDPerRelay</code> Target as possible, the Protocol Throttling Formula multiplies <code>BaseThroughput</code> by the total <code>ParticipationRate</code> of the protocol to reflect any changes in demand for Relays, then the DAO will use the <code>StabilityAdjustment</code> in the short-term to correct deviations from the <code>$USDPerRelay</code> Target that are most likely attributed to short-term changes inherent in the random walk of the cryptocurrency/FOREX markets. If the StabilityAdjustment persists above/below zero without resetting, we can attribute the deviation from the <code>$USDPerRelay</code> Target to a more permanent change in POKT’s market value, at which point the DAO will update <code>BaseRelaysPerPOKT</code> and reset <code>StabilityAdjustment</code> to zero.</p>
<p>The <code>BaseRelaysPerPOKT</code> will be updated at the discretion of the DAO.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>🤖 Node Economics</h1>

<h2 id="overview">Overview</h2>
<p>Pocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of generalized mining or useful proofs of work, where inflation is directly tied to work validated by the network.</p>
<p>Service Nodes batch all requests received in a session to one Pocket blockchain transaction, a “Proof-of-Relay” that Applications can validate client-side and other nodes can validate in block production, removing the need for Applications to pay constant transaction fees for this work. Once those Proofs-of-Relays are validated by the network, a new block is confirmed, then POKT is minted and issued to the relevant Service Nodes as a reward for their work.</p>
<p>Service Nodes are pseudo-randomly assigned to a Session. Every Service Node who has staked the required node security deposit has an equal chance of being chosen in every available Session within the protocol regardless of how much POKT they have staked. New Sessions get created every 25 blocks with a new, pseudo-random set of Service Nodes.</p>
<h2 id="node-staking">Node Staking</h2>
<p>Like with applications, when nodes invoke the <code>StakeNode()</code> function, the minimum staking period is 21 days. The minimum stake at launch required to become a Service Node is 15,000 POKT. This node stake keeps nodes honest and incentivized to provide high quality service. Additionally, a node sufficient stake allows nodes to participate in PoS consensus as a Validator Node. Per the changes in <a href="https://forum.pokt.network/t/pip-7-consensus-rule-change-validator-servicer-split-validator-consolidation">RC-0.7.0</a>, not all nodes are validators, but all validators are service nodes. To become a Validator Node, you must be in the top 1,000 node stakes on the network. Validator Nodes can claim a block reward percentage for submitting the block equal to the value of the <a href="/learn/economics/nodes/../../protocol-parameters.md#proposerallocation"><code>ProposerAllocation</code></a> parameter.</p>

<div class="box notices cstyle danger">
    <div class="box-label"></div>
    <div class="box-content">
<p>While the Minimum Node Stake is 15,000 POKT, we highly recommend staking an amount greater than 15,000 the minimum in case of burning that may be caused by misconfiguration. Node runners have reported a stake of 15,100 POKT is a best practice.</p>
    </div>
</div>
<h2 id="distribution-of-service-nodes"><strong>Distribution of Service Nodes</strong></h2>
<p>While Pocket Network will depend on professional infrastructure providers to provide the bulk of the infrastructure for applications, due to the low marginal cost of running a full Service Node, we expect there to be a long tail of individuals running Service Nodes. There are two primary objectives that the network will focus on to avoid any stagnation in the number of Service Nodes in the network:</p>
<ul>
<li>Continuing to lower the barrier to entry for non-technical users to run full nodes by providing clear documentation as well as technical support in the bootstrapping days of the network</li>
<li>Ensuring that the minimum stake to become a Service Node within Pocket is kept low enough to maximize the number of nodes within the network</li>
</ul>
<p>Additional efforts to prevent stagnation include supporting distribution channels such as local mining pools through data centers, run-your-own node distribution partners and the Pocket DAO’s R&amp;D efforts.</p>
<p>Incentivizing the long tail of individuals running Service Nodes and keeping barriers to entry low is important to keep large node providers honest, and to minimize the odds of having an entire set of Service Nodes in a Session owned by one entity, which could lead to collusion attempts.</p>
<h2 id="optimal-deployment-strategy">Optimal Deployment Strategy</h2>
<p>The optimal economic strategy for node operators is to replicate as many Service Nodes as they can with the amount of POKT they hold, thereby spreading out their POKT holdings. By dispersing their stake amongst many Service Nodes, node operators maximize their chances of being chosen in as many Sessions as possible, providing them with the opportunity to serve Relays within the network. These incentives promote further decentralization, redundancy and the number of nodes available for each blockchain network supported by Pocket.</p>
<h2 id="cost-to-nodes">Cost to Nodes</h2>
<h3 id="upfront-costs">Upfront costs</h3>
<p>There are two initial costs to becoming a Service Node:</p>
<ul>
<li>Minimum Node Stake</li>
<li>Hardware (if chosen)</li>
</ul>
<h3 id="hardware">Hardware</h3>
<p>Pocket Network is neutral to the hardware utilized by Service Nodes, meaning that hardware can be a physical server that is run in a home or a local data center, or computing power can be purchased through popular cloud providers. The specs required for a Service Node’s hardware is dependent on the blockchain(s) that a Service Node chooses to support. For example, if a Service Node were to choose to support Ethereum, the server would need to have at least 1TB of storage (as of writing) to support an archival node for Ethereum.</p>
<h3 id="stake">Stake</h3>
<p>The minimum stake at launch required to become a Service Node is 15,000 POKT. This minimum stake also allows Service Nodes to participate in PoS consensus. If a Service Node stake falls below the minimum amount through serving incorrect data or incorrect block validation, 20% of the minimum stake for that Service Node will be slashed and jailed. If a Service Node submits a fraudulent Relay batch, 100% of their stake will be slashed. The initial amount of POKT needed to stake as a Service Node is not dynamic, but can be raised or lowered by the Pocket DAO to ensure a stable barrier to entry.</p>
<p>Once the initial costs of a Service Node are covered, the only additional cost is electricity and bandwidth for providing the computing power to complete Relays. Marginal costs for Service Nodes are extremely low and increase linearly as work increases.</p>
<h3 id="recurring-costs">Recurring costs</h3>
<ul>
<li>Cloud providers</li>
<li>Electricity</li>
<li>Bandwidth</li>
<li>Data center</li>
</ul>
<p>Outside of the fixed costs associated with running a node, Service Node operators will also incur costs like electricity, data center fees, and bandwidth costs for physical hardware. Alternatively, if they opt for a cloud-hosted service, they&rsquo;ll be paying an all-in fee for hosting. Again, these marginal fees are low, but will play a factor in node profitability and total node counts.</p>
<h2 id="economic-security">Economic Security</h2>
<p>The initial amount of POKT needed to stake as a Service Node is not dynamic, but can be raised or lowered by the Pocket DAO to ensure a stable barrier to entry.</p>
<h3 id="jailing-and-slashing">Jailing and Slashing</h3>
<ul>
<li><em>Jailing</em> a Validator removes them from both protocol service and consensus.</li>
<li><em>Slashing</em> a Validator burns a percentage of the &lsquo;Staked Tokens&rsquo;</li>
</ul>
<p>A Validator is jailed and subsequently slashed for not signing (or incorrectly signing) block proposals. More often than not, this is the reason why Validators are jailed.</p>

<div class="box notices cstyle danger">
    <div class="box-label"></div>
    <div class="box-content">
<p>If a Validator falls below the minimum stake (due to slashing) it will be forcibly removed by the protocol and all Staked Tokens burned. This feature of the protocol highlights the importance of staking &lsquo;well above&rsquo; the minimum stake.</p>
    </div>
</div>
<h3 id="jailing-penalties">Jailing Penalties</h3>
<p>A Pocket Validator Node can be jailed for 1 of 2 reasons:</p>
<ol>
<li>Fails to produce <code>min_signed_per_window</code> amount of blocks over a <code>signed_blocks_window</code>. When jailed because of this reason, a Pocket Validator Node is Slashed a <code>slash_fraction_downtime</code>% of their Stake.</li>
<li>For Double Signing a Block. When jailed because of this reason, a Pocket Validator Node is slashed a <code>slash_fraction_double_sign</code>% of their Stake.</li>
</ol>
<p>When a Pocket Validator Node becomes Jailed, it remains in the Staked list of Pocket Validator Nodes, however it becomes ineligible to become for Block Production or participating in <code>Sessions</code>. In order to become Unjailed again, and after waiting <code>downtime_jail_duration</code> nano-seconds, a Node Unjail transaction must be sent to the Pocket Network, and upon approval, the Pocket Validator Node will become Unjailed again.</p>

<div class="box notices cstyle danger">
    <div class="box-label"></div>
    <div class="box-content">
<p>If a Pocket Validator Node is left jailed for <code>max_jailed_blocks</code> blocks, it will be Force Unstaked.</p>
    </div>
</div>
<h3 id="double-sign-penalties">Double Sign Penalties</h3>
<p><a href="https://forum.pokt.network/t/pup-1-change-slashfractiondoublesign-to-0-000001/273">0.0001% percentage</a> of the validator&rsquo;s stake that will be slashed upon reporting of double vote Evidence type from Tendermint, where a double vote on a block is/can be a submission for two differing states, transactions, apphashes, etc. and result in a forked network.</p>
<h3 id="relay-challenges">Relay Challenges</h3>
<p>In order to participate in the network economic incentive mechanism, the Validator must first <strong>Claim</strong> and then <strong>Prove</strong> the completed work.</p>
<h3 id="burning-for-bad-fraud-proofs">Burning for Bad Fraud Proofs</h3>
<p>If a Service Node submits a fraudulent Relay batch, 100% of their stake will be slashed.</p>
<h3 id="economic-incentives">Economic Incentives</h3>
<p>For providing infrastructure access to applications, Validators are rewarded proportional to the work they provide. Pocket Core attempts to send a <em>Claim</em> and subsequent <em>Proof</em> transaction automatically after the <code>proof_waiting_period</code> elapses. If both transactions are successful, Tokens are minted to the address of the Validator.</p>
<p>Read more about <a href="/learn/economics/nodes/monetary-policy.md">Pocket monetary policy</a>.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>🏦 Monetary Policy</h1>

<p>Pocket&rsquo;s staking and inflation mechanisms enable a more efficient resource allocation structure by limiting the number of transactions (and thus block validation costs) to one-time staking transactions. All nodes are able to focus primarily on servicing and validating Relay requests by Applications, with minimal energy spent on block validation. By being <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventually consistent</a> and tying rewards directly to inflation, Service Nodes are in effect receiving micropayments for work validated by two parties without the need for constant on-chain fee payments.</p>
<h2 id="allocation-of-minted-pokt">Allocation of Minted POKT</h2>
<p>For each Relay served and validated by the protocol, POKT is added to the next block reward according to the mint rate. The following is a breakdown of each participant&rsquo;s share of the block reward given no parameter changes.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Participant</th>
<th style="text-align:left">Parameter Name</th>
<th style="text-align:left">Current Allocation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Service Nodes</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">85%</td>
</tr>
<tr>
<td style="text-align:left">Block Producer</td>
<td style="text-align:left"><a href="/learn/economics/monetary-policy/../protocol-parameters.md#proposerallocation">ProposerAllocation</a></td>
<td style="text-align:left">5%</td>
</tr>
<tr>
<td style="text-align:left">DAO</td>
<td style="text-align:left"><a href="/learn/economics/monetary-policy/../protocol-parameters.md#daoallocation">DAOAllocation</a></td>
<td style="text-align:left">10%</td>
</tr>
</tbody>
</table>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>Current values of these parameters (and all others) can be found on the <a href="/learn/economics/monetary-policy/../protocol-parameters.md">Protocol Parameters</a> page.</p>
    </div>
</div>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>The value for ProposerAllocation has recently changed. Please see <a href="https://forum.pokt.network/t/pup-19-increase-validator-reward-from-1-to-5-immediately/3169/13">PUP-19</a> for details.</p>
    </div>
</div>
<p>As part of the Proof-of-Stake consensus, each Service Node has a weighted chance of being selected to be the block producer for any given block based on the total amount staked for that given node. The block producer receives a portion of the entire block reward, as does the Pocket DAO, which provides continuous and sustainable funding for supporting the continued adoption and utility of Pocket Network.</p>
<h2 id="monetary-phases">Monetary Phases</h2>
<p>As the Pocket Network develops, we envision the POKT monetary policy evolving through three stages: Bootstrapping, Growth, and Maturity. The following sections will discuss each of these phases. Note that some of these ideas are forward-thinking and so are subject to change.</p>
<h3 id="bootstrapping-phase">Bootstrapping Phase</h3>
<p>During the bootstrapping phase of the network, it is important to build a strong foundation for the service, securing as many individual entities running nodes as possible. We do this by creating an environment where it is simple and inexpensive for initial Applications to access the network, and significantly profitable for Service Nodes to provide infrastructure.</p>
<p>Application usage and traction dictate the initial rewards that the Service Node pool will receive. By decreasing the barrier to entry for Applications (freemium access, low cost), the demand for Relays should be high during the Bootstrapping Phase, providing the initial pool of Service Nodes with ample opportunities to earn the high rate of POKT awarded for Relays serviced in the bootstrapping phase of the network.</p>
<p>As inflation and revenue increase per Service Node, the potential for competition increases, as rational, profit-seeking agents discover the protocol. This creates the flywheel to spur the network effects of Service Nodes purchasing and using POKT to participate until an equilibrium is found.</p>
<p>As the Protocol Throttling Formula adjusts to market demands, Applications being able to purchase more Relays results in more revenue for Service Nodes, further increasing the incentive for existing Service Nodes to re-stake their earned POKT. Increased participation in Pocket Network from Applications and Service Nodes ultimately benefits all parties by providing new revenue opportunities for Service Nodes and improving the service and resilience of the network for Applications. Due to Pocket Network being a permissionless Proof-of-Stake protocol and Service Nodes having an extremely low marginal cost of operation, the barriers to entry are significantly lower compared to Proof-of-Work mining based protocols. Pocket&rsquo;s economic primitives incentivize a diverse set of entities and individuals such as data centers, existing infrastructure providers and hobbyists to participate as node operators within the network.</p>
<h3 id="growth-phase">Growth Phase</h3>
<p>The growth phase is the period from launch which will see the greatest increase in the overall <code>ParticipationRate</code> of the protocol. When Applications stake during the growth phase, they earn more <code>MaxRelays</code> as the network grows (assuming they un-stake and re-stake), and don&rsquo;t pay for anything else until the network has matured and the Application Burn is activated.</p>
<p>One result of this is inflation. It is a priority of the DAO to manage inflation in a manner that encourages sustainable growth of the Pocket ecosystem, protects rewards against a potential decrease in relays, and sensibly updates rewards as Pocket Network grows.</p>
<p>If both sides of the marketplace (Applications and Service Nodes) grow, there will be continuous demand for Relays resulting in Service Nodes spinning up new Pocket nodes to increase the number of Relays they can service.</p>
<p>Early Applications will receive more infrastructure throughput as the network grows providing an incentive to early adopters of the network. When both the percentage of POKT staked and Service Node margins begin reaching their equilibrium, the protocol will have entered its maturity phase.</p>
<p>See the section below on inflation for more details.</p>
<h3 id="maturity-phase">Maturity Phase</h3>
<p>While the Growth Phase is inflationary, designed to incentivize active participation and supply-side staking for the security of the network, the Maturity Phase is designed to ensure the long-term sustainability of Pocket. The Maturity Phase is defined as the point in which Pocket Network has crossed equilibrium and the growth in inflation begins outpacing growth in the total staked supply of POKT.</p>
<p>This shift to long-term sustainability revolves around burning POKT to ensure the POKT supply is stable doesn&rsquo;t lose its value as a form of consideration to Service Nodes. In this phase, Pocket becomes similar to traditional Software as a Service pricing models, where Applications must &ldquo;top up&rdquo; their stakes periodically to avoid going below their needed Relay limit.</p>
<p>This should result in a decline in the <code>ParticipationRate</code> and Service Node margins due to an imbalance from more supply than demand for POKT.</p>
<p>In addition, to ensure the continued sustainability of POKT, to retain reasonable margins for Service Nodes, and to eliminate unnecessary overinflation of POKT, the Pocket DAO may activate an Application Burn Rate (ABR) at the Maturity Phase. This means that any POKT minting is balanced out by Application stake being burned at the same rate.</p>
<p>Once activated, the ABR results in a shift from Applications paying through dilution, to Application POKT being burned on a block by block basis to balance the minting of POKT as inflation awards to Service Nodes.</p>
<p>The effect of this is a logarithmic decay until the minimum App stake of 1 POKT is reached. Unless an Application increases the number of POKT they have staked, their holdings will fall under their desired amount causing applications to &ldquo;top up&rdquo; their stakes turning the network into a self-sustaining SaaS-like infrastructure protocol.</p>
<p>The rate of Application burn is determined by using indicators such as the decay in the growth of Application and Service Node stake over time.</p>
<h2 id="pokt-inflation">POKT Inflation</h2>
<h3 id="overview">Overview</h3>
<p>As the number of Nodes grows in the Pocket ecosystem, if we assume a constant per-relay payout, it follows that the total amount of POKT generated by the nodes will increase. While POKT was designed to be permanently inflationary, the high rate of inflation which this situation causes has strong repercussions for the network itself.</p>
<p>There are plenty of benefits to inflation, such as attractive rewards for new and existing participants, near term buying pressure from new node runners, and the ability to bootstrap new chains more easily. And excitement in the marketplace driven by node rewards can lead to increased adoption.</p>
<p>However, there are many drawbacks to excessive inflation, such as sell pressure which may reduce activity on the network, network underutilization and unnecessary hardware costs, and a general perception of long-term unsustainability.</p>
<p>With this in mind, the DAO has voted on implementing and ongoing adjustment to the value of the rewards per relay (in parameter form, known as <code>RelaysToTokensMultiplier</code>).</p>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>For more information and to read the actual DAO proposals on inflation management, please see the following:</p>
<ul>
<li><a href="https://forum.pokt.network/t/pup-11-wagmi-inflation/1369/1">PUP-11: WAGMI Inflation</a></li>
<li><a href="https://forum.pokt.network/t/pup-12-inflation-stop-gap-proposal-double-trouble/2011">PUP-12: Inflation Stop-Gap Proposal: Double Trouble</a></li>
<li><a href="https://forum.pokt.network/t/pup-13-initial-wagmi-parameters/2238">PUP-13: Initial WAGMI Parameters</a></li>
</ul>
    </div>
</div>
<h3 id="inflation-management">Inflation management</h3>
<p>The DAO&rsquo;s currently approved inflation management framework is called the Weighted Annual Gross Max Inflation rate (WAGMI).</p>
<p>A WAGMI target of 100% was implemented on Feb 28, 2022, which corresponds to a per-node reward of 0.008461 POKT/relay. It was previously set to 0.01 POKT/relay.</p>
<p>WAGMI targets will be stepped down to 50% over the following five months as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">WAGMI Target Inflation Rate</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Feb 28, 2022</td>
<td style="text-align:left">100%</td>
</tr>
<tr>
<td style="text-align:left">Mar 26, 2022</td>
<td style="text-align:left">90%</td>
</tr>
<tr>
<td style="text-align:left">Apr 25, 2022</td>
<td style="text-align:left">80%</td>
</tr>
<tr>
<td style="text-align:left">May 25, 2022</td>
<td style="text-align:left">70%</td>
</tr>
<tr>
<td style="text-align:left">Jun 24, 2022</td>
<td style="text-align:left">60%</td>
</tr>
<tr>
<td style="text-align:left">Jul 24, 2022</td>
<td style="text-align:left">50%</td>
</tr>
</tbody>
</table>
<p>The per-node reward (also known by its parameter value <a href="/learn/economics/monetary-policy/../protocol-parameters.md#relaystotokensmultiplier">RelaysToTokensMultiplier</a>) is calculated using:</p>
<ul>
<li>The 30-day trailing average of daily relays at the time of each adjustment</li>
<li>The total supply at the time of the proposal passing (&ldquo;Total Supply Baseline&rdquo;):</li>
</ul>

<span class="math align-center">$$
\text{Mint rate} = \frac{\text{Total Supply Baseline} \times \text{Inflation rate}}{\text{30-day trailing average of daily relays} \times \text{365 days}}
$$</span><p>The timestamp of the proposal was Feb 24, 2022, 6:37 GMT (block height: 51909), and the Total Supply Baseline was 945,014,989 POKT.</p>
<p>Also note that the DAO is empowered to recalculate the mint rate more frequently than the above monthly schedule in times of sharp increases or decreases in the amount of relays. In this case, a weekly recalculation may occur.</p>
<p>Recent recalculations:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Target inflation rate</th>
<th style="text-align:left">Approx. 30-day trailing avg. of daily relays</th>
<th style="text-align:left">Mint rate</th>
<th style="text-align:left">RelaysToTokensMultiplier</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[Initial]</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">0.010000</td>
<td style="text-align:left">10000</td>
</tr>
<tr>
<td style="text-align:left">Feb 24, 2022</td>
<td style="text-align:left">100%</td>
<td style="text-align:left">306,000,000</td>
<td style="text-align:left">0.008461</td>
<td style="text-align:left">8461</td>
</tr>
<tr>
<td style="text-align:left">Mar 25, 2022</td>
<td style="text-align:left">90%</td>
<td style="text-align:left">311,000,000</td>
<td style="text-align:left">0.007498</td>
<td style="text-align:left">7498</td>
</tr>
<tr>
<td style="text-align:left">Apr 1, 2022</td>
<td style="text-align:left">90%</td>
<td style="text-align:left">403,000,000</td>
<td style="text-align:left">0.005776</td>
<td style="text-align:left">5776</td>
</tr>
<tr>
<td style="text-align:left">Apr 8, 2022</td>
<td style="text-align:left">90%</td>
<td style="text-align:left">481,000,000</td>
<td style="text-align:left">0.004847</td>
<td style="text-align:left">4847</td>
</tr>
<tr>
<td style="text-align:left">Apr 25, 2022</td>
<td style="text-align:left">80%</td>
<td style="text-align:left">693,000,000</td>
<td style="text-align:left">0.002988</td>
<td style="text-align:left">2988</td>
</tr>
<tr>
<td style="text-align:left">May 31, 2022</td>
<td style="text-align:left">70%</td>
<td style="text-align:left">860,000,000</td>
<td style="text-align:left">0.002109</td>
<td style="text-align:left">2109</td>
</tr>
<tr>
<td style="text-align:left">Jun 30, 2022</td>
<td style="text-align:left">60%</td>
<td style="text-align:left">879,000,000</td>
<td style="text-align:left">0.001768</td>
<td style="text-align:left">1768</td>
</tr>
</tbody>
</table>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>💰 Pricing &amp; Economics FAQ</h1>

<h2 id="what-is-pokt">What is POKT?</h2>
<p>POKT is the native utility token that powers the economics of the protocol. Pocket Network requires both developers and nodes to stake POKT to participate in the network. Nodes earn POKT for fulfilling API requests for apps on a per request basis.</p>
<h2 id="how-much-does-it-cost-to-send-a-relay">How much does it cost to send a relay?</h2>
<p>This is determined by the <a href="/learn/economics/faq/../protocol-parameters.md#baserelaysperpokt"><code>BaseRelaysPerPOKT</code></a> parameter.</p>
<h2 id="how-much-can-i-earn-by-running-a-node">How much can I earn by running a node?</h2>
<p>Pocket is quite a unique blockchain network, because there are two ways for nodes to earn POKT:</p>
<ol>
<li><strong>Servicing:</strong> processing requests to/from blockchains on behalf of apps</li>
<li><strong>Validating:</strong> confirming blocks, which contain proofs of the above relays done</li>
</ol>
<p>Each time a block is validated, POKT is minted according to the <a href="/learn/economics/faq/../protocol-parameters.md#relaystotokensmultiplier"><code>RelaysToTokensMultiplier</code></a> parameter which means, for every relay processed by a node, this amount of POKT is minted.</p>
<p>This mint is then divided according to the following percentages:</p>
<ul>
<li><code>1 -(</code><a href="/learn/economics/faq/../protocol-parameters.md#proposerallocation"><code>ProposerAllocation</code></a><code>+</code><a href="/learn/economics/faq/../protocol-parameters.md#daoallocation"><code>DAOAllocation</code></a><code>)</code> to all the nodes who did #1, proportional to the number of relays they did</li>
<li><a href="/learn/economics/faq/../protocol-parameters.md#proposerallocation"><code>ProposerAllocation</code></a> to the node who validated the block (#2)</li>
<li><a href="/learn/economics/faq/../protocol-parameters.md#daoallocation"><code>DAOAllocation</code></a> to the DAO</li>
</ul>
<p>So what does this mean in practice?</p>
<p>Check out <a href="https://c0d3r.org/NetworkCharts">these charts</a> to view the profitability of nodes over the lifetime of the network.</p>
<h2 id="what-is-the-minimum-staking-amount-for-a-node">What is the minimum staking amount for a node?</h2>
<p>The minimum staking amount for nodes is determined by the <a href="/learn/economics/faq/../protocol-parameters.md#stakeminimum"><code>StakeMinimum</code></a> parameter.</p>
<p>However, if a node stake falls below this minimum stake the entire stake will be burned by the protocol. Therefore, as a <strong>best practice</strong>, we <strong>recommend staking an extra 7% to 10% buffer of POKT</strong> above the minimum stake per node. This is to account for any unforeseen slashing events due to node misconfiguration, bad behavior, natural disaster, or potential accidents.</p>
<h2 id="what-determines-my-odds-of-being-selected-to-validate-a-block">What determines my odds of being selected to validate a block?</h2>
<p>The following formula:</p>
<p><code>round down (node stake / avg node stake) = # of tickets in the hat for block producer</code></p>
<h2 id="is-there-an-advantage-to-staking-all-of-my-pokt-on-one-node">Is there an advantage to staking all of my POKT on one node?</h2>
<p>There is no advantage.</p>
<p>All nodes with the minimum stake have an equal chance of being selected to serve an app during a session. Therefore, to maximize the work you are being selected for, you should split your stake across as many nodes as possible, accounting for the minimum stake plus a buffer as described in <a href="/learn/economics/faq/faq.md#what-is-the-minimum-staking-amount-for-a-node">What is the minimum staking amount for a node?</a></p>
<p>Similarly, tickets for block production are weighted according to POKT staked in comparison to the average, based on the formula <a href="/learn/economics/faq/faq.md#what-determines-my-odds-of-being-selected-to-validate-a-block">above</a>, however it makes no difference to you whether this POKT is all staked on one node or across multiple.</p>
<h2 id="why-is-the-number-of-staked-nodes-growing-faster-than-the-number-of-staked-apps">Why is the number of staked nodes growing faster than the number of staked apps?</h2>
<p>While it&rsquo;s true that the supply (nodes) of Pocket&rsquo;s two-sided market should respond to demand (apps), the important metric is the number of relays, not the number of staked apps.</p>
<p>Nodes are paid proportionally to the relays they process, so if the number of staked apps remains constant while the relays the submit increases, the node supply will grow in response to growing revenue opportunities.</p>
<p>Many apps use the <a href="https://portal.pokt.network">Pocket Portal</a> to connect to the network, which stakes and integrates with <a href="https://docs.pokt.network/js">PocketJS</a> on their behalf. The Dashboard can divide the throughput it has staked for across multiple URLs, which means we don&rsquo;t need to stake a new account for every new app that uses the Dashboard.</p>
<h2 id="how-do-i-buy-pokt">How do I buy POKT?</h2>
<p>Visit this <a href="https://forum.pokt.network/t/secondary-markets-for-pokt/629">forum post</a>.</p>
<h2 id="what-is-the-supply-of-pokt">What is the supply of POKT?</h2>
<h3 id="genesis--circulating-supply">Genesis &amp; Circulating Supply</h3>
<p>The initial supply of POKT is 650M, which is divided according to the following genesis distribution:</p>
<p><img src="/images/initial-distribution.jpg" alt="">
The vast majority of these tokens are non-transferable and subject to use restrictions by the holders, starting from mainnet launch. __</p>
<ul>
<li><strong>Private Sale 1/2:</strong> one-year lockup and use restriction from the date of purchase. Those whose year had already expired pre-mainnet also agreed to an additional lockup according to the following schedule: 50% of tokens unlocked after 6 months, 100% of tokens unlocked after 12 months.</li>
<li><strong>Founder Vesting:</strong> the founders agreed to restart a 3 year vesting schedule upon mainnet launch, with 10% of their allocations immediately vesting upon mainnet launch and subject to a 1-year lockup and use restriction. __</li>
<li><strong>Pocket Network, Inc. (PNI)</strong>:
<ul>
<li><strong>Token Sale Pool:</strong> fully unlocked at launch and available for direct sale to users of the network. __</li>
<li><strong>Employee/Contractor Pool:</strong> already-vested tokens subject to a 1-year lockup and use restriction, with varying vesting agreements per contractor on average of 3-4 years.</li>
<li><strong>PNI Reserves:</strong> subject to 4 years of vesting and non-transferable for five unbonding periods (105 days total) following mainnet launch. __</li>
</ul>
</li>
<li><strong>Foundation/DAO:</strong>
<ul>
<li><strong>Foundation Reserves:</strong> subject to 4 years of vesting and non-transferable for five unbonding periods (105 days total) following mainnet launch. __</li>
<li><strong>DAO Funds:</strong> fully unlocked at launch and distributed according to DAO grants.</li>
<li><strong>All other genesis addresses (e.g. incentivized testnet participants):</strong> non-transferable for five unbonding periods (105 days total) following mainnet launch.</li>
</ul>
</li>
</ul>
<p>This all results in the following circulating supply schedule:</p>
<p><img src="/images/circulating-supply-schedule.jpg" alt=""></p>
<h3 id="fully-diluted-supply">Fully Diluted Supply</h3>
<p>While the initial total supply of POKT is 650M, Pocket Network uses minting to compensate nodes for performing work on the network. For this reason, POKT is permanently inflationary proportional to usage of the network, i.e. proportional to the number of relays being processed by nodes, but the total supply will be capped through a burning mechanism put in place by the DAO (more on this below).</p>
<p>The Growth Phase of the network is characterized by relatively high rewards and an increase in the POKT supply designed to subsidize the bootstrapping of the network from a node and application perspective.</p>
<p>Once the growth rate of relays begins to decrease because Pocket Network has saturated the broader decentralized infrastructure market, Pocket Network will enter the Maturity Phase. It&rsquo;s at this point that the DAO can choose to institute the Application Burn Rate (ABR) which burns developers’ stake at a rate that offsets future inflation - capping the total supply of POKT. The ABR caps the total amount of POKT and ushers in network equilibrium where mint and burn rate is equal. This is reflected in our model by a flattening in the growth in POKT. In all three scenarios, ABR is instituted at the same time but could happen earlier or later as the DAO sees fit.</p>
<p>You can read more about these topics in the section on <a href="/learn/economics/faq/monetary-policy.md">Monetary Policy</a>.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
          <article class="chapter">
<div class="article-subheading">Chapter 8</div>
<h1>👀 Future (v1)</h1>

<p>Pocket Network launched on mainnet on July 28th 2020, with the singular goal of providing a utilitarian economy between Web3 applications and the full nodes that provide access to the data they need. Since launching, Pocket Network has demonstrated that a decentralized alternative to full node infrastructure is not only possible, but with the right architecture could provide a service that is unmatched. Further, the lessons we have learned maintaining the network have highlighted a path towards a truly scalable future for Pocket Network’s Web3 infrastructure. These are the possibilities that v1 seeks to achieve.</p>
<p>When we started working on Pocket Network, we were a scrappy startup with months of runway. For our vision to survive, we had to build our concept as lean as possible. This is where Tendermint Core came in, a general-purpose framework for building applications that require their own application specific blockchain. This provided us with the minimum viable networking and BFT consensus stack we needed to build a kickstart our vision. But, as we have grown, we have continued to push the limits of Tendermint’s general-purpose capabilities. We have made so many changes over the years that Pocket Network is now unrecognizable compared to the typical Tendermint ABCI application. These changes have allowed us to scale Pocket Network to the largest Tendermint network out there, exceeding 27,000 nodes while Tendermint was built to handle at most 10,000.</p>
<p>We have come to realize that, to reach our true vision of unstoppable Web3 infrastructure network with millions of nodes serving quadrillions of relays, we need to bid farewell to Tendermint and build our own stack from the ground up using all of the lessons we have learned after 1.5 years of mainnet optimized for Pocket&rsquo;s use case.</p>
<p>v1 will contain 4 specialized modules that are optimized for Pocket Network’s core utility:</p>
<ul>
<li><a href="/learn/future/utility.md">Utility</a></li>
<li><a href="/learn/future/consensus.md">Consensus</a></li>
<li><a href="/learn/future/peer-to-peer.md">Peer-to-Peer</a></li>
<li><a href="/learn/future/persistence.md">Persistence</a></li>
</ul>
<p>v1 will also be the catalyst for an enhanced engineering process that is more inclusive of the community, with robust laboratory infrastructure for responsive experimentation, QA, visibility, tooling and tighter development feedback loops. This is an R&amp;D project with at least 1 year of work anticipated before the launch of v1.0 mainnet. We are revealing our vision to the community at this stage to empower everyone to get involved in our new development cycle:</p>
<ul>
<li>You can follow along the R&amp;D cycle in <a href="https://github.com/pokt-network/pocket">GitHub</a>.</li>
<li>You can post your research ideas in the <a href="https://forum.pokt.network/c/research/47">Pocket Forum</a>.</li>
<li>You can chat about anything v1 in <a href="https://discord.gg/Bk7J4Cy6CC">Discord</a>.</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
          <article class="default">
<h1>🪙 Utility</h1>

<p>Pocket Network has always been designed to do one thing and do it well: provide a utilitarian economy that coordinates unstoppable Web3 access. In the context of the v1.0 Utility Module, this means we are laser-focused on optimizing the existing utility of the network, not expanding the scope of our utility.</p>
<p>This means optimizing how effectively we coordinate Web3 access, which can be broken down into two categories:</p>
<ul>
<li><strong>Relay Quality</strong>: RPC node (Servicer) incentives should be as tightly-coupled as possible to relay quality, so that Pocket Network’s service not only matches centralized providers’ but provides a level of quality, unique to Pocket’s architecture, that can’t be matched</li>
<li><strong>Relay Scalability:</strong> our protocol should be as scalable as possible, to maximize the number of relays that the network can process and optimize the efficiency (and thus cost) of the service</li>
</ul>
<h2 id="relay-quality">Relay Quality</h2>
<h3 id="quality-enforcement">Quality Enforcement</h3>
<h4 id="v0--client-side--layer-2-enforcement">v0 – Client-side + Layer-2 Enforcement</h4>
<p>When we first designed Pocket Network, we assumed that service quality would be ensured through a Darwinian competitive dynamic. Indeed, there is a weak incentive to perform better on latency/volume to maximize relays processed, though this is insufficient to ensure quality on all metrics.</p>
<p>To address this, we included a simple client-side validation mechanism known as a challenge transaction, which enables Apps to protest the rewards that Servicers earned for low-quality work. However, 1.5 years into mainnet, challenge transactions have never been utilized, likely since the Portal does quality checks before it sends relays. We’ve learned that client-side validation is an insufficient model to rely upon because it 1) results in Apps experiencing quality failures before they are corrected, 2) forces Apps to choose between validating relays and maximizing relay speed.</p>
<p>The Portal is our gateway drug. It is a web application that stakes Pocket Apps on behalf of developers, and allows us to provide the simple RPC endpoints that apps have come to expect from centralized providers. Currently, the Portal administers the majority of the protocol’s App stakes to ensure service quality while we bootstrap new chains. In 2021 we developed various layer-2 <a href="https://forum.pokt.network/t/cherry-picker-improvements-dec-2021/1332">cherry-picking methods</a> through the Portal to ensure that Apps receive service from the highest-quality Servicers available in each Session. These methods have laid the groundwork for the on-chain quality enforcement that we will be introducing in v1.0.</p>
<p><img src="/images/utility-v0.png" alt="Utility v0 High Level Overview"></p>
<h4 id="v10--on-chain-enforcement">v1.0 – On-chain Enforcement</h4>
<p>The Portal is a service that builds on the Pocket Network, managing app stakes on behalf of Apps and providing quality of service checks. Maintaining this core service has shown us how critical quality assurance is to our core utility, so we decided to take these lessons and move them on-chain.</p>
<p>We have considered a world in which other people deploy their own Portals and compete to provide the best layer-2 quality enforcement. However, we realized that Portals would fall to the tragedy of the commons; they are simultaneously expensive to run and inherently altruistic. The only way this could be resolved off-chain is through economies of scale and extractive pricing. Sound familiar? If we went down this route, we would no longer be solving the incentive problem we saw in the full node ecosystem, we’d simply be pushing it further up the stack.</p>
<p>To solve this in a manner compatible with our trustless vision, the protocol needs to directly incentivize actors on-chain to enforce quality according to a standardized ruleset. Enter the Fishermen. These are a new set of actors who can disguise themselves as Apps and sample the quality provided by Servicers.</p>
<p>Fishermen measure the quality of relays across three key metrics according to a standardized sampling protocol:</p>
<ul>
<li><strong>Availability:</strong> Since Fishermen, Apps, and Servicers are all time-synced according to the session protocol, time-based sampling can be used to assess the availability of the Servicer. If no signed response can be collected from a Servicer, a null sample is recorded for the sample time slot. The more null samples the worse the Servicer’s availability score.</li>
<li><strong>Latency:</strong> The time it takes for the Fisherman to receive a signed response from the Servicer (i.e. Round Trip Time) is another metric that is tracked. Due to normal variances in latency to be expected from the varying geographical distance between Apps and Servicers, these metrics are used to disincentivize high-average latency rather than explicitly rewarding the highest-performing Servicers.</li>
<li><strong>Consistency:</strong> In addition to time-based sampling, it is mandatory for Fishermen to sample all Servicers in a session at once. The Fishermen can then compare responses and measure data consistency without needing their own comparative Web3 datasource.</li>
</ul>
<p><img src="/images/Fisherman1.png" alt="The Fisherman sends sampling requests to all Servicers to collect data about all 3 quality metrics">
Fishermen compile these samples into test scores for each Servicer, which are averaged out across Fishermen over time, ultimately determining the proportion of block rewards that Servicers receive. Fishermen are not incentivized to influence test scores because they are paid based on the quantity and completeness of their reports, not the content of the metrics being reported.</p>
<p><img src="/images/utility-v1.png" alt="Utility V1 High Level Overview"></p>
<h3 id="quality-incentives">Quality Incentives</h3>
<h4 id="v0--quantity-based">v0 – Quantity-based</h4>
<p>89% of v0 block rewards are distributed to Servicers proportional to the volume of relays they served. This means Pocket Network’s incentives currently optimize for the quantity of work done, not the quality of work done.</p>
<h4 id="v10--quality-based">v1.0 – Quality-based</h4>
<p>v1.0 prioritizes quality over quantity; block rewards are distributed to Servicers according to the aggregate test scores submitted by Fishermen.</p>
<p>The total salary for Servicers is still proportional to the volume of relays performed on aggregate. However, this is divided between Servicers in proportion to their test scores. Each Servicer above the MinimumReportCardThreshold is eligible for an equal salary from the total pool for their RelayChain or GeoZone but has their allocation burned by the difference between their ReportCard% and 100%.</p>
<p><img src="/images/service-rewards.png" alt="This diagram illustrates how service rewards are divided equally then burned by the difference between their ReportCard% and 100%, assuming a burn coefficient of 1."><!-- raw HTML omitted --></p>
<p>These incentives enable Pocket Network to probabilistically guarantee a Service Level Agreement for applications.</p>
<h2 id="relay-scalability">Relay Scalability</h2>
<h3 id="proving-relays">Proving Relays</h3>
<h4 id="v0--pessimistic-proofs-of-relays">v0 – Pessimistic Proofs of Relays</h4>
<p>v0 is pessimistic about proving work done; guilty until proven innocent. To validate the volume of relays they completed, Servicers must generate plasma merkle trees, store relay evidence, and create merkle proofs, which will then be validated by Validators, as part of a multi-step Zero Knowledge Range Proof.</p>
<p>This works very well as secure cryptography but it scales linearly because plasma merkle trees have O(<strong>n</strong> log(<strong>n</strong>)) space complexity, where <strong>n</strong> is the number of relays, and the branch must be included in every proof transaction. In practice, this means proofs get more expensive to process in proportion to relays, which contributes to higher CPU loads and longer block processing times.</p>
<p>If Pocket Network is to grow to serve quadrillions of relays, the relay proof lifecycle must be fundamentally restructured.</p>
<h4 id="v10--optimistic-proofs-of-samples">v1.0 – Optimistic Proofs of Samples</h4>
<p>Work payments in v1.0 are optimistic, more like a salary compared to v0’s unit-based payments.</p>
<p>The total salary pool is still proportional to the volume of relays performed on aggregate. To determine the size of this total available reward, Fishermen probabilistically estimate volume using probabilistic hash collisions rather than counting up (and proving) every relay.</p>
<p>The Fishermen samples themselves are also optimistic. Fishermen only need to submit test scores on a pseudorandom schedule and only need to verify a single pseudorandomly selected non-null sample. Since the Fishermen (and Servicers) can’t predict which test scores will be submitted or which samples will need to be verified, the monitoring system remains a secure deterrent of bad behavior while avoiding the cost that would come from validating every test score.</p>
<p><img src="/images/Test1.png" alt="">
<img src="/images/Test2.png" alt="We only need to submit a subset of test scores and prove a subset of samples">
By switching to an optimistic model, we reduce both the frequency and size of proofs, which should allow relays to scale exponentially rather than linearly.</p>
<h3 id="creating--validating-proofs">Creating &amp; Validating Proofs</h3>
<h4 id="v0--unified-actors">v0 – Unified Actors</h4>
<p>In v0, until recently, Validators and Servicers were bundled together. This meant that the scalability of Servicers was bound by Validators, for two reasons:</p>
<ul>
<li>Validators are subject to the scalability of the BFT consensus algorithm, which is arguably the least scalable component of our protocol by design</li>
<li>Servicers are burdened with performing expensive Validator tasks, even though these aren’t necessary to perform Servicer tasks</li>
</ul>
<p>We have already begun moving away from this model with the separation of Validators and Servicers in v0.7. Limiting Validators to the top 1,000 by stake has allowed our Servicer count to grow to almost 25,000 without impacting the health of our blockchain. v1.0 will take this a step further.</p>
<h4 id="v10--task-based-specialization-of-actors">v1.0 – Task-based Specialization of Actors</h4>
<p>We have already agreed that Servicers shouldn’t need to validate proofs. Taking this a step further, why should they need to prove their own work? In v0, Servicers must constantly store claims and proofs if they want to get paid, which presents a computational burden that distracts them from optimizing on their most important tasks: relaying RPC requests.</p>
<p>In v1.0, we are more explicitly separating actors according to their tasks. We are introducing the Fisherman, whose sole responsibility is to prove the quality of work done. This narrows the scope of Servicer work to just performing relays, which should make it cheaper to perform relays and thus dramatically enhance the efficiency of the network’s core task.</p>
<h2 id="v10-utility-roadmap">v1.0 Utility Roadmap</h2>
<h3 id="1-proto-fish">1. Proto-Fish</h3>
<p>We will begin live-testing the Fisherman sampling methods in v0, using the Portal as a low-risk supervised environment.</p>
<h3 id="2-castaway">2. Castaway</h3>
<p>When v1.0 launches, we will begin with a single DAO-governed Fisherman. This will enable us to adopt all the benefits of v1.0, with the Fisherman actor being the only trusted actor in the network.</p>
<h3 id="3-fishermen">3. Fishermen</h3>
<p>We will then transition to a multi-Fisherman model, wherein DAO governance can appoint and remove Fishermen, burning them to penalize bad behavior.</p>
<h3 id="4-cast-net">4. Cast-Net</h3>
<p>Finally, Fishermen will become truly trustless actors as the monitoring/enforcement of their behavior is moved entirely on-chain.</p>
<h2 id="more-details">More Details</h2>
<p>Read more details about the <a href="https://docs.pokt.network/v1/utility">v1.0 Utility module spec</a>.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>🤝 Consensus</h1>

<p>The consensus module coordinates Validators to come to agreement that the transactions in a block are legitimate before the block is added to the blockchain. Currently, v0 inherits its consensus implementation from Tendermint. While Tendermint provides a great framework for building applications that can handle arbitrary computation, it is not optimized for Pocket Network&rsquo;s singular focus of coordinating unstoppable Web3 access.</p>
<p>Some of the major changes to the consensus module for v1.0 include:</p>
<ul>
<li>Replacing Tendermint BFT with HotStuff BFT</li>
<li>Migrating from a Round Robin leader selection process to a blind, pseudorandom leader selection process</li>
<li>Allowing the Block Proposer to validate transactions against the mempool before including them in a block</li>
</ul>
<p>For the network as a whole, these changes will enable more consistent block times. For those running nodes, these changes will allow for:</p>
<ul>
<li>Less bandwidth and compute resources spent communicating with other nodes during consensus</li>
<li>Less storage usage, as invalid transactions will no longer be included in blocks</li>
<li>Block creation rewards proportional to the amount staked.</li>
</ul>
<h2 id="a-primer-on-consensus">A Primer on Consensus</h2>
<p>The two most popular types of consensus algorithms are Nakamoto and Byzantine Fault Tolerance (BFT).</p>
<h3 id="nakamoto">Nakamoto</h3>
<p>In Nakamoto consensus, the network chooses to follow the longest chain. This is the consensus mechanism that Bitcoin, Ethereum 1.0, and most Proof of Work chains currently use. As long as someone can submit a valid proof of work, they can add a block to the chain.</p>
<p>In case the block added was fraudulent, whether maliciously or accidentally, whoever submits the next block can choose to do so from whichever point they wish, creating a fork in the chain. If the network adopts this new chain enough that it becomes the longest, this results in what&rsquo;s known as a chain reorganization. This is why applications that make transactions on these chains often wait for a number of &ldquo;confirmations&rdquo;, because the chain can potentially reorganize at any point. This process of waiting for transactions accomplishes something called probabilistic finality.</p>
<p>Probabilistic finality works well for coming to consensus on events that have already occurred, however, since Pocket Network uses the current state of the blockchain to determine which Servicers to match Apps with, Nakamoto consensus is incompatible with the Utility module.</p>
<h3 id="bft">BFT</h3>
<p>In BFT consensus algorithms, Validators must come to agreement before adding any blocks to the chain. The name comes from the &ldquo;Byzantine generals problem&rdquo;, a thought experiment that dealt with how a group of military generals, who could not communicate directly with each other, could come to a decision about whether to attack or flee. This issue doesn&rsquo;t just deal with the case of the general being a malicious actor, but also the case of the messenger being the one who changed the vote, or simply not being able to deliver the message. In a computer system, Byzantine faults are used to describe errors that can occur from an actor either being compromised or faulty. These types of consensus mechanisms, while useful for blockchain consensus, were originally developed to enable aircraft to rely upon their sensor data to make software decisions as long as a certain threshold of their sensors were always in agreement.</p>
<p>Where Nakamoto consensus can probabilistically resolve fraudulent blocks through its longest-chain selection process, BFT instead opts to require consensus on the next block before moving forward with the chain. Since Pocket Network’s Utility module requires a single state from which to maintain coordination between Servicers and Apps, BFT is the obvious choice.</p>
<h2 id="the-consensus-algorithm">The Consensus Algorithm</h2>
<h3 id="v0--exponential-communication-complexity">v0 – Exponential Communication Complexity</h3>
<p>The Tendermint BFT consensus algorithm has served Pocket Network well but will hold us back because communication complexity scales exponentially in proportion to the number of nodes, for two reasons:</p>
<ul>
<li><strong>Network-Wide Random Gossip:</strong> Every node in the network must pass on what every other node has told them, including Servicers. The more nodes there are, the more node-node messages must be sent and received, resulting in an exponential volume of messages. If Pocket Network is to continue scaling to hundreds of thousands of nodes, this gossip process must be fundamentally restructured, otherwise the communication bandwidth required will become insurmountable.</li>
<li><strong>Pessimistic Responsiveness:</strong> When voting on a block, the network must wait for all nodes to vote (or wait a minimum period of time) before moving on, even if enough votes have already been cast to reach consensus. This can make the network more vulnerable to chain halts if not enough nodes can keep up with the voting process.</li>
</ul>
<h3 id="v10--linear-communication-complexity">v1.0 – Linear Communication Complexity</h3>
<p>We will be solving these issues in v1.0 by switching to our own implementation of the HotStuff BFT consensus algorithm: HotPocket. The biggest advantage of this algorithm is that it uses validator-specific structured gossip and optimistic responsiveness to significantly reduce communication complexity.</p>
<p><img src="/images/hot-stuff.png" alt=""></p>
<ul>
<li><strong>Validator-Specific Structured Gossip:</strong> HotPocket selects a small group of nodes to be responsible for listening for messages and then broadcasting gossip to everyone. This means instead of sharing messages with everyone, nodes only have to share with the selected listeners, which allows communication bandwidth to scale exponentially with the number of Validators.</li>
<li><strong>Optimistic Progress:</strong> HotPocket introduces a new phase in the consensus process. During this phase, Validators must acknowledge that they have seen the block proposal going up for a vote. When it comes to the voting phase, any Validators who did not acknowledge the proposal can be dismissed and the chain can move on with majority consensus as long as the present Validators approve it. Along with this, we have a custom pacemaker module that ensures consistent block times, which are critical for the time-synced mechanisms in the Utility module.</li>
</ul>
<h2 id="the-leader-selection-process">The Leader Selection Process</h2>
<h3 id="v0--round-robin">v0 – Round Robin</h3>
<p>Tendermint uses Round Robin to determine the next leader who will propose the next block. This makes the blockchain vulnerable to DDoS attacks since we know exactly who the next leaders are going to be and when. We have already modified Tendermint’s Round Robin to use a pseudorandom selection algorithm where the hash of the previous block determines the next leader.</p>
<h3 id="v10--vrf--cdfs">v1.0 – VRF + CDFs</h3>
<p>In v1.0, we are leveraging Verifiable Random Functions (VRFs) for more secure pseudo-random leader selection that is unpredictable before the block production, yet deterministic and computationally cheap to verify afterwards. Whereas v0 uses the previous block hash to generate leaders, v1.0 uses the VRF secret keys of other Validators which are impossible for the proposer to know. VRFs are combined with Cumulative Distribution Functions (CDFs) to enable selection to be weighted based on the amount staked by the Validator. Because it is probabilistic, it is possible for the VRF to generate 0 proposers, in which case we fallback to the v0 Round Robin process.</p>
<h2 id="handling-invalid-transactions">Handling Invalid Transactions</h2>
<h3 id="v0--block-proposer-cant-validate">v0 – Block Proposer Can&rsquo;t Validate</h3>
<p>Since Tendermint was designed to support arbitrary computation, there were risks for them allowing the block proposer to validate transactions against the mempool. Since the state of the mempool changes as transactions come in, there is currently no way for the block proposer to know if transactions are valid before proposing them in a block. For chained and dependent transactions that rely on ordering, this can cause problems of unexpected failed transactions. Since transactions aren’t validated until they’re included in the block, this leads to the chain being bloated with meaningless failed transactions, which makes indexing and processing transactions harder, ultimately wasting resources.</p>
<h3 id="v1--block-proposer-can-validate">v1 – Block Proposer Can Validate</h3>
<p>Since Pocket Network isn&rsquo;t a blockchain built for arbitrary computation, and instead built for a specific purpose, we can make guarantees about what computations would occur if the block proposer tried to validate transactions against the mempool. This means that it is possible for the block proposer to filter invalid transactions before proposing a block. This will greatly help to reduce the storage requirements of the chain as well as making it easier to index and process transactions.</p>
<h2 id="more-details">More Details</h2>
<p>Read more details about the <a href="https://docs.pokt.network/v1/consensus">v1.0 Consensus module spec</a>.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>💬 Peer to Peer</h1>

<p>The Peer-to-Peer (P2P) module is responsible for handling how all the nodes in the network communicate with each other when new transactions need to be added to a block and when the new block gets added to the chain. Currently, v0 pairs peers together randomly. This random pairing was chosen to ensure redundancy across the network, however, as Pocket Network continues to grow, the redundancy and complexity of random pairing require more bandwidth as more nodes come online – with a good chunk of that bandwidth being used to retrieve copies of information the nodes have already seen.</p>
<p>In v1.0, the P2P module will transition from random communication to structured communication. For those running nodes, this transition means a significant reduction in bandwidth usage. For the network as a whole, this means more efficient and scalable communication, while maintaining the required redundancy. This will move the P2P system from having low visibility and a large amount of message duplication to having high visibility and less message duplication.</p>
<h2 id="a-primer-on-p2p-a-hrefa-primer-on-p2p-ida-primer-on-p2pa">A Primer on P2P <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>There are three primary components of the P2P system that all contribute to the reliability and speed of the network. Those components include Event Dissemination which handles how nodes will be paired to communicate with each other, Membership and Churn which handles knowing when nodes either come online or go offline, and the Transport Layer which controls the mechanism used to actually send and receive messages between peers. Some of these problems are problems that can apply to networking across the board, while others are unique to P2P networks specifically. The requirements of building an effective P2P communication network include:</p>
<ol>
<li><strong>Efficiency and Scalability</strong> – making sure that more peers can connect without a major impact to the network performance</li>
<li><strong>Fault and Partition Tolerance</strong> – despite any number of breakdowns that happen between nodes, the network can continue to operate</li>
<li><strong>Managing Membership and Churn</strong> – effectively communicating when a peer both joins and leaves the network.</li>
</ol>
<p>While there are a large variety of existing P2P implementations out in the wild, each implementation has made design decisions based on specific needs that don&rsquo;t translate to the needs of Pocket. In choosing the design for the v1.0 implementation, it was important to understand the fundamental needs of Pocket Network. There are three types of communications that are fundamental to how Pocket Network operates.</p>
<ol>
<li>Servicers need to be able to inform the network of transactions made</li>
<li>Validators need to be able to communicate with each other during consensus and with the whole network when a new block is created</li>
<li>Archival nodes need to be informed of new blocks, as well as handling and making requests for new blocks.</li>
</ol>
<p>From these three main types of communication, we can specifically say that the P2P module of Pocket Networks needs to be able to:</p>
<ol>
<li>Communicate blocks and transactions across the network</li>
<li>Restrict communications to only the groups who are needed for those communications.</li>
</ol>
<h2 id="event-dissemination">Event Dissemination</h2>
<h3 id="v0--random-gossip">v0 – Random Gossip</h3>
<p>Currently, Pocket Network communicates information about blocks and transactions through random gossip. When a node learns of a new piece of information, they pass that information along randomly to other nodes in the network. This random process ensures that the data can make its way through the network, regardless of failures between certain pairs of nodes. This process, while ensuring redundancy, does so in a way that requires nodes to spend bandwidth and resources receiving the same message multiple times.</p>
<p>Building on this, because nodes randomly select other nodes to share this information with, nodes will share and receive information regardless of whether that is information they need. Gossip about the consensus process is only relevant to nodes who are acting as Validators. Gossiping with every Servicer and Archival node about the validation process not only takes away resources from those nodes but it slows down the gossip phase of the consensus process.</p>
<h3 id="v10--structured-gossip">v1.0 – Structured Gossip</h3>
<p>RainTree is a gossip protocol that leverages the efficiency that Binary Trees provide for lookups of sorted, randomly-distributed data. RainTree provides the mechanism to ensure delivery, offer redundancy against non-participation without needing retries or acknowledgements, and perform a cleanup to ensure 100% message propagation in all cases.</p>
<p>The process starts with a node that wishes to gossip a message to all other peers in the network. Once the node has a sorted list of all other peers in the network, it needs to:</p>
<ol>
<li>Build a binary tree based off the sorted list, with the left branch being the peer at 33%, and the right branch being the peer at 66%, with a third branch that points back to itself</li>
<li>Determine its own and max depth of the tree</li>
<li>Gossip messages to all depths of the tree.</li>
</ol>
<p>The peers on the left and right branches then build their own subsections of the tree using the above, and the process continues. This third branch is there to add redundancy. When the node begins gossiping down the tree, it will, eventually, reach the point where it has to send itself the message. Once it has reached this point, the node is able to send it to not just the left and right as expected but also every other node in the originally sorted list.</p>
<p>Since networks are vulnerable to nodes dropping out at any point, if one of the branches does not acknowledge that it received the message, the node that tried to communicate with them will then readjust and send the message to the children that would have received the message from the unresponsive parent.</p>
<p><img src="/images/good-node-delivery.png" alt="A successful transmission to the left and right nodes.">
<img src="/images/bad-node-delivery.png" alt="An unresponsive right node means that the children of that node need to be notified directly">
To be 100% certain that all functional nodes received the message, the Double-Daisy-Chain (DDC) cleanup layer provides a reliability mechanism that&rsquo;s used in other gossip algorithms, including epidemic communications. Once the message propagation has reached the next to last layer of the tree, the nodes in the final layer are sent a special &ldquo;I Got You Want?&rdquo; (IGYM) message that expects either a Yes/No answer. If the answer is a Yes, the node is forwarded along the full message and they continue said process. If the answer is No, or there is no answer, that node is skipped and the next node in the chain is selected for the same process.</p>
<p><img src="/images/ddc.png" alt="DDC Cleanup Layer"></p>
<h2 id="gossip-restrictions">Gossip Restrictions</h2>
<h3 id="v0--everyone-communicates-everything">v0 – Everyone Communicates Everything</h3>
<p>In the current system, all nodes communicate any information to all other nodes regardless of whether the information is relevant to that node. This means that Servicers must actively listen and share information about the consensus process, despite the fact that they are not participating. In networks that primarily consist of Validators, this doesn’t cause many issues, but since Pocket Network contains other specialized actors such as Servicers and Fishermen, scaling these actors should not impact the communication of processes irrelevant to their input. If we don’t scale actor communication independently, scaling Servicers and Fishermen will slow down consensus, resulting in longer block times.</p>
<h3 id="v10--restricted-to-relevant-parties">v1.0 – Restricted to Relevant Parties</h3>
<p>The gossip protocol in the Consensus module is a specialized version of RainTree designed for that specific case. As Pocket Network already keeps a list of the current Validators, it’s possible to leverage RainTree for this process. This allows the consensus process to take advantage of the optimizations and redundancy of RainTree. Even more importantly, since the tree will be constructed from only the list of Validators, this means that gossip related to consensus can occur only between those that are involved in the process. This means that the consensus process isn’t held up by trying to communicate with the entire network and that other actors are now unburdened from gossip that isn’t relevant to them.</p>
<h2 id="more-details">More Details</h2>
<p>Read more details about the <a href="https://docs.pokt.network/v1/p2p">v1.0 Peer To Peer module spec</a>.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>🗄 Persistence</h1>

<p>The Persistence module is responsible for ensuring that the data continues to persist over time, across deployments, and throughout software changes. Currently, V0 handles data persistence through Tendermint. Tendermint uses a similar mechanism to most other blockchains, storing the different state data that needs to persist in Merkle trees. The roots of these trees are included in the block, and then for each block, each of the trees is stored as a file.</p>
<p>This design simplifies the computational overhead a new client would need to get up to sync with the current block, however, it does so at the cost of storage. While this decision was made to ensure that the barrier to entry of acting as a validator of a network is low, it fails to consider how critical full nodes, nodes that maintain copies of the data to be accessed and queried by applications, are as infrastructure for production applications.</p>
<p>As the core mission of Pocket Network is to provide access to high quality, decentralized infrastructure, the role of the full node needs to be considered as a priority and not an afterthought. Some of the changes that are being made to the persistence layer in V1 include:</p>
<ul>
<li>Moving from a Key Value Filesystem DB to an SQL based Tamper Proof Hybrid Mutable DB</li>
<li>Decoupling the persistence layer to allow for a Client Server Architecture between pocket-core and persistence.</li>
</ul>
<p>For those interacting with the network, these changes will mean significantly faster access to any state data that would have relied on a query to access.</p>
<p>For those running nodes, these changes will not only make the current experience better, but it will also open the door to more control and options when it comes to deployment configurations. These changes will:</p>
<ul>
<li>Drastically reduce the storage needs (80%) for storing the blockchain data.</li>
<li>Drastically reduce the amount of resources needed to query state data. (10+ seconds -&gt; milliseconds)</li>
<li>Enable better data portability, making it easier to quickly spawn up additional databases as needed</li>
<li>Enable individual scalability, making it easier to kill off and replace a failed process.</li>
<li>Allow for an additional layer of fault tolerance, since the choice for database engine can be replaced.</li>
<li>Enable for multi-process concurrency, making it possible to horizontally scale pocket-core without worrying about the storage cost for doing so.</li>
</ul>
<h2 id="underlying-database">Underlying Database</h2>
<h3 id="v0--key-value-filesystem">V0 – Key Value Filesystem</h3>
<p>Currently, at each block, the data that represents the current state is stored as a tree in a file. While this provides some benefits, such as being able to simply move a directory to move the data, and easily being able to store arbitrary data, these benefits come with significant downsides. For one, regardless if anything has changed in the state between blocks, an entire copy of that tree is written again. There is no process for currently managing data deduplication.</p>
<p>The other issues come from using a filesystem as a production database. Out of the box, Linux cannot handle the amount of simultaneously open files needed to manage a system in this manner, hence needing to make sure the <code>ulimit</code> is properly specified before running a node. Using the filesystem also means that data access is almost entirely reliant on the I/O speeds of the system. When you add in how querying through old state would mean opening multiple files, this means that queries dependent on I/O are the slowest part of the system.</p>
<h3 id="v1--tamper-proof-hybrid-mutable-db">V1 – Tamper Proof Hybrid Mutable DB</h3>
<p>SQL provides a mature, optimized, battle-hardened solution to the data storage problem. One issue with SQL is it requires a well-defined data schema, and so it&rsquo;s well suited for arbitrary data storage. Since Pocket Network does not handle arbitrary computation, and instead serves a defined application specific purpose, SQL provides the opportunity for significant storage and speed optimizations.</p>
<p>A Persistence Client Middleware will communicate between <code>pocket-core</code> and a generic database engine, to define what needs to happen to define, persist, update, and query the datasets it stores. This mechanism will define the following to ensure consistency:</p>
<ol>
<li>Versioning of the state dataset</li>
<li>Byte-perfect consistency of the data encoding</li>
<li>Schema definition mechanism</li>
<li>Deterministic write mechanism</li>
<li>Idempotent Dataset Updates</li>
</ol>
<p>To ensure that the data is tamper proof, the Patricia Merkle Tree can be stored in the state dataset for each block, and can be used to verify the validity of each block. As the operations on the data are ACID and idempotent, any change to the underlying data is detectable.</p>
<h2 id="system-deployment">System Deployment</h2>
<h3 id="v0--data-duplication">V0 – Data Duplication</h3>
<p>The current system requires that each pocket-core process needs access to an independent copy of the data to run. If a node needs to increase resources, whether that be to handle more traffic, or more data access, the only option is to start another process that needs a full copy of the data to run.</p>
<h3 id="v1--client-server-architecture">V1 – Client-Server Architecture</h3>
<p>Breaking the core and persistence layers into a client server architecture gives node runners the ability to scale and manage the respective processes more efficiently. While keeping the persistence layer on the same machine as the <code>pocket-core</code> process would allow for the least latency, it also restricts the node runner from configuring their infrastructure in a way that best serves the needed demand.</p>
<p>Some of the examples that node runners now have access to include:</p>
<ul>
<li>Spawning up multiple <code>pocket-core</code> processes on behalf of the same identity to scale to handle more demand.</li>
<li>Connecting multiple <code>pocket-core</code> processes that represent at least two nodes in close physical proximity to the same database.</li>
<li>Connecting multiple <code>pocket-core</code> process that represent multiple nodes to a database cluster to allow a collection of nodes to efficiently scale-up storage needs</li>
</ul>
<p><img src="/images/PersistenceClientServer.jpg" alt="Some example deployment configurations available when allowing for a Client Server architecture">
Since nodes know the maximum amount of relays that the applications it&rsquo;s serving can request, this gives node runners the ability to save costs by allocating resources only as needed.</p>
<h2 id="more-details">More Details</h2>
<p>Read more details about the <a href="https://docs.pokt.network/v1/persistence">v1.0 Persistence module spec</a>.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
          <article class="default">
<h1>🎚 Protocol Parameters</h1>

<h2 id="off-chain">Off-Chain</h2>
<h3 id="usdrelaytargetrange">USDRelayTargetRange</h3>
<p><strong>Current Value:</strong> $0.00036–0.00059 per relay</p>
<p>The range of USD/relay prices the DAO doesn’t want the real price of a relay to exceed, accounting for the USD price of POKT.</p>
<h3 id="returnoninvestmenttarget">ReturnOnInvestmentTarget</h3>
<p><strong>Current Value:</strong> 10 months</p>
<p>How long the DAO wants it to take for the USD/relay price to be achieved, since the cost basis of a relay decreases over the lifetime of an app stake.</p>
<h2 id="application-module">Application Module</h2>
<h3 id="applicationstakeminimum">ApplicationStakeMinimum</h3>
<p><strong>Current Value:</strong> 1000000</p>
<p>The minimum stake required of an app, denominated in <a href="/learn/protocol-parameters/protocol-parameters.md#stakedenom">StakeDenom</a>. This does not have the same economic security requirements as a node&rsquo;s <a href="/learn/protocol-parameters/protocol-parameters.md#stakeminimum">minimum stake</a> because an app&rsquo;s access to the network (relay throughput) is already proportional to the stake.</p>
<h3 id="appunstakingtime">AppUnstakingTime</h3>
<p><strong>Current Value:</strong> 1814400000000000</p>
<p>The time, in nanoseconds, that an app must wait after initiating an unstake before they can use the POKT for anything else.</p>
<h3 id="baserelaysperpokt">BaseRelaysPerPOKT</h3>
<p><strong>Current Value:</strong> 7014</p>
<p>The number of relays that an app is entitled to for every POKT it stakes, multiplied by 100.</p>
<p>The formula for calculating the <code>MaxRelays</code> an app is entitled to is</p>

<span class="math align-center">$$
MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput)
$$</span><p>Where <code>BaseThroughput</code> is</p>

<span class="math align-center">$$
(BaseRelaysPerPOKT/100) * StakedPOKT
$$</span><p>The <code>/100</code> is included in the formula to enable the DAO to make more granular adjustments, since the protocol is unable to use decimal numbers.</p>
<p>In practice, this means if the <code>BaseRelaysPerPOKT</code> parameter is 100 then the baseline throughput that apps are entitled to is 1 relay per POKT.</p>
<h3 id="maxapplications">MaxApplications</h3>
<p><strong>Current Value:</strong> 2295</p>
<p>The number of staked applications that the protocol allows.</p>
<h3 id="maximumchains">MaximumChains</h3>
<p><strong>Current Value:</strong> 15</p>
<p>An app can only be configured for up to this many chains on one stake.</p>
<h3 id="participationrateon">ParticipationRateOn</h3>
<p><strong>Current Value:</strong> false</p>
<p>The protocol may adjust an application&rsquo;s <code>MaxRelays</code> at the time of staking according to network-wide stake rates, where the ParticipationRate acts as a proxy for utilization of the network on a block by block basis.</p>

<span class="math align-center">$$
MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput)
$$</span><p>This parameter was set to <code>false</code> at genesis and will only be activated if the DAO decides.</p>
<h3 id="stabilityadjustment">StabilityAdjustment</h3>
<p><strong>Current Value:</strong> 0</p>
<p>The DAO may manually adjust an application&rsquo;s <code>MaxRelays</code> at the time of staking to correct for short-term fluctuations in the price of POKT, which may not be reflected in ParticipationRate.</p>

<span class="math align-center">$$
MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput)
$$</span><p>When this parameter is set to <code>0</code>, no adjustment is being made.</p>
<h2 id="pos-node-module">PoS (Node) Module</h2>
<h3 id="blockspersession">BlocksPerSession</h3>
<p><strong>Current Value:</strong> 4</p>
<p>The number of blocks allowed before a Session tumbles.</p>
<h3 id="daoallocation">DAOAllocation</h3>
<p><strong>Current Value:</strong> 10</p>
<p>The DAO treasury earns this proportion of the total POKT block reward. Value is a percentage. See also <a href="/learn/protocol-parameters/protocol-parameters.md#proposerallocation">ProposerAllocation</a> for another beneficiary of the block reward.</p>
<h3 id="daoowner">DAOOwner</h3>
<p><strong>Current Value:</strong> a83172b67b5ffbfcb8acb95acc0fd0466a9d4bc4</p>
<p>The account which has the permission to submit governance transactions on behalf of the DAO.</p>
<h3 id="downtimejailduration">DowntimeJailDuration</h3>
<p><strong>Current Value:</strong> 3600000000000</p>
<p>The amount of time (in nanoseconds) before a node can unjail and resume service.</p>
<h3 id="maxevidenceage">MaxEvidenceAge</h3>
<p><strong>Current Value:</strong> 120000000000</p>
<p>The amount of time (in nanoseconds) a node has to submit their Tendermint evidence in memory before it expires.</p>
<h3 id="maximumchains-1">MaximumChains</h3>
<p><strong>Current Value:</strong> 15</p>
<p>A node can only be configured for up to this many chains on one stake.</p>
<h3 id="maxjailedblocks">MaxJailedBlocks</h3>
<p><strong>Current Value:</strong> 37960</p>
<p>The amount of time (in blocks) a node has to unjail before being force unstaked and slashed.</p>

<div class="box notices cstyle danger">
    <div class="box-label"></div>
    <div class="box-content">
<p>Warning: Reaching MaxJailedBlocks will result in a node&rsquo;s entire stake being slashed.</p>
    </div>
</div>
<h3 id="maxvalidators">MaxValidators</h3>
<p><strong>Current Value:</strong> 1,000</p>
<p>The number of staked nodes that are eligible to be selected for producing blocks. Any staked nodes outside of the top <code>MaxValidators</code> staked validators will still be eligible to service relays.</p>
<h3 id="minsignedperwindow">MinSignedPerWindow</h3>
<p><strong>Current Value:</strong> 0.6</p>
<p>The minimum proportion of the <a href="/learn/protocol-parameters/protocol-parameters.md#signedblockswindow">SignedBlocksWindow</a> that a node must sign to stay out of jail.</p>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>If SignedBlocksWindow is 10 and MinSignedPerWindow is 0.6, this means a node can miss up to 4 blocks out of every 10 blocks before it is jailed.</p>
    </div>
</div>
<h3 id="proposerallocation">ProposerAllocation</h3>
<p><strong>Current Value:</strong> 5</p>
<p>Block proposers earn this proportion of the total POKT block reward. Value is a percentage. See also <a href="/learn/protocol-parameters/protocol-parameters.md#daoallocation">DAOAllocation</a> for another beneficiary of the block reward.</p>
<h3 id="relaystotokensmultiplier">RelaysToTokensMultiplier</h3>
<p><strong>Current Value:</strong> 1768</p>
<p>The amount of POKT, denominated in <a href="/learn/protocol-parameters/protocol-parameters.md#stakedenom">StakeDenom</a>, that is minted as block rewards per relay.</p>
<p>Note that this value will change over time. Please see the section on <a href="/learn/protocol-parameters/economics/monetary-policy.md#poktinflation">POKT inflation</a> for more information.</p>
<h3 id="signedblockswindow">SignedBlocksWindow</h3>
<p><strong>Current Value:</strong> 10</p>
<p>The number of consecutive blocks within which the <a href="/learn/protocol-parameters/protocol-parameters.md#minsignedperwindow">MinSignedPerWindow</a> proportion of blocks must be signed by a node to stay out of jail.</p>

<div class="box notices cstyle info">
    <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
    <div class="box-content">
<p>If SignedBlocksWindow is 10 and MinSignedPerWindow is 0.6, this means a node can miss up to 4 blocks out of every 10 blocks before it is jailed.</p>
    </div>
</div>
<h3 id="slashfractiondoublesign">SlashFractionDoubleSign</h3>
<p><strong>Current Value:</strong> 0.000001</p>
<p>The % of a node&rsquo;s stake that is burned for double signing, where 1 is 100%.</p>
<h3 id="slashfractiondowntime">SlashFractionDowntime</h3>
<p><strong>Current Value:</strong> 0.000001</p>
<p>The % of a node&rsquo;s stake that is burned for downtime, where 1 is 100%.</p>
<h3 id="stakedenom">StakeDenom</h3>
<p><strong>Current Value:</strong> upokt</p>
<p>POKT amounts are defined by the protocol. Read more about <a href="/learn/protocol-parameters/economics/token.md#POKT-denominations">POKT denominations</a>.</p>
<h3 id="stakeminimum">StakeMinimum</h3>
<p><strong>Current Value:</strong> 15000000000</p>
<p>The minimum stake required of a node, denominated in <a href="/learn/protocol-parameters/protocol-parameters.md#stakedenom">StakeDenom</a>, for the economic security of the protocol.</p>
<h3 id="unstakingtime">UnstakingTime</h3>
<p><strong>Current Value:</strong> 1814000000000000</p>
<p>The time, in nanoseconds, that a node must wait after initiating an unstake before they can use the POKT for anything else.</p>
<h2 id="pocket-core-module">Pocket Core Module</h2>
<h3 id="claimexpiration">ClaimExpiration</h3>
<p><strong>Current Value:</strong> 120</p>
<p>The amount of time (in blocks) a node has to submit a proof for an already existing claim.</p>
<h3 id="claimsubmissionwindow">ClaimSubmissionWindow</h3>
<p><strong>Current Value:</strong> 3</p>
<p>The window of time (in Sessions) a node can submit a claimTx for RelayEvidence collected in the most recently ended session, before the claimTx expires. In addition, it is also the minimum amount of time a node must wait to submit a proof for an existing claim.</p>
<h3 id="minimumnumberofproofs">MinimumNumberOfProofs</h3>
<p><strong>Current Value:</strong> 10</p>
<p>The minimum number of relays a node must have for a claim and proof to be payable.</p>
<h3 id="replayattackburnmultiplier">ReplayAttackBurnMultiplier</h3>
<p><strong>Current Value:</strong> 3</p>
<p>The multiplier slash factor for submitting a replay attack. The base slash is directly proportional to the amount of relays claimed.</p>
<h3 id="sessionnodecount">SessionNodeCount</h3>
<p><strong>Current Value:</strong> 24</p>
<p>The number of nodes an app will be matched with in a session.</p>
<h3 id="supportedblockchains">SupportedBlockchains</h3>
<p><a href="/learn/protocol-parameters/../supported-blockchains.md">List of currently supported blockchains</a></p>
<p>Only blockchains with sybil-resistant demand from apps are whitelisted to generate revenue for nodes.</p>
<h2 id="auth-module">Auth Module</h2>
<h3 id="feemultiplier">FeeMultiplier</h3>
<p><strong>Current Value:</strong> 1</p>
<p>The multiplier factor for each transaction type. The base transaction fee is universally set at 10,000 uPOKT.</p>
<h3 id="maxmemocharacters">MaxMemoCharacters</h3>
<p><strong>Current Value:</strong> 75</p>
<p>The character limit of transaction memos.</p>
<h3 id="txsiglimit">TxSigLimit</h3>
<p><strong>Current Value:</strong> 8</p>
<p>The maximum number of signatures that a multi-sig account can have.</p>

            <footer class="footline">
            </footer>
          </article>

    
          <article class="default">
<h1>Glossary</h1>

<h2 id="application">Application</h2>
<p>The base consumer of the decentralized infrastructure of Pocket Network.</p>
<p>Application’s stake POKT into the protocol in order to access the decentralized infrastructure.</p>
<h2 id="application-authentication-token-aat">Application Authentication Token (AAT)</h2>
<p>An Application Authentication Token (AAT) is needed for each client to authorize the use of an allocated “throughput.”</p>
<p>Application Authentication Tokens are similar in function to JSON Web Tokens (JWT) and provide security guarantees for the use of the service.</p>
<p>An AAT is generated after a client acquires &amp; stakes POKT for an application.</p>
<p>There are two design patterns recommended for AAT usage:</p>
<ul>
<li><strong>Optimizing for Safety:</strong> __ A simple backend server that distributes signed AAT’s using the clients Pocket Account. Though this pattern is of higher effort for the Application, it provides the highest security guarantee around their AAT</li>
<li><strong>Optimizing for Performance:</strong> Embed a token production system within the Application code. This guarantees the smoothest UX for the clients and easiest setup for the Application. However, reverse engineering a source code level token generator can be trivial if obfuscation methods are not applied. The upside to this approach is not having the need to have an additional component in the Application that generates the AAT dynamically while keeping the Application private key secure.</li>
</ul>
<h2 id="block-hash">Block Hash</h2>
<p>The SHA3-256 hash of a Block.</p>
<h2 id="jail">Jail</h2>
<p>A Pocket Validator Node can be <code>Jailed</code> for 1 of 2 reasons:</p>
<ol>
<li>Fails to produce <code>min_signed_per_window</code> amount of blocks over a <code>signed_blocks_window</code>. When jailed because of this reason, a Pocket Validator Node is <code>Slashed</code> a <code>slash_fraction_downtime</code>% of their <code>Stake</code>.</li>
<li>For <code>Double Signing</code> a <code>Block</code>. When jailed because of this reason, a Pocket Validator Node is <code>Slashed</code> a <code>slash_fraction_double_sign</code>% of their <code>Stake</code>.</li>
</ol>
<p>When a Pocket Validator Node becomes <code>Jailed</code>, it remains in the <code>Staked</code> list of Pocket Validator Nodes, however it becomes ineligible to be selected for <code>Block Production</code> or participating in <code>Sessions</code>. In order to become <code>Unjailed</code> again, and after waiting <code>downtime_jail_duration</code> nano-seconds, a <code>Node Unjail</code> transaction must be sent to the <code>Pocket Network</code>, and upon approval, the Pocket Validator Node will become <code>Unjailed</code> again.</p>
<p>If a Pocket Validator Node is left jailed for <code>max_jailed_blocks</code> blocks, it will be <code>Force Unstaked</code>.</p>
<h2 id="pokt">POKT</h2>
<p>The native cryptocurrency to Pocket Network.</p>
<h2 id="relay">Relay</h2>
<p>A <strong>Relay</strong> is a blockchain API request and response transmitted through the Pocket Network.</p>
<p>A <strong>Relay Request</strong> is broken down into 3 sections:</p>
<ul>
<li>Request Payload</li>
<li>Metadata</li>
<li>Proof (of Relay)</li>
</ul>
<p>A <strong>Relay Response</strong> is broken down into 2 sections:</p>
<ul>
<li>Response Payload</li>
<li>Servicer Signature</li>
</ul>
<p>Requests are signed by the Client of the Application and responses are signed by the servicing Validator.</p>
<p>This 1 for 1 signature scheme enables the protocol to validate all parties that participate in the <em>servicing</em> cycle.</p>
<h2 id="relay-chain">Relay Chain</h2>
<p>A single database instance, typically a blockchain, provided by a Validator that makes up the Pocket Network decentralized infrastructure.</p>
<h2 id="relay-evidence">Relay Evidence</h2>
<p>Provable evidence of a Relay completed, backed by digital signatures from an Application client.</p>
<h2 id="serviceuri">ServiceURI</h2>
<p>The endpoint where Validators host the Pocket RPC.</p>
<p>A static URI (or IP) that you have assigned to your node, which applications can use to send relays to your node, <strong>NOT</strong> your blockchain node URL.</p>
<h2 id="session">Session</h2>
<p>The relationship between an Application and the Validator(s) that service it at any point in time.</p>
<p>Every Application will only have one single <strong>Session</strong> per Relay Chain it is staked for. Meaning following an Application stake event, there will <em>always</em> be a corresponding <strong>Session</strong> for the Application for each Relay Chain until it unstakes.</p>
<h2 id="session-block">Session Block</h2>
<p>Some number of blocks, marking session beginning/ends.</p>
<h2 id="validator">Validator</h2>
<p><strong>Validators</strong> are responsible for committing new blocks in the blockchain. These <strong>validators</strong> participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each <strong>validator’s</strong> private key.</p>
<p>Validators stake POKT into the protocol to participate in Servicing and Consensus.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
        </div>
      </main>
    </div>
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">
<img alt="POKT Logo" src="/images/logo-white.svg" />

        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="/js/auto-complete.js?1658922679" defer></script>
        <script src="/js/lunr.min.js?1658922679" defer></script>
        <script src="/js/lunr.stemmer.support.min.js?1658922679" defer></script>
        <script src="/js/lunr.multi.min.js?1658922679" defer></script>
        <script src="/js/lunr.en.min.js?1658922679" defer></script>
        <script src="/js/search.js?1658922679" defer></script>
      </div>
      <div id="homelinks" class="default-animation">
        <ul>
          <li>
              <a class="padding" href="/">👋 Welcome</a>
          </li>
        </ul>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/supported-blockchains/" title="✅ Supported Blockchains" class="dd-item"><a href="/supported-blockchains/">Supported Blockchains</a></li>
          <li data-nav-id="/pokt/" title="💰 Get POKT" class="dd-item"><input type="checkbox" id="section-988f0a59c06aa1ec7897abdaf06824dd" class="toggle"/><label for="section-988f0a59c06aa1ec7897abdaf06824dd" ></label><a href="/pokt/">Own POKT</a><ul>
          <li data-nav-id="/pokt/wallets/" title="Manage POKT" class="dd-item"><a href="/pokt/wallets/">Manage POKT</a></li>
          <li data-nav-id="/pokt/buy/" title="Buy POKT" class="dd-item"><a href="/pokt/buy/">Buy POKT</a></li>
          <li data-nav-id="/pokt/stake/" title="Stake POKT" class="dd-item"><a href="/pokt/stake/">Stake POKT</a></li>
          <li data-nav-id="/pokt/wpokt/" title="🎁 Wrapped POKT (wPOKT)" class="dd-item"><a href="/pokt/wpokt/">Wrapped POKT (wPOKT)</a></li></ul></li>
          <li data-nav-id="/learn/" title="Learn Pocket" class="dd-item active parent"><input type="checkbox" id="section-b30da781944ae4db0143d27203425a9c" class="toggle" checked/><label for="section-b30da781944ae4db0143d27203425a9c" ></label><a href="/learn/">Learn Pocket</a><ul>
          <li data-nav-id="/learn/vision/" title="Vision" class="dd-item"><a href="/learn/vision/">Vision</a></li>
          <li data-nav-id="/learn/protocol/" title="⛓ Protocol" class="dd-item"><input type="checkbox" id="section-7b0ba589eab3b7bc81771ad16ca9eaa3" class="toggle"/><label for="section-7b0ba589eab3b7bc81771ad16ca9eaa3" ></label><a href="/learn/protocol/">Protocol</a><ul>
          <li data-nav-id="/learn/protocol/servicing/" title="🤝 Servicing" class="dd-item"><a href="/learn/protocol/servicing/">Servicing</a></li>
          <li data-nav-id="/learn/protocol/security/" title="🛡 Security" class="dd-item"><a href="/learn/protocol/security/">Security</a></li></ul></li>
          <li data-nav-id="/learn/economics/" title="🪙 Economics" class="dd-item"><input type="checkbox" id="section-8041da21916b100a66d56b9fffe9d2a7" class="toggle"/><label for="section-8041da21916b100a66d56b9fffe9d2a7" ></label><a href="/learn/economics/">Economics</a><ul>
          <li data-nav-id="/learn/economics/token/" title="🪙 Token Economics" class="dd-item"><a href="/learn/economics/token/">Token Economics</a></li>
          <li data-nav-id="/learn/economics/apps/" title="💻 App Economics" class="dd-item"><a href="/learn/economics/apps/">App Economics</a></li>
          <li data-nav-id="/learn/economics/nodes/" title="🤖 Node Economics" class="dd-item"><a href="/learn/economics/nodes/">Node Economics</a></li>
          <li data-nav-id="/learn/economics/monetary-policy/" title="🏦 Monetary Policy" class="dd-item"><a href="/learn/economics/monetary-policy/">Monetary Policy</a></li>
          <li data-nav-id="/learn/economics/faq/" title="💰 Pricing &amp; Economics FAQ" class="dd-item"><a href="/learn/economics/faq/">FAQ</a></li></ul></li>
          <li data-nav-id="/learn/future/" title="👀 Future (v1)" class="dd-item"><input type="checkbox" id="section-9461954986787100253a049ef82f97d4" class="toggle"/><label for="section-9461954986787100253a049ef82f97d4" ></label><a href="/learn/future/">Future</a><ul>
          <li data-nav-id="/learn/future/utility/" title="🪙 Utility" class="dd-item"><a href="/learn/future/utility/">Utility</a></li>
          <li data-nav-id="/learn/future/consensus/" title="🤝 Consensus" class="dd-item"><a href="/learn/future/consensus/">Consensus</a></li>
          <li data-nav-id="/learn/future/peer-to-peer/" title="💬 Peer to Peer" class="dd-item"><a href="/learn/future/peer-to-peer/">Peer To Peer</a></li>
          <li data-nav-id="/learn/future/persistence/" title="🗄 Persistence" class="dd-item"><a href="/learn/future/persistence/">Persistence</a></li></ul></li>
          <li data-nav-id="/learn/protocol-parameters/" title="🎚 Protocol Parameters" class="dd-item"><a href="/learn/protocol-parameters/">Parameters</a></li>
          <li data-nav-id="/learn/glossary/" title="Glossary" class="dd-item"><a href="/learn/glossary/">Glossary</a></li></ul></li>
          <li data-nav-id="/use/" title="Use Pocket" class="dd-item"><input type="checkbox" id="section-9c8f252997a5013ebfdc92ac7869fc4d" class="toggle"/><label for="section-9c8f252997a5013ebfdc92ac7869fc4d" ></label><a href="/use/">Use Pocket</a><ul>
          <li data-nav-id="/use/get-endpoint/" title="Get An Endpoint" class="dd-item"><a href="/use/get-endpoint/">Get an Endpoint</a></li>
          <li data-nav-id="/use/public-rpc/" title="Public RPC Endpoints" class="dd-item"><input type="checkbox" id="section-5d1bd50b2ec2e182f37a6e240ac8eab5" class="toggle"/><label for="section-5d1bd50b2ec2e182f37a6e240ac8eab5" ></label><a href="/use/public-rpc/">Public RPC Endpoints</a><ul>
          <li data-nav-id="/use/public-rpc/avax/" title="Avalanche \(AVAX\)" class="dd-item"><a href="/use/public-rpc/avax/">Avalanche</a></li>
          <li data-nav-id="/use/public-rpc/bsc/" title="Binance Smart Chain \(BSC\)" class="dd-item"><a href="/use/public-rpc/bsc/">Binance Smart Chain</a></li>
          <li data-nav-id="/use/public-rpc/dfk-chain/" title="Connecting MetaMask to DFK Chain" class="dd-item"><a href="/use/public-rpc/dfk-chain/">DFK Chain</a></li>
          <li data-nav-id="/use/public-rpc/ethereum/" title="Ethereum \(ETH\)" class="dd-item"><a href="/use/public-rpc/ethereum/">Ethereum</a></li>
          <li data-nav-id="/use/public-rpc/evmos/" title="Evmos" class="dd-item"><a href="/use/public-rpc/evmos/">Evmos</a></li>
          <li data-nav-id="/use/public-rpc/fuse/" title="Fuse" class="dd-item"><a href="/use/public-rpc/fuse/">Fuse</a></li>
          <li data-nav-id="/use/public-rpc/gnosis-chain/" title="Gnosis Chain (xDAI)" class="dd-item"><a href="/use/public-rpc/gnosis-chain/">Gnosis Chain (fka xDAI)</a></li>
          <li data-nav-id="/use/public-rpc/harmony/" title="Harmony" class="dd-item"><a href="/use/public-rpc/harmony/">Harmony</a></li>
          <li data-nav-id="/use/public-rpc/iotex/" title="IoTeX" class="dd-item"><a href="/use/public-rpc/iotex/">IoTeX</a></li>
          <li data-nav-id="/use/public-rpc/polygon/" title="Polygon" class="dd-item"><a href="/use/public-rpc/polygon/">Polygon</a></li></ul></li>
          <li data-nav-id="/use/dapps/" title="Pocket-Powered dApps" class="dd-item"><input type="checkbox" id="section-7c46178e6f5bbc55407fafefbfe1baa3" class="toggle"/><label for="section-7c46178e6f5bbc55407fafefbfe1baa3" ></label><a href="/use/dapps/">Pocket-Powered dApps</a><ul>
          <li data-nav-id="/use/dapps/conquest-eth/" title="Conquest.eth" class="dd-item"><a href="/use/dapps/conquest-eth/">Conquest.eth</a></li>
          <li data-nav-id="/use/dapps/dark-forest/" title="Dark Forest" class="dd-item"><a href="/use/dapps/dark-forest/">Dark Forest</a></li>
          <li data-nav-id="/use/dapps/mycrypto/" title="MyCrypto" class="dd-item"><a href="/use/dapps/mycrypto/">MyCrypto</a></li>
          <li data-nav-id="/use/dapps/rotki/" title="Rotki" class="dd-item"><a href="/use/dapps/rotki/">Rotki</a></li></ul></li></ul></li>
          <li data-nav-id="/node/" title="Run Nodes" class="dd-item"><input type="checkbox" id="section-1cd363a44403268e4bd7ae15574da217" class="toggle"/><label for="section-1cd363a44403268e4bd7ae15574da217" ></label><a href="/node/">Run Nodes</a><ul>
          <li data-nav-id="/node/environment/" title="Environment Setup" class="dd-item"><a href="/node/environment/">Environment Setup</a></li>
          <li data-nav-id="/node/setup/" title="Node Setup" class="dd-item"><a href="/node/setup/">Pocket Node Setup</a></li>
          <li data-nav-id="/node/staking/" title="Custodial and non-custodial staking" class="dd-item"><a href="/node/staking/">Custodial and Non-Custodial Staking</a></li>
          <li data-nav-id="/node/seeds/" title="🌱 Seeds" class="dd-item"><a href="/node/seeds/">Seeds</a></li>
          <li data-nav-id="/node/tutorials/" title="Node Tutorials" class="dd-item"><input type="checkbox" id="section-250316b1db19d7bf2e89212214811654" class="toggle"/><label for="section-250316b1db19d7bf2e89212214811654" ></label><a href="/node/tutorials/">Tutorials</a><ul>
          <li data-nav-id="/node/tutorials/zero-to-node/" title="Introduction" class="dd-item"><input type="checkbox" id="section-6ab9d8d230d608550786165898c7a0ca" class="toggle"/><label for="section-6ab9d8d230d608550786165898c7a0ca" ></label><a href="/node/tutorials/zero-to-node/">Zero To Node</a><ul>
          <li data-nav-id="/node/tutorials/zero-to-node/server-setup/" title="Part 1 –  Server setup" class="dd-item"><a href="/node/tutorials/zero-to-node/server-setup/">Server setup</a></li>
          <li data-nav-id="/node/tutorials/zero-to-node/software-install/" title="Part 2 –  Software installation" class="dd-item"><a href="/node/tutorials/zero-to-node/software-install/">Software installation</a></li>
          <li data-nav-id="/node/tutorials/zero-to-node/pocket-config/" title="Part 3 –  Pocket configuration" class="dd-item"><a href="/node/tutorials/zero-to-node/pocket-config/">Pocket configuration</a></li>
          <li data-nav-id="/node/tutorials/zero-to-node/proxy-config/" title="Part 4 –  Proxy configuration" class="dd-item"><a href="/node/tutorials/zero-to-node/proxy-config/">Proxy configuration</a></li>
          <li data-nav-id="/node/tutorials/zero-to-node/going-live/" title="Part 5 –  Going live" class="dd-item"><a href="/node/tutorials/zero-to-node/going-live/">Going live</a></li></ul></li></ul></li>
          <li data-nav-id="/node/automated-deployments/" title="Automated Deployments" class="dd-item"><a href="/node/automated-deployments/">Automated Deployments</a></li>
          <li data-nav-id="/node/hosting-services/" title="Node-Hosting Services" class="dd-item"><a href="/node/hosting-services/">Node-Hosting Services</a></li>
          <li data-nav-id="/node/faq/" title="Node FAQ" class="dd-item"><a href="/node/faq/">Node FAQ</a></li></ul></li>
          <li data-nav-id="/integrate/" title="Integrate" class="dd-item"><input type="checkbox" id="section-d4bb38a7d13f002c4014ff23289c50e8" class="toggle"/><label for="section-d4bb38a7d13f002c4014ff23289c50e8" ></label><a href="/integrate/">Integrate</a><ul>
          <li data-nav-id="/integrate/sdk/" title="SDKs" class="dd-item"><a href="/integrate/sdk/">SDKs</a></li>
          <li data-nav-id="/integrate/accounts-transactions/" title="Accounts and Transactions" class="dd-item"><input type="checkbox" id="section-1f772117c78cb1420090c8202df835ca" class="toggle"/><label for="section-1f772117c78cb1420090c8202df835ca" ></label><a href="/integrate/accounts-transactions/">Accounts and Transactions</a><ul>
          <li data-nav-id="/integrate/accounts-transactions/account-generation-validation/" title="Account Generation and Validation" class="dd-item"><a href="/integrate/accounts-transactions/account-generation-validation/">Account Generation and Validation</a></li>
          <li data-nav-id="/integrate/accounts-transactions/transaction-construction/" title="Transaction Construction" class="dd-item"><a href="/integrate/accounts-transactions/transaction-construction/">Transaction Construction</a></li>
          <li data-nav-id="/integrate/accounts-transactions/transaction-verification/" title="Transaction Verification" class="dd-item"><a href="/integrate/accounts-transactions/transaction-verification/">Transaction Verification</a></li></ul></li></ul></li>
          <li data-nav-id="/community/" title="Community" class="dd-item"><input type="checkbox" id="section-5222f03197abba24f0c665fe1d22532c" class="toggle"/><label for="section-5222f03197abba24f0c665fe1d22532c" ></label><a href="/community/">Join Us</a><ul>
          <li data-nav-id="/community/governance/" title="👑 Governance" class="dd-item"><input type="checkbox" id="section-58d7c2e4187c5d62f879f3f81802f3c9" class="toggle"/><label for="section-58d7c2e4187c5d62f879f3f81802f3c9" ></label><a href="/community/governance/">Governance</a><ul>
          <li data-nav-id="/community/governance/proposals/" title="Proposals" class="dd-item"><a href="/community/governance/proposals/">Proposals</a></li></ul></li>
          <li data-nav-id="/community/contribute/" title="🦸 Contribute" class="dd-item"><input type="checkbox" id="section-1455a3dbf4677a4000103a13e3e0af39" class="toggle"/><label for="section-1455a3dbf4677a4000103a13e3e0af39" ></label><a href="/community/contribute/">Contribute</a><ul>
          <li data-nav-id="/community/contribute/scholarships/" title="Scholarships" class="dd-item"><a href="/community/contribute/scholarships/">Scholarships</a></li></ul></li>
          <li data-nav-id="/community/trophies/" title="🗳 Trophies" class="dd-item"><input type="checkbox" id="section-203bb11e8b6be933d85a663ca65b1a91" class="toggle"/><label for="section-203bb11e8b6be933d85a663ca65b1a91" ></label><a href="/community/trophies/">Trophies</a><ul>
          <li data-nav-id="/community/trophies/app-developers/" title="🏆 App Developers" class="dd-item"><a href="/community/trophies/app-developers/">App Developers</a></li>
          <li data-nav-id="/community/trophies/node-runners/" title="🏆 Node Runners" class="dd-item"><a href="/community/trophies/node-runners/">Node Runners</a></li>
          <li data-nav-id="/community/trophies/community-shepherds/" title="🏆 Community Shepherds" class="dd-item"><a href="/community/trophies/community-shepherds/">Community Shepherds</a></li>
          <li data-nav-id="/community/trophies/contributors/" title="🏆 Governor/Contributors" class="dd-item"><a href="/community/trophies/contributors/">Contributors</a></li></ul></li></ul></li>
          <li data-nav-id="/more-info/" title="💬 More Information" class="dd-item"><a href="/more-info/">More Info</a></li>
        </ul>
        <div id="shortcuts">
          <div class="nav-title">More</div>
          <ul>
            <li><a class="padding" href="https://forum.pokt.network">Forum</a></li>
            <li><a class="padding" href="https://github.com/pokt-foundation/pocket-js">PocketJS</a></li>
            <li><a class="padding" href="https://discord.gg/pokt">Discord</a></li>
            <li><a class="padding" href="https://github.com/pokt-foundation/pypocket">pypocket</a></li>
            <li><a class="padding" href="https://github.com/pokt-foundation/pocket-go">pocket-go</a></li>
            <li><a class="padding" href="https://angel.co/company/pocket-network">Jobs</a></li>
          </ul>
        </div>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="variants.changeVariant( this.value );">
                    <option id="blue" value="blue" selected>Blue</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter">
        </div>
      </div>
    </aside>
    <script src="/js/clipboard.min.js?1658922679" defer></script>
    <script src="/js/perfect-scrollbar.min.js?1658922679" defer></script>
    <script src="/js/featherlight.min.js?1658922679" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign({
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{ \"chtml\": { \"displayAlign\": \"left\" } }") );
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/js/jquery.svg.pan.zoom.js?1658922679" defer></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js" defer></script>
    <script>
      function useMermaid( config ){
        if (typeof mermaid != 'undefined' && typeof mermaid.mermaidAPI != 'undefined') {
          mermaid.initialize( Object.assign( { "securityLevel": "antiscript", "startOnLoad": false  }, config ) );
          if( config.theme ){
            var write_style = variants.findLoadedStylesheet( 'variant-style' );
            write_style.setProperty( '--CONFIG-MERMAID-theme', config.theme );
          }
        }
      }
      useMermaid( JSON.parse("{ \"theme\": \"default\" }") );
    </script>
    <script src="/js/theme.js?1658922679" defer></script>
  </body>
</html>
