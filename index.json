[{"content":"Before buying any POKT, you should first ensure that you know how to store it safely.\nCreate Wallet You can use the official wallet web app to create your wallet. Note: desktop and Ledger apps are in development. This documentation will be updated when they are available to use.\nClick ‚ÄòCreate‚Äô. 2. Enter a unique passphrase.\nWarning The passphrase unlocks/decrypts an encrypted version of the private key that is stored in a Key File. Make sure to store your passphrase safely, if you lose it you will not be able to unlock your Key File.\n2. Download the Key File by clicking the blue download icon and click Continue to open your account.\nIf you accidentally click Back, as long as you downloaded your Key File and saved your passphrase, you will now be able to import your new wallet.\nWarning Make sure to store your Key File safely, if you lose it you will only be able to use the Private Key method to import your wallet anywhere. The Key File is the more secure method of importing your wallet since it is encrypted by your passphrase.\n3. Click ‚ÄúReveal Private Key‚Äù then enter your passphrase again to reveal the Private Key for your wallet.\nWarning Store your Private Key safely. This will be a second method for you to import your wallet in the event that you lose your Key File or passphrase. However, this is also less secure than the Key File since the Key File is encrypted by your passphrase.\nNever reveal your Private Key to anyone. If someone has access to your Private Key, they have full access to all the funds. The only application that should ever need access to your Private Key is a wallet.\nBackup Wallet It is important that you back up your Key File, passphrase, and private key securely. There are two considerations when choosing a backup method:\nTheft Prevention: make sure no-one else can access your Key File, passphrase, or private key Loss Prevention: make sure you don‚Äôt lose access to your Key File, passphrase, or private key The most secure way to prevent theft is to store your Key File, passphrase, and private key on a USB drive (or other secure external drive), disconnected from any online ‚Äúcloud‚Äù service or internet-connected computer that can be hacked.\nInfo POKT will soon have Ledger support, which provides a little more advanced functionality than a USB drive, but there is no ETA on this.\nFor extra-secure theft prevention, you should split the Key File, passphrase and private key across separate drives and password-protect these drives so that anyone who gets their hands on a drive can‚Äôt access the contents. For extra loss prevention, you should make multiple copies of these drives and store them in different locations, such as a personal safe, the safe of a trusted family member, and a bank safety deposit box.\nOnce you have created your backups, delete all traces of the Key File, passphrase and private key from the hard drive of the computer you used for account setup. To ensure deletion, consider using software such as sDelete (Windows) or shred followed by rm (Linux).\nInfo For more convenience, you may consider using a password manager that can store encrypted files. Just be mindful that you risk theft if your master password is compromised and you risk loss if you forget your master password.\nImport Wallet The official wallet web app has two methods of importing your wallet. The Key File is the more secure method of importing your wallet since it is encrypted by your passphrase.\nKey File Import Click Select File then choose your keyfile.json from your local file explorer.\nEnter your Key File passphrase, which you specified when creating the wallet.\nClick Import.\nPrivate Key Import Enter your Private Key.\nCreate a temporary passphrase that will secure your session until you log out of the wallet. This is a measure to prevent anyone with access to your computer from stealing your funds.\n","description":"","tags":null,"title":"Manage POKT","uri":"/docs-hugo/pokt/wallets/"},{"content":"This section will help you set up and configure a server to prepare it for being a Pocket node.\nSetup a server The first thing you‚Äôll need to run a Pocket node is a server. For this guide, we‚Äôll be using a virtual machine on the Linode cloud service. But, you could use any cloud service you like.\nInfo Pocket has no affiliation with Linode and does not recommend any one provider over another. The general steps outlined here should work for most cloud providers.\nLet‚Äôs start by creating a Linode instance (a virtual machine).\nCreating a Linode instance To create a Linode instance, do the following:\nGet a Linode account and login. Create a new Linode with the following specifications: Image / Distribution: Ubuntu 20.04 LTS Region: Atlanta, GA Linode Plan: Dedicated 16 GB - 8 CPU, 320 GB Storage, 16 GB RAM Linode Label: pokt001 Wait for the Linode to be created and show up as running in the web interface. Info For a more detailed guide on setting up a Linode instance, see the Linode docs. Also, note that the Atlanta, GA region was selected for this guide because it supports NVMe storage which is preferable for running nodes. Check to see which other regions support NVMe storage.\nConfigure DNS Now that the Linode instance is created and running, you‚Äôll need to set up a DNS record that points to the IP address of the Linode instance.\nPocket nodes require a DNS name. DNS (Domain Name Service) names are used to map an IP address to more human-friendly names. So rather than referencing a server with an address like 134.23.153.21 we can use a name like pokt001.pokt.run.\nInfo Most domain registrars allow you to add DNS records. Please refer to the DNS setup documentation for your provider.\nSpecifically, you‚Äôll need to add an A record for the domain name. For the exact steps, consult the DNS documentation for your provider. Then create a record with the following information:\nName: pokt001 Type: A Value: {Linode_IP_Address} TTL: 300 After setting up your DNS record, wait a few minutes for the DNS to propagate. Then use the following command to check that the DNS record is working:\nInfo The examples in this tutorial will use pokt001 as the server on the pokt.run domain, so pokt001.pokt.run will be used as the DNS name. Please replace this throughout with your own server and domain name.\nping -c 3 pokt001.pokt.run You should see a response that looks something like this:\n64 bytes from 134.23.153.21: icmp_seq=0 ttl=47 time=92.403 ms 64 bytes from 134.23.153.21: icmp_seq=1 ttl=47 time=142.828 ms 64 bytes from 134.23.153.21: icmp_seq=2 ttl=47 time=182.456 ms If the IP address matches the IP address of your Linode instance, you‚Äôre all set!\nInfo It can sometimes take longer than a minute for the DNS to propagate. So, be patient if things don‚Äôt seem to work right away.\nLogin with SSH Now that we have a DNS record setup, we will look at using SSH to log in and continue the setup process.\nThe Secure Shell Protocol (SSH) is a secure way to connect to your Linode instance from a remote machine, like your local computer. We‚Äôll be using SSH to complete the remainder of the setup process.\nSSH from Mac or Linux If you‚Äôre using a Mac, or Linux, on your local computer, you can SSH into your node by doing the following:\nOpen a terminal\nSSH into your node using the following command:\nssh root@pokt001.pokt.run Info Don‚Äôt forget to replace pokt001.pokt.run with your DNS name.\nYou‚Äôll be prompted for your password. This is the root password that you set when you created your Linode.\nSSH from Windows Windows 10 and later have a built-in SSH client. You can use SSH on Windows by doing the following:\nOpen the Windows terminal\nSSH into your node using the following command:\nssh root@pokt001.pokt.run Info Don‚Äôt forget to replace pokt001.pokt.run with your DNS name.\nIf you‚Äôre using an older version of Windows, you might need to install PuTTY or some other SSH client.\nSet the hostname At this point you should be logged into your node as the root user.\nIn a previous step, we set the DNS name for the node. Now we‚Äôll use the same name for the hostname on the server.\nTo set the server hostname use the following steps:\nOpen the /etc/hostname file with the following command:\nnano /etc/hostname Change the localhost value to the fully qualified hostname of your node (for example, pokt001.pokt.run).\nSave the file with Ctrl+O and then Enter.\nExit nano with Ctrl+X.\nReboot the server with the following command:\nreboot Wait for the server to reboot then ssh back in as the root user before continuing on.\nCreate a user For security reasons it‚Äôs best not to use the root user. Instead, it‚Äôs better to create a new user and add the user to the sudo group.\nAlso, by default, the Pocket CLI will place the data directory for the node in the user‚Äôs home directory. So, when you create a new user, you‚Äôll want to make sure the home directory is on a volume that has plenty of room for the data directory.\nWarning At the time of writing, Pocket requires ~200GB for its blockchain data. The following user setup steps assumes that the location of your user‚Äôs home directory is on a volume with enough room for the pocket data.\nCreating a new user To create a new user and home directory, enter the following commands:\nCreate a new user named pocket, add it to the sudo group, and set the default shell to bash. If you want to specify the location of the home directory, you can use the -d option followed by the path to the home directory:\nuseradd -m -g sudo -s /bin/bash pocket \u0026\u0026 passwd pocket For the rest of this guide, we‚Äôll be using the pocket user. So now that the pocket user is created, you can switch from using root to the pocket user with the following command:\nsu - pocket Configure SSH Key Login (Optional): While not required, using an SSH key provides a more secure means of accessing your server.\nUsing an SSH key removes the ability for credentials to be sniffed in the login process, and removes the pitfalls that can often come with user generated passwords since the key will truly be random.\nOne important thing to understand, is that without access to the ssh key, you won‚Äôt be able to log into your node. If you intend on accessing your node from multiple computers, it‚Äôs recommended that you repeat the Generate Key and Upload Key steps from each computer that you intend to access your node from before moving on to the Disable Root Login and Password Authentication step.\nLog Out\nAt the terminal you‚Äôll need to enter the logout command twice. The first logout logs you out of the pocket user, back to the root user, and the second logout logs you out of the server and back to your terminal.\nGenerate Key\nNext, we‚Äôll generate an ssh key. To do that you‚Äôll run the ssh-keygen command. You‚Äôll be prompted to specify the file you want to save the key to, and for a password. Specifying a password means that if someone has access to your key, they‚Äôd still need to know the password to be able to use it to login. To create the key, do the following:\nRun the ssh-keygen command\nssh-keygen -t rsa -b 4096 Enter file in which to save the key (~/.ssh/id_rsa)\nEnter a passphrase (empty for no passphrase)\nEnter same passphrase again\nThe results should looking something like the following:\nThe key fingerprint is: SHA256:jr2MLXIha188wYsp/bNflN9BuqQ3LWCAXJNTtHO7sWk The key's randomart image is: +---[RSA 4096]----+ | o+o | | . oo. . | | o ..o . . | | . . o.+ | | S oo= . | | ...B o..+.B..| | .o=.B ..E...| | +.o*.o .o o | | . +o.*+. | +----[SHA256]-----+ Upload Key\nNow we‚Äôre going to upload the key so that we can use it to log into the pocket user. If you choose a different path for the ssh key, it‚Äôs important to replace the ~/.ssh/id_rsa with the key you used.\nssh-copy-id -i ~/.ssh/id_rsa pocket@pokt001.pokt.run Disable Root Login and Password Authentication\nNow we‚Äôre now going to configure ssh to no longer allow root logins, and to not allow any password based login attempts. Meaning without access to the ssh key for the pocket user, no one will be able to log into the server.\nFirst we‚Äôll need to log back into the server:\nssh pocket@pokt001.pokt.run From there, we‚Äôll want to open the /etc/ssh/sshd_config file to make some changes to the default configuration:\nsudo nano /etc/ssh/sshd_config Once there, we‚Äôll need to find and change the following lines:\n#PermitRootLogin prohibit-password -\u003e PermitRootLogin no #PubkeyAuthentication yes -\u003e PubkeyAuthentication yes #PasswordAuthentication yes -\u003e PasswordAuthentication no Once changed, Ctrl-O followed by Enter will save the changes, and Ctrl-X will exit nano back to the terminal.\nThen we‚Äôll need to restart the ssh server for these changes to take effect:\nsudo systemctl restart sshd.service Verify Everything Works\nThe last step is to log out of the server, and try logging back in. If you‚Äôre no longer prompted for a password, then everything is working as expected.\nThat‚Äôs it for the server setup! Continue on to install the necessary software.\n","description":"Set up a server to prepare it for being a Pocket node. Part 1 of 5 in the Zero to Node tutorial.","tags":null,"title":"Part 1 ‚Äì  Server setup","uri":"/docs-hugo/node/tutorials/zero-to-node/server-setup/"},{"content":"Test another line.\nPocket Network is the TCP/IP of Web3 node infrastructure ‚Äì a multi-chain relay protocol that incentivizes RPC nodes to provide DApps and their users with unstoppable Web3 access.\nPocket supports dozens of blockchains, with more being added all the time.\nView the list of supported blockchains\nGet Started Use Pocket Network‚Äôs RPC Using Pocket Network is as easy as any other RPC. If you‚Äôre already using a centralized RPC provider, the Pocket Portal was built to allow a seamless transition with URLs you can claim below. Alternatively, you can integrate directly with PocketJS.\nGet a public RPC URL for your wallet Create a private RPC URL for your DApp Run a POKT Node Learn the basics of managing POKT Learn how to run your own node Shape Pocket Network‚Äôs Future Learn how to contribute to the Pocket Network ecosystem Learn how to become a member of the DAO ","description":"","tags":null,"title":"Welcome","uri":"/docs-hugo/"},{"content":"Overview The Pocket Network‚Äôs Servicing layer is comprised of 2 main actors: Applications and Servicers. An Application submits a Relay Request, or an API requests to be routed to any Relay Chain. A Servicer ‚Äòservices‚Äô the Application, by routing the Relay Request to the Relay Chain and forwarding the response to the Application. This interaction between an Application and a Servicer is the fundamental utility of Pocket Network.\nBasic Lifecycle To register for decentralized infrastructure, an Application must stake the native cryptocurrency POKT in the network. The amount of the sanctioned throughput (per request) is determined by the amount the Application stakes in the network. To register to provide decentralized infrastructure, a Servicer must stake the native cryptocurrency POKT in the network. After the subsequent staking, an Application is paired with Servicer(s), during which time the servicing interaction takes place. For providing the decentralized infrastructure, Servicer receives an amount of the native cryptocurrency POKT proportional to the amount of throughput (in requests) served. Once an Application or Servicer unstakes, they are unregistered from Pocket Network and the stake is returned to their account. Sessions Distribution The Servicer(s) that are paired to service an Application in a Session are equally distributed among all of the Servicers in the network.\nMeaning that every Servicer theoretically serves the same amount as their peers and every Application theoretically will be evenly serviced by each Servicer over time.\nGeneration The generation of a Session is key to the equal distribution property.\nEqually distributed sessions are generated with pseudorandom seed data:\nBlockHash: Hash of the last Session Block AppPubKey: The Application‚Äôs public key RelayChain: The identifier of the Relay Chain The result of using this seed data is unique sessions for every Relay Chain of Application at any given Session period.\nThe Servicers over time that will serve each Application at any given time are extrapolated using this data, meaning any actor with the following blockchain data is able to generate the proper serving Servicers.\nA single Dispatch API call to any full node on Pocket Network will provide an Application client with the ServiceURI of their Session period Servicers.\nTumbling Tumbling is the act of regenerating a Session with new seed data.\nSessions are tumbled periodically every predetermined (by governance) quantity of blocks.\nThe tumbling mechanism allows for much greater Application security, as the same Validator(s) will only service the Application for a certain amount of time.\nThroughput The max Application throughput (in number of requests) is proportional to the amount staked.\nThe maximum a Servicer in a Session can service for a certain Application is determined using the following formula:\nmax_app_relays = base_throughput / (# of Servicers in Session * # of relay_chains staked for)\nRelays Payload The request payload is the body of the RPC request\nData: The actual request body to be forwarded to the Relay Chain e.g. {\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":67} Method: The HTTP CRUD method e.g. POST Path: Path variable for REST support e.g: \"/v1/query/block\" Headers: HTTP Headers e.g. Content-Type: application/json Metadata The Relay Metadata is Protocol level descriptive information that is needed for servicing.\nBlockHeight: The Pocket Network block height when the request was made The metadata mechanism allows for a configurable client syncronization module, enabling the Servicer to reject out of sync clients.\nSince the Metadata is grouped into the request hash, this mechanism is a protection against Client level synchronization attacks where the Client is able to challenge single Servicers by requesting chain data at a different time than the majority.\nProof of Relay (Evidence) A Proof of Relay is the portion of a Relay Request that is used for verification of the atomic work completed.\nFor each Application of each Session, a Servicer collects Relay Evidence in the form of a Proof of Relay. The amount of Relay Evidence is completely proportional to the amount of Relays serviced, meaning for each Relay successfully completed, the Servicer stores one piece of Relay Evidence.\nStructure of the Proof of Relay RequestHash: The SHA3-256 hash of the request payload Connects the specific payload with the proof Needed for the Application Challenge Mechanism Entropy: A unique nonce (random number) that ensures uniqueness Unique Relays are a requirement of Pocket Network for Claim/Proof Submission Collisions are rejected by the Servicers SessionBlockHeight: The block height of the session when the Relay was serviced Needed to verify the participants of Session ServicerPubKey: The ED25519 Public Key of the servicer Needed to identify the servicer RelayChain: The identifier of the ‚Äòrelayed to‚Äô blockchain Ex: 0021 (Eth mainnet) AAT: The Application Authentication Token for the client serviced Includes both App Public Key and Client Public Key Needed for protocol level verification (app node pairings, client permissions, etc.) ClientSignature: The Elliptic Curve Digital Signature of the client Preserves the integrity of the Relay data Needed at Proof/Claim verification level Response Response Payload The response payload is the body of the RPC response:\nResponse: String representation of the HTTP response Servicer Signature The servicer signature completes the signature exchange needed to verify all parties in the servicing protocol.\nSignature: preserves the integrity by signing the hash of the Proof of Relay and the response payload. Claim/Proof Lifecycle In order to participate in the network economic incentive mechanism, the Servicer must first Claim and then Prove the completed work. For each Application of each Session, after servicing is complete and Relay Evidence is collected, the Servicer must send two subsequent transactions:\nClaim Transaction Merkle Root of Relay Evidence Number of Relays serviced Evidence Type (Relay or Challenge) Proof Transaction Selected Relay Corresponding Merkle Proof for selected Relay Evidence Type (Relay or Challenge) Upon successful completion of BOTH transactions, the Servicer is minted reward directly to their address.\nMerkle Tree Pocket Network requires a specific Merkle tree implementation that ensures no two leafs of the Merkle tree are identical (for Relay replay protection). Plasma-Core‚Äôs Merkle sum tree satisfies this property.\nBy using the hash of the Relay data (integrity is validated by verifying the Application Client Signature) in conjunction with the replay protection from the Plasma tree, Pocket Network can probabilistically guarantee work completed without the Servicer actually transmitting the entirety of its Relay Evidence to the rest of the network.\nA fancier name for this is a Zero Knowledge Range Proof.\nZero Knowledge Range Proof In order to complete a successful ZKRP in Pocket Network, the following steps must be executed by each Servicer for each Session:\nGenerate the Merkle Tree using the SHA3-256 hash of the Relay Evidence as the leafs Submit a Claim Transaction to preserve the integrity of the local Merkle tree and corresponding Relay Evidence, as well as inform the protocol of the range or number of leafs possible to select from After a protocol wide waiting period (determined by governance), the Servicer generates the selected leaf (using the latest block hash as pseudorandom entropy to prevent knowledge of the selection during claim generation) and subsequently creates a Merkle Proof (branch) for the pseudorandomly selected leaf. The Servicer submits a Proof Transaction containing the selected leaf (Relay Evidence) and the corresponding Merkle Proof (branch) The protocol verifies the Merkle proof against the previously submitted Merkle root (in the Claim Transaction), verifies the session (proper app/node pair, not overserviced etc.), and then verifies the client signature against the Proof of Relay (integrity check) All of the Validators confirm the validity of the Proof Transaction, completing the Zero Knowledge Range Proof Tokens are minted to the address of the Servicer proportional to the amount of Relays served. ","description":"","tags":null,"title":"ü§ù Servicing","uri":"/docs-hugo/learn/protocol/servicing/"},{"content":"Pocket works out-of-the-box with any network/blockchain (RelayChain) that uses the RPC standard.\nCurrent RelayChains The following table shows the full list of supported, revenue-generating RelayChains. This list should be identical to the SupportedBlockchains parameter.\nName Portal API Prefix RelayChainID Algorand algo-mainnet 0029 Avalanche avax-mainnet 0003 Binance Smart Chain bsc-mainnet 0004 Binance Smart Chain Archival bsc-archival 0010 Boba boba-mainnet 0048 DFKchain Subnet dfk-mainnet 03DF Evmos evmos-mainnet 0046 Ethereum eth-mainnet 0021 Ethereum Archival eth-archival 0022 Ethereum Archival Trace eth-archival-trace 0028 Ethereum Goerli eth-goerli 0026 Ethereum Kovan poa-kovan 0024 Ethereum Rinkeby eth-rinkeby 0025 Ethereum Ropsten eth-ropsten 0023 Fantom fantom-mainnet 0049 FUSE fuse-mainnet 0005 FUSE Archival fuse-archival 000A Gnosis Chain gnosischain-mainnet 0027 Gnosis Chain Archival gnosischain-archival 000C Harmony Shard 0 harmony-0 0040 IoTeX iotex-mainnet 0044 Moonbeam moonbeam-mainnet 0050 Moonriver moonriver-mainnet 0051 NEAR near-mainnet 0052 OKExChain oec-mainnet 0047 Optimism optimism-mainnet 0053 Pocket Network mainnet 0001 Polygon poly-mainnet 0009 Polygon Archival poly-archival 000B Solana sol-mainnet 0006 Swimmer Network Mainnet avax-cra 03CB Pocket Testnet RelayChains The following table shows the full list of currently-supported blockchains on the Pocket Testnet.\nName RelayChainID Ethereum Goerli 0020 Ethereum Rinkeby 0022 Ethereum Ropsten 0023 Pocket Network Testnet 0002 Claimed RelayChains The following table shows the full list of RelayChains that are known to have been claimed.\nDue to Pocket Network‚Äôs permissionless nature, any RelayChainID can be claimed by adding it to this list. Apps and nodes staking on the RelayChain will be matched together in sessions, but nodes will not earn POKT.\nThese blockchains are not supported or revenue-generating, and presence on this table does not imply that they will be supported or revenue-generating in the future.\nName Portal API Prefix RelayChainID Algorand Archival algorand-archival 000D Algorand Testnet algorand-testnet 0045 Algorand Testnet Archival algorand-testnet-archival 0A45 Arweave arweave-mainnet 0030 Avalanche Archival avax-archival 00A3 Avalanche Fuji avax-fuji 000E Binance Smart Chain Testnet bsc-testnet 0011 Binance Smart Chain Testnet Archival bsc-testnet-archival 0012 Harmony Shard 0 Archival harmony-0-archival 0A40 Harmony Shard 1 harmony-1 0041 Harmony Shard 1 Archival harmony-1-archival 0A41 Harmony Shard 2 harmony-2 0042 Harmony Shard 2 Archival harmony-2-archival 0A42 Harmony Shard 3 harmony-3 0043 Harmony Shard 3 Archival harmony-3-archival 0A43 Polygon Mumbai poly-mumbai 000F Polygon Mumbai Archival poly-mumbai-archival 00AF Solana Testnet sol-testnet 0031 Integrating New RelayChains In order to integrate a RelayChain with Pocket, the node running community needs to support the chain. So a chain that is easier to deploy, sync, and maintain, has helpful documentation, and provides stable nodes, will all tend to increase the likelihood of the community supporting the chain.\nThe Pocket Network Foundation determines which RelayChains are supported (revenue-generating) on behalf of the DAO. Before making this determination, the Foundation aims to give the community of node runners enough notice to deploy their nodes to ensure a level playing field.\nOnce the determination has been made to support a new RelayChain at scale, the RelayChainID will be added to the SupportedBlockchains parameter, meaning that nodes will earn POKT for every request that they relay for the RelayChain based on the RelaysToTokensMultiplier parameter.\nFor more information, please see PIP-6.2: Settlers of New Chains.\n","description":"","tags":null,"title":"‚úÖ Supported Blockchains","uri":"/docs-hugo/supported-blockchains/"},{"content":"Exchanges POKT is available to purchase on multiple global exchanges. Follow this DAO proposal for updates on official listings.\nNote that you can‚Äôt stake POKT from exchanges. To stake your POKT you would need to withdraw to your wallet (see below).\nOver-the-Counter (OTC) Over-the-Counter (OTC) trading desks are white-label markets operated by trusted intermediaries who match buyers and sellers. They are typically used for large volume trades.\nThe POKT community has a number of OTC desks which can be found here.\nTransfer POKT to Your Wallet To receive POKT, you must use your Address, not your Public Key. The Public Key is used for API transactions, not basic wallet actions.\n","description":"","tags":null,"title":"Buy POKT","uri":"/docs-hugo/pokt/buy/"},{"content":"This section will help you install all the necessary software for your node.\nInstall dependencies Now let‚Äôs move on to the Pocket CLI installation.\nAt this point you should be logged in via SSH as the pocket user that we set up in a previous step. Before we install the Pocket software, we need to update the existing system packages and add a few dependencies.\nUpdating system packages Update the repository index with the following command: sudo apt update Update the distribution with the following command: sudo apt dist-upgrade -y After the update completes, we‚Äôre ready to install the dependencies.\nInstalling dependencies There are a handful of dependencies but installing them won‚Äôt take long. Also, some might already be installed. So if one of the dependencies exists, you can just move on to the next one.\ngit sudo apt-get install git -y build tools sudo apt-get install build-essential -y curl sudo apt-get install curl -y file sudo apt-get install file -y nginx sudo apt install nginx -y certbot sudo apt install certbot -y python3-certbot-nginx sudo apt-get install python3-certbot-nginx -y jq sudo apt install jq -y Install Go After installing the dependencies, there is one more dependency we‚Äôll need to add, and that‚Äôs Go. Go (sometimes known as ‚ÄúGolang‚Äù) is the programming language that the Pocket software was written in.\nWe could install Go using apt, but we want to get the latest stable version which probably isn‚Äôt available by default in the apt repository. So, we‚Äôll use the steps below to install Go.\nMake sure you‚Äôre in the pocket home directory. cd ~ Find the latest version of Go from https://golang.org/dl/ then download it with the following command. (Make sure to change the link below to point to the correct version of Go.) wget https://dl.google.com/go/go1.17.7.linux-amd64.tar.gz Extract the archive: sudo tar -xvf go1.17.7.linux-amd64.tar.gz Set permissions on the extracted files: sudo chown -R pocket ./go Add Go to the PATH: echo 'export PATH=$PATH:$HOME/go/bin' \u003e\u003e ~/.profile Set the GOPATH and GOBIN environment variables: echo 'export GOPATH=$HOME/go' \u003e\u003e ~/.profile echo 'export GOBIN=$HOME/go/bin' \u003e\u003e ~/.profile Reload your .profile: source ~/.profile Verify the installation: go version You should see something like this: go version go1.17.7 linux/amd64 Make sure the version number matches the version you downloaded. If the go version command doesn‚Äôt work, try logging out and logging back in. Verify the GOPATH and GOBIN variables are set correctly: go env You should see the GOPATH and GOBIN variables set correctly. Install Pocket After you can verify that you have the latest stable version of Go, we‚Äôre ready to install the Pocket software.\nWe‚Äôll be downloading Pocket Core from GitHub and then compiling it with Go to get it fully installed.\nTo download and install Pocket Core, do the following:\nCreate a project directory: sudo mkdir -p $GOPATH/src/github.com/pokt-network Change to the project directory: cd $GOPATH/src/github.com/pokt-network Clone the Pocket Core repository: sudo git clone https://github.com/pokt-network/pocket-core.git Change to the code directory: cd pocket-core Checkout the latest version. You can find the latest tag by going to https://github.com/pokt-network/pocket-core/tags. sudo git checkout tags/RC-0.8.2 Build project code: go build -o $GOPATH/bin/pocket $GOPATH/src/github.com/pokt-network/pocket-core/app/cmd/pocket_core/main.go Test that the build succeeded: pocket version That‚Äôs it for the software installation. Now let‚Äôs move on to the Pocket core configuration.\n","description":"Install all the necessary software for your node. Part 2 of 5 in the Zero to Node tutorial.","tags":null,"title":"Part 2 ‚Äì  Software installation","uri":"/docs-hugo/node/tutorials/zero-to-node/software-install/"},{"content":"By enforcing POKT to be staked from both the Applications and the Validators, the protocol is able to economically penalize either actor participating in servicing\nSession Security The probability due to randomized selection without replacement is:\n$$ P (A‚à©B) = P (A) P (B|A) $$Thus the probability of selecting any combination of Validators at any given Session in Pocket Network is:\n$$ 1 / (allvals (allvals-1) (allvals - 2) ... * (allvals - valspersession)) $$Meaning, the more Validators in the network, the higher level of randomization and by extension security.\nThe deterministic yet unpredictable properties of the block hash seed data in Session Generation, ensure that no malicious actors will be able to determine Application and Validator pairings. This is a common security mechanism used in Pocket Network.\nApplication Security The Application Authentication Token is the key mechanism for Applications to balance the security of their stake and UX of clients during servicing. Through the AAT, the Application is able to sanction clients to access their throughput via Digital Signature. Future implementations of the AAT include enforcing a lifecycle through expiration and other client access configurations such as Relay Chain specification.\nApplication Distribution Configuration is the recommended practice of distributing an Application ‚Äôs throughput over multiple Application stakes (or identities) to ensure the highest level of data accuracy, uptime, and data privacy.\nClient Side Validation is the recommended practice of redundantly sending the same request to multiple Validators. CSV allows the client to come to a majority consensus on the Relay Responses. This configuration ensures the highest level of data accuracy and enables the Application to use the Application Challenge Mechanism of the protocol, where corresponding minority Validator(s) providing invalid data are economically penalized.\nValidator Security A Validator will not receive mint for any service they provided while breaking the servicing protocol rules.\nThese rules are enforced by the Validators by verifying all the work reported to the network.\nExamples of breaking the Servicing Rules include:\nOverservicing an Application Incorrect App/Validator Pairing Incorrect Relay Chain Non-Unique Proof of Relays Invalid Merkle Root / Proof pairings Invalid Application Authentication Token A minority Validator in Client-Side Validation Invalid Servicer in Proof Below minimum Relay count ","description":"","tags":null,"title":"üõ° Security","uri":"/docs-hugo/learn/protocol/security/"},{"content":"POKT is the native cryptocurrency that powers Pocket. In this section, we‚Äôll go over how to store your POKT safely, as well as buying and staking.\nManage POKT Buy POKT Stake POKT Wrapped POKT (wPOKT) ","description":"","tags":null,"title":"üí∞ Get POKT","uri":"/docs-hugo/pokt/"},{"content":"This section will help you configure your instance of Pocket.\nCreate a Pocket wallet account Pocket nodes are associated with a Pocket wallet account. This is the account that will be used to send and receive transactions from the node. You can either create a new account using the Pocket CLI we just installed, or you can use an existing account. For this guide, we‚Äôll be creating a new account.\nCreating an account To create an account, run the following command:\npocket accounts create You‚Äôll be prompted to set a passphrase for the account. You can use any passphrase you like but for security reasons, it‚Äôs best to use a passphrase that is at least 12 characters long, preferably longer.\nListing accounts After you‚Äôve created the account you can use the pocket accounts list command to confirm that the account was added successfully.\npocket accounts list Setting the validator address Next, to set the account as the one the node will use, run the following command:\npocket accounts set-validator {YourAccountAddress} Confirm the validator address Finally, you can confirm that the validator address was set correctly by running the following command:\npocket accounts get-validator Create config.json The Pocket core software uses a config file to store configuration details. By default the config file is located at ~/.pocket/config/config.json. In this step we‚Äôll look at how to create a new config file.\nTo create a new config file:\nRun the following command, which will create the default config.json file, add the seeds, set port 8081 to 8082, and increase the RPC timeout value:\necho $(pocket util print-configs) | jq '.tendermint_config.P2P.Seeds = \"03b74fa3c68356bb40d58ecc10129479b159a145@seed1.mainnet.pokt.network:20656,64c91701ea98440bc3674fdb9a99311461cdfd6f@seed2.mainnet.pokt.network:21656,0057ee693f3ce332c4ffcb499ede024c586ae37b@seed3.mainnet.pokt.network:22856,9fd99b89947c6af57cd0269ad01ecb99960177cd@seed4.mainnet.pokt.network:23856,1243026603e9073507a3157bc4de99da74a078fc@seed5.mainnet.pokt.network:24856,6282b55feaff460bb35820363f1eb26237cf5ac3@seed6.mainnet.pokt.network:25856,3640ee055889befbc912dd7d3ed27d6791139395@seed7.mainnet.pokt.network:26856,1951cded4489bf51af56f3dbdd6df55c1a952b1a@seed8.mainnet.pokt.network:27856,a5f4a4cd88db9fd5def1574a0bffef3c6f354a76@seed9.mainnet.pokt.network:28856,d4039bd71d48def9f9f61f670c098b8956e52a08@seed10.mainnet.pokt.network:29856,5c133f07ed296bb9e21e3e42d5f26e0f7d2b2832@poktseed100.chainflow.io:26656\"' | jq '.pocket_config.rpc_timeout = 15000' | jq '.pocket_config.rpc_port = \"8082\"' | jq '.pocket_config.remote_cli_url = \"http://localhost:8082\"' | jq . \u003e ~/.pocket/config/config.json Warning This is a long command! Make sure you've copied it completely. Verify the config.json file setting by viewing the contents of the file:\ncat ~/.pocket/config/config.json Create chains.json Pocket nodes relay transactions to other blockchains. So, you‚Äôll need to configure the chains your node can relay to. For this guide, we‚Äôll just be setting up our node to relay to the Pocket mainnet blockchain, essentially through itself.\nTo maximize your rewards, you‚Äôll want to relay to other chains. We‚Äôll cover that in more detail later but here is a list of other blockchains you could relay to.\nGenerating a chains.json file with the CLI You can use the Pocket CLI to generate a chains.json file for your node by running the following command:\npocket util generate-chains This will prompt you for the following information:\nEnter the ID of the Pocket network identifier: 0001 Enter the URL of the network identifier. Use http://127.0.0.1:8081/ if you‚Äôre not running a validator node: http://127.0.0.1:8082/ When you‚Äôre prompted to add another chain, enter n for now.\nInfo By default the chains.json file will be created in ~/.pocket/config. You can use the --datadir flag to create the chains.json file in an alternate location. For example: pocket util generate-chains --datadir \"/mnt/data/.pocket\".\nCreate genesis.json Now that we have a chains.json file set up, so we can move on to test our node.\nWhen you start a Pocket node for the first time, it will need to find other nodes (peers) to connect with. To do that we use a file named genesis.json with details about peers the node should connect to get on the network.\nTo create a JSON file with the genesis information:\nChange to the .pocket/config directory: cd ~/.pocket/config Use the following command to get the genesis.json file from GitHub: wget https://raw.githubusercontent.com/pokt-network/pocket-network-genesis/master/mainnet/genesis.json genesis.json Set open file limits Ubuntu and other UNIX-like systems have a ulimit shell command that‚Äôs used to set resource limits for users. One of the limits that can be set is the number of open files a user is allowed to have. Pocket nodes will have a lot of files open at times, so we‚Äôll want to increase the default ulimit for the pocket user account.\nIncreasing the ulimit Before increasing the ulimit, you can check the current ulimit with the following command: ulimit -n Increase the ulimit to 16384. The -Sn option is for setting the soft limit on the number of open files: ulimit -Sn 16384 Check the new ulimit to confirm that it was set correctly. The -n option is for getting the limit for just the number of open files: ulimit -n Permanent settings Using the above method for setting the ulimit only keeps the change in effect for the current session. To permanently set the ulimit, you can do the following:\nOpen the /etc/security/limits.conf file. sudo nano /etc/security/limits.conf Add the following line to the bottom of the file: pocket soft nofile 16384 Save the file with Ctrl+O and then Enter. Exit nano with Ctrl+X. After permanently setting the ulimit, the next thing we‚Äôll do is download a snapshot of the Pocket blockchain.\nDownload snapshot Rather than synchronizing your Pocket node from block zero (which could take weeks), you can use a snapshot. A snapshot of the Pocket blockchain is taken every 12 hours and can be downloaded using the instructions on the Pocket Snapshots Repository README page.\nInfo As of this writing, the snapshots are refreshed every 12 hours. In the GitHub repo you can look at when the README.md file was last updated to determine when the last snapshot was taken. It‚Äôs best to download the snapshot that is less than a few hours old.\nHere are the steps for download the snapshot using the wget command:\nChange into the .pocket directory. cd ~/.pocket Make a directory named data and change into it. mkdir data \u0026\u0026 cd data Download the latest snapshot using the following command: wget -qO- https://snapshot.nodes.pokt.network/latest.tar.gz | tar xvfz - Make the pocket user the owner of the data directory. sudo chown -R pocket ~/.pocket/data Warning This process can take a few hours depending on your internet connection.\nConfigure systemd Next, we‚Äôll configure the Pocket service using systemd, a Linux service manager. This will enable the Pocket node to run and restart even when we‚Äôre not logged in.\nCreating a systemd service in Linux To setup a systemd service for Pocket, do the following:\nOpen nano and create a new file called pocket.service:\nsudo nano /etc/systemd/system/pocket.service Add the following lines to the file:\n[Unit] Description=Pocket service After=network.target Wants=network-online.target systemd-networkd-wait-online.service [Service] User=pocket Group=sudo ExecStart=/home/pocket/go/bin/pocket start ExecStop=/home/pocket/go/bin/pocket stop [Install] WantedBy=default.target Make sure the User is set to the user that will run the Pocket service.\nMake sure the ExecStart and ExecStop paths are set to the path for the Pocket binary.\nSave the file with Ctrl+O and then return.\nExit nano with Ctrl+X.\nReload the service files to include the pocket service:\nsudo systemctl daemon-reload Start the pocket service:\nsudo systemctl start pocket.service Verify the service is running:\nsudo systemctl status pocket.service Stop the pocket service:\nsudo systemctl stop pocket.service Verify the service is stopped:\nsudo systemctl status pocket.service Set the service to start on boot:\nsudo systemctl enable pocket.service Verify the service is set to start on boot:\nsudo systemctl list-unit-files --type=service Start the pocket service:\nsudo systemctl start pocket.service Other systemctl commands To restart the service:\nsudo systemctl restart pocket.service To prevent the service from starting on boot:\nsudo systemctl disable pocket.service To see mounted volumes:\nsudo systemctl list-units --type=mount Info If your pocket data is on a separate partition, you can use the following command in the `pocket.service` file to mount it before the pocket service starts. ``` After=network.target mnt-data.mount ``` This ensures that the network is up and the volume is mounted before the pocket service starts.\nViewing the logs To view the logs for the pocket service:\nsudo journalctl -u pocket.service To view just the last 100 lines of the logs (equivalent to the tail -f command):\nsudo journalctl -u pocket.service -n 100 --no-pager Finding Errors You can use grep to find errors in the logs.\nsudo journalctl -u pocket.service | grep -i error Alright, we‚Äôre just about done. We just need to setup an HTTP proxy and we‚Äôll be ready to go live. We‚Äôll setup the proxy next.\n","description":"Configure your Pocket node. Part 3 of 5 in the Zero to Node tutorial.","tags":null,"title":"Part 3 ‚Äì  Pocket configuration","uri":"/docs-hugo/node/tutorials/zero-to-node/pocket-config/"},{"content":"There is no many-to-one delegation in Pocket Network. You cannot simply stake POKT from your wallet and then forget about it. A POKT account must be staked on a node that is relaying RPC requests. However, if you do not have the skills to run a node yourself, you still have options.\nRun Your Own Node Running your own node is an option if you possess both of the following:\nThe DevOps skills to run your own node More than 15,000 POKT to meet the minimum node stake Read our tutorial on how to get started running your node.\nPay Someone to Run Your Node If you don‚Äôt possess the skills to run your own node, but you do have more than 15,000 POKT for the minimum node stake, you can pay someone else to run your node(s). Payment models include a monthly subscription and a revenue share of your node‚Äôs POKT earnings.\nAll third-party node runners can be found here.\nJoin a Staking Pool If you possess neither the skills nor more than the 15,000 POKT minimum node stake, you can join a staking pool. Like the third-party node runners above, staking pools are also entirely custodial, so be sure to do your due diligence. You can view the list of staking pools here.\n","description":"","tags":null,"title":"Stake POKT","uri":"/docs-hugo/pokt/stake/"},{"content":"The Purpose of POKT POKT is not a transactional cryptocurrency. The Pocket Network blockchain is not meant to have sub-5-second block times, provide 10,000 transactions per second, facilitate direct payments (generally speaking), or act as a smart contract platform. The majority of the transactions occurring will be staking by Applications and Service Nodes, Proof-of-Relay batches by Service Nodes, and block reward payments to Service Nodes for facilitating Relay requests, which all POKT holders will pay for via inflation.\nThis is in contrast to most layer 1 chains, which will eventually need to rely predominantly on transaction fees. At network maturity, Pocket will become a simple fee market with the demand side (Applications) burning POKT and the supply side (Service Nodes) receiving newly minted POKT via the block reward inflation mechanism. This allows for the transfer of value without using direct fees and incurring further costs of coordination.\nBy building a set of crypto-economic mechanisms to ensure the validation of Proofs-of-Relays, Pocket‚Äôs architecture can provide blockchain infrastructure at an order-of-magnitude lower cost than other options by virtue of being a permissionless, non-rent-seeking, and open marketplace for anyone to participate. Pocket Network uses these validated Proofs-of-Relays to reward Service Nodes through inflation.\nBoth Applications and Service Nodes must stake POKT to access or provide work to Pocket Network. For Applications utilizing the Pocket network, POKT represents an ongoing right to an allocation of the network‚Äôs throughput, whereas, for Service Nodes, POKT represents a right to provide ongoing work on the network and the future inflation rewards for performing that work.\nUseful Proofs of Work Pocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of generalized mining or ‚Äúuseful proofs of work.‚Äù Submitting proofs of work mints POKT in proportion to the amount of work completed increasing the overall supply of POKT. How this affects the overall supply is determined by the monetary policy.\nOur current monetary policy is broken down into two phases: the Growth Phase and the Maturity Phase. During the Growth Phase, applications stake just once to access the protocol (assuming they don‚Äôt change their throughput) attracting new applications to use the service due to the low cost of service - only paying through their initial stake and through inflation. At network maturity (the Maturity Phase), Pocket will become a simple fee market with the demand side (Applications) stakes are burned in proportion to the amount of POKT minted by the supply side (Nodes) - eliminating the growth in total supply of POKT. This allows for the transfer of value without using direct fees and incurring further costs of coordination.\nFor more information, read our page on Pocket monetary policy.\nTransactions Leader-elected nodes are rewarded for facilitating P2P transfers of POKT on the Pocket blockchain via a transaction fee. This is required for the security of the network in order to prevent spam or ‚Äúdust‚Äù attacks. A transaction fee is paid by the individual or entity making a transaction, 99% of which is burned, and the remaining 1% is awarded to the leader-elected node for including transactions in the relevant block. The 1% fee provides an incentive for block producers to include transactions in the next block.\nüå± Token Staking There are two distinct types of stake functions within Pocket: StakeApp() and StakeNode(). Both stake functions use the POKT cryptocurrency.\nApplication Staking Applications pay for the service in advance by staking POKT. When they invoke the StakeApp() function, the minimum staking period is 21 days. By incurring the minimum unstaking period, Applications forego the potential of using their resources, POKT in this case, for other alternatives as an opportunity cost. Additionally, Applications pay through dilution, where each time a Relay is serviced and validated by the network, a specific sum of POKT is awarded to the relevant Service Nodes in the next block reward.\nThe protocol limits the number of Relays an Application may access based on the number of POKT staked in relation to the Protocol Throttling Formula (as defined below). Once an Application stakes POKT, the Maximum Relays (MaxRelays) it can use is locked in perpetuity unless the Application re-stakes that POKT or their stake is burned.\nNode Staking Like with applications, when nodes invoke the StakeNode() function, the minimum staking period is 21 days. The minimum stake at launch required to become a Service Node is 15,000 POKT. This node stake keeps nodes honest and incentivized to provide high quality service. Additionally, a node sufficient stake allows nodes to participate in PoS consensus as a Validator Node. Per the changes in R.C.0.6.0, not all nodes are validators, but all validators are service nodes. To become a Validator Node, you must be in the top 1,000 node stakes (subject to change on DAO parameter vote) on the network. Validator Nodes can claim the block reward for submitting the block which is equal to the value of the ProposerAllocation parameter.\nWhile the Minimum Node Stake is 15,000 POKT, we highly recommend staking an amount greater than 15,000 the minimum in case of burning that may be caused by misconfiguration. Node runners have reported a stake of 15,100 POKT is a best practice.\nüîü POKT Denominations Info The current denomination used by the protocol is defined by the StakeDenom parameter. When using the Pocket CLI or PocketJS library to send transactions to the network, you will need to use this denomination.\nLevel Denomination Level 10^24 EPOKT ExaPOKT 10^21 PPOKT PetaPOKT 10^18 TPOKT TeraPOKT 10^15 GPOKT GigaPOKT 10^12 MPOKT MegaPOKT 10^9 KPOKT KiloPOKT 10^6 POKT POKT 10^3 mPOKT MiliPOKT 10^0 uPOKT Micro or ‚Äòyou‚ÄôPOKT Upper Bound = 9,223,372,036,854,775,807,000,000 STAKED uPOKT ","description":"An overview of Pocket Network Economics.","tags":null,"title":"ü™ô Token Economics","uri":"/docs-hugo/learn/economics/token/"},{"content":"What is wPOKT? Wrapped POKT (wPOKT) is an ERC-20 token backed 1:1 by POKT on the Pocket blockchain and held by a POKT wallet where the underlying holdings are verifiable. wPOKT standardizes POKT to the ERC20 format, enabling and leveraging the usage of smart contracts. Check out the whole green paper here.\nHow does staking wPOKT contribute to the Pocket Network? Data Farming allows Ethereum users to stake for infrastructure on behalf of their favorite Ethereum applications while earning rewards. Data Farming provides Apps with a mechanism to crowdsource free infrastructure from their users through network-specific pools and drives liquidity to wPOKT and subsequently POKT through proven liquidity farming mechanisms.\nThis means there are now two opportunities for capital providers to profit from supporting Pocket Network‚Äôs economy: stake POKT tokens as a Node Runner in the native Pocket Network ‚Äì earning staking rewards, serving relays to Apps, and securing the network ‚Äì or stake wPOKT as a Farmer ‚Äì earning farming rewards, subsidizing relays for Apps, and liquidizing the network.\nWhy incentivize wPOKT staking at all? Data farming is a bootstrapping program for Pocket Network. It‚Äôs designed to drive relays to the protocol, boosting rewards for nodes and farmers alike. The program encourages users to spread the word of Pocket Network so they can earn additional yield. To put things simply, every time a new application is onboarded to the program, a new pool can be created which is a new opportunity for farmers to earn more wPOKT.\nWill this undermine incentives to run nodes? We anticipate that the rewards for node running will remain at a premium to data farming due to the technical hurdles and inherent costs involved. We will be creating pools designed to maintain this balance.\nThe data farming program has been designed to open up channels of inclusivity that otherwise hadn‚Äôt previously existed in Pocket Network by creating a low-barrier way to contribute. We believe this program to be additive and non-competitive with node running rewards. In order to ensure there‚Äôs no vampiric conflict between the two systems, we‚Äôll be closely monitoring the impact of data farming on node running. If there is a substantially negative impact on the service that Pocket Network is providing, the farming program will be changed accordingly.\nWho holds the staked wPOKT? The staking pool contracts hold the staked wPOKT tokens and the wPOKT tokens for distribution (in the locked and unlocked pools). All ownership is accounted for on-chain via smart contracts.\nHow is my reward share calculated? The more you stake and the longer you stake wPOKT relative to others, the greater share of the unlock pool you receive.\n$$ UserStakingTokenTime / GlobalStakingTokenTime $$As an example, imagine there are two users in the system, Valeria and Jack. Valeria has staked 10 tokens for 1 day, Jack has staked 5 tokens for 3 days.\nValeria_token_time = 10 tokens * 1 days = 10\nJack_token_time = 5 tokens * 3 days = 15\nGlobal_staking_token_time = (Valeria_token_time) + (Jack_token_time) = 25 token_time\nValeria owns (10 / 25) = 40% of unlocked rewards\nJack owns (15 / 25) = 60% of unlocked rewards\nIn this system, rewards are earned based on the total ownership of unlocked rewards in a pool.\nOwnership percentages and token unlocks are continuous, meaning they‚Äôre calculated block-by-block.\n*These percentages assume the maximum bonus from the bonus period has been met.\nHow does the Bonus Period work? The staking pool is designed to incentivize long-term liquidity providers. While there are no hard lockup periods for staking, there is a benefit to keeping your staked position longer.\nWhen you begin staking, you begin at a 1X bonus multiplier on your reward earnings. This multiplier increases throughout the trial period, to a maximum of 3X after two months. An easy way to think about it is each additional month you hold, you receive ‚Äòan extra X‚Äô on your multiplier, up to a maximum of 3X. For example, holding for an entire month gives you a 2X multiplier, and holding for two months, a 3X multiplier. If you withdraw half-way through month 2 (after 6 weeks), you would get half-way between 2X and 3X. It‚Äôs a simple linear function.\nEach individual stake amount marks the beginning of its own period. So if you stake two times then withdraw, the first stake and the second stake may have different bonus amounts. Withdrawn stakes always start with the newest staked tokens.\nWhat‚Äôs an LBP? LBP (Liquidity Bootstrapping Pool) is an adjustable Balancer smart pool that is used for initial distribution and price discovery of tokens. It continually changes the weights of the assets in the pool which has the effect of suppressing the price of the distributed token if there is no demand. These mechanisms are designed to distribute wPOKT as fairly as possible while encouraging price discovery. You can learn more about LBPs here and here.\nThe LBP will be a limited-time distribution event and afterward, liquidity will be moved to Uniswap or another viable DEX.\nWhat happens to the LBP proceeds? After the distribution event occurs, there will be both wPOKT and a stablecoin left in the pool. 100% of these funds will be moved to a new pool on Uniswap that will act as an on/off ramp for new and existing users. This pool will be a 50/50 weighted pool which will require the addition of some wPOKT to balance the pool to the last known LBP pool price (assuming more than 50% of wPOKT is sold). We may elect to change one of the assets in the pool (for example, DAI to ETH) to encourage more usage, but the total value of tokens will remain the same.\nWho are the wPOKT Data Farming program launch partners? These are the applications available to support in the genesis wPOKT farm! Please, welcome our wPOKT launch partners:\nFuse Razor MyCrypto Centaur EthersJS Faculty Group Snowball Streamr Seascape PLOTx Finance.Vote API3 DApp[.]com Ferrum Mask Network EarniFi ","description":"","tags":null,"title":"üéÅ Wrapped POKT (wPOKT)","uri":"/docs-hugo/pokt/wpokt/"},{"content":"Important Initial Application Parameters Item Initial Parameter Minimum Application Stake 1 POKT Minimum Unbonding Period (Apps) 21 days BaseRelaysPerPOKT 1.67 relays per session Stability Adjustment 0 Participation Rate Active False Block Time 15 minutes Session Time 4 blocks (60 minutes) Session Node Count 5 nodes Max Chains per Stake 15 Application Economics Pocket Network is a developer-driven protocol, with demand from Applications driving the rewards the Service Nodes earn. Applications use Pocket Network to retrieve data and write state to and for their blockchain applications. Each Relay that is created by an Application results in the creation of newly-minted POKT as a reward for the Service Nodes facilitating such Relays. Applications stake just once to access the protocol (assuming they don‚Äôt change their throughput), using the native cryptocurrency POKT which is tied for single-use to the Pocket blockchain.\nThe protocol limits the number of Relays an Application may access based on the number of POKT staked in relation to the Protocol Throttling Formula (as defined below). Once an Application stakes POKT, the Maximum Relays (MaxRelays) it can use is locked in perpetuity unless the Application re-stakes that POKT or their stake is burned.\nDue to the oracle problem, the protocol cannot infer external factors that might influence the market price of POKT, or therefore account for these factors in the Protocol Throttling Formula. This introduces a risk to the demand side of the protocol, where fluctuations in the market price of POKT may affect the price Applications must pay for Relays.\nWe aim to allow the market to find a $USDPerRelay Target for POKT, to ensure the real price borne by Applications is within a relatively stable and acceptable range. This $USDPerRelay Target is not an on-chain variable, but a publicly agreed price that the DAO will target with its monetary policy, by adjusting variables in the Protocol Throttling Formula.\nCalculating Throughput When Applications stake POKT, their rate for the number of Relays they may access (MaxRelays) is locked in for the entire length of the stake. Due to the oracle problem, the protocol cannot infer external factors that might influence the market price of POKT, or therefore account for these factors in the Protocol Throttling Formula. This introduces a risk to the demand side of the protocol, where fluctuations in the market price of POKT may affect the price Applications must pay for Relays.\nWe aim to allow the market to find a $USDPerRelay Target for POKT, to ensure the real price borne by Applications is within a relatively stable and acceptable range. This $USDPerRelay Target is not an on-chain variable, but a publicly agreed price that the DAO will target with its monetary policy, by adjusting variables in the Protocol Throttling Formula.\nWhen Applications stake POKT, their rate for the number of Relays they may access (MaxRelays) is locked in for the entire length of the stake. We use the following simple formula to calculate the amount of Relays Applications are entitled to per Session.\n$$ MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput) $$These three variables, StabilityAdjustment, ParticipationRate, and BaseThroughput aim to dynamically reflect POKT‚Äôs usage and ensure that Applications will be able to enter the ecosystem adjusting to changes in the market price of POKT.\nTo keep the real $USDPerRelay price as close to the $USDPerRelay Target as possible, the Protocol Throttling Formula multiplies BaseThroughput by the total ParticipationRate of the protocol to reflect any changes in demand for Relays, then the DAO will use the StabilityAdjustment in the short-term to correct deviations from the $USDPerRelay Target that are most likely attributed to short-term changes inherent in the random walk of the cryptocurrency/FOREX markets. If the StabilityAdjustment persists above/below zero without resetting, we can attribute the deviation from the $USDPerRelay Target to a more permanent change in POKT‚Äôs market value, at which point the DAO will update BaseRelaysPerPOKT and reset StabilityAdjustment to zero.\nLearn more about each variable below.\nStability Adjustment The StabilityAdjustment parameter helps smooth out pricing for applications because there is a menu cost associated with changing BaseRelaysPerPOKT too often. Applications will be reliant on a relatively stable real $USDPerRelay price to access throughput. Community resources and consistent communication will help them make decisions about how much POKT to stake at any given moment.\nPocket‚Äôs price target optimization problem will rely on off-chain data about a given currency‚Äôs current exchange rate with POKT, e.g. using $USDPerPOKT to measure how close the real $USDPerRelay price is to the DAO‚Äôs current $USDPerRelay Target. Short-term fluctuations will therefore be arbitrary depending on which currency has been chosen to anchor the DAO‚Äôs price target against and what is happening day-to-day in the crypto and FOREX markets; today $USDPerPOKT might change by 5% but ‚Ç¨EURPerPOKT only changes by 1%. It is important that we don‚Äôt let short-term fluctuations impact the stability and accessibility of the network.\nWe can therefore use the StabilityAdjustment to dynamically adjust the MaxRelays computed in the Protocol Throttling Formula, while only changing our ‚Äúmenu price‚Äù (BaseRelaysPerPOKT) when there is a long-term deviation that can be more assuredly attributed to long-term changes in POKT‚Äôs value.\nThe StabilityAdjustment will be updated at the discretion of the DAO.\nParticipation Rate Not implemented initially, the ParticipationRate is a tool to dynamically adjust max relays for applications without the intervention of the DAO as network usage changes. ParticipationRateacts as a proxy for utilization of the network and is reflected on a block by block basis, adjusting an Application‚Äôs MaxRelays dynamically based on the growth or decline in network-wide stake rates. Participation Rate is calculated by:\n$$ ParticipationRate = (appStakedPOKT + nodeStakedPOKT) / TotalPOKT $$The StabilityAdjustment and BaseRelaysPerPOKT help calibrate the natural ParticipationRate. Changes to the $USDPerRelay Target will be made by the Pocket DAO using a proposal system similar to MakerDAO‚Äôs Stability fee votes.\nAs the protocol matures, the market will dictate what price Applications should be paying for Relays, reflected by the Pocket DAO deciding on the $USDPerRelay Target. As the on-chain MaxRelays for Applications adjusts over time, existing Applications with locked-in rates for MaxRelays will be faced with two scenarios:\nIn a downside scenario, where the rate for MaxRelays drops below an Application‚Äôs current locked-in rate, Applications are incentivized to keep their POKT staked to continue receiving throughput at an above market rate. In an upside scenario, where the rate for MaxRelays rises above an Application‚Äôs current locked-in rate, Applications will be incentivized to unstake and restake their POKT to receive more Relays for the same amount of POKT. Regardless of the scenario, applications are able to benefit from shifts in the market for POKT making the most of their stake.\nBase Throughput BaseThroughput is the baseline number of Relays we aim for an Application to get per POKT staked, assuming no external factors influencing POKT. This is calculated as:\n$$ BaseThroughput = BaseRelaysPerPOKT * StakedPOKT $$BaseRelaysPerPOKT is a uint64, governed by the Pocket DAO, which describes the baseline number of Relays the Pocket DAO aims for each Application to receive per POKT staked. As a multiplier, changing this number more significantly impacts MaxRelays than changing StabilityAdjustment. For further granularity, BaseRelaysPerPOKT can be expressed as:\n$$ BaseRelaysPerPOKT = BaseRelaysPerPOKTNumerator / BaseRelaysPerPOKTDenominator $$This allows the protocol to express decimals in the form of fractional integers, enabling more granularity for the BaseRelaysPerPOKT number.\nDue to the oracle problem, it is not possible to automatically adjust BaseRelaysPerPOKT based on the market price of POKT. The DAO will track indicators (such as ParticipationRate as well as the rate of change of new POKT being staked on the demand side), and adjust Pocket‚Äôs economic levers, as necessary, to ensure that Relays remain affordable for Applications.\nTo keep the real $USDPerRelay price as close to the $USDPerRelay Target as possible, the Protocol Throttling Formula multiplies BaseThroughput by the total ParticipationRate of the protocol to reflect any changes in demand for Relays, then the DAO will use the StabilityAdjustment in the short-term to correct deviations from the $USDPerRelay Target that are most likely attributed to short-term changes inherent in the random walk of the cryptocurrency/FOREX markets. If the StabilityAdjustment persists above/below zero without resetting, we can attribute the deviation from the $USDPerRelay Target to a more permanent change in POKT‚Äôs market value, at which point the DAO will update BaseRelaysPerPOKT and reset StabilityAdjustment to zero.\nThe BaseRelaysPerPOKT will be updated at the discretion of the DAO.\n","description":"An overview of Pocket Network application economics.","tags":null,"title":"üíª App Economics","uri":"/docs-hugo/learn/economics/apps/"},{"content":"","description":"","tags":null,"title":"Learn Pocket","uri":"/docs-hugo/learn/"},{"content":"This section will help you set up the proxy setting on your node.\nSetup SSL Pocket requires that nodes have an SSL certificate for secure communications. SSL (Secure Sockets Layer) is a layer of security that sits on top of TCP/IP. It‚Äôs used to encrypt the data sent between a client and a server. To use SSL, you need to have a certificate and a key. Thankfully, getting an SSL certificate is straightforward and free.\nTo get a certificate, we‚Äôll be using Let‚Äôs Encrypt which is a service that issues SSL certificates for free. We‚Äôll also be using software called certbot to register, install, and renew the certificate.\nRegistering an SSL certificate We installed certbot in a previous step so we just need to use it to request a certificate.\nTo get a certificate, we‚Äôll need to use the certbot command with the following options:\n--register-unsafely-without-email: This option is required to get a certificate without an email address. --agree-tos: This option is required to agree to the Let‚Äôs Encrypt Terms of Service. --nginx: This option is required to use the nginx plugin. --no-redirect: This option is required to disable the redirect to the Let‚Äôs Encrypt website. --domain: This option is required to specify the domain name. Here‚Äôs an example of how to request a certificate. Just replace $HOSTNAME with the DNS name of your node:\nsudo certbot --nginx --domain $HOSTNAME --register-unsafely-without-email --no-redirect --agree-tos The output from this command should confirm that the certificate was successfully registered.\nTesting your certificate To be sure, you‚Äôll also want to test that the certificate is working.\nThere is a command that certbot provides to test your certificate. It‚Äôs used for testing the auto-renewal of the certificate but it also confirms that the certificate is working. You can run it using the following command:\nsudo certbot renew --dry-run The resulting output should confirm that the certificate is working.\nConfigure Nginx Nginx is a web server. We installed it in aprevious step but we need to do some additional configuration.\nNginx uses config files to define servers and routes for incoming requests. For Pocket nodes, nginx needs to relay public requests to a local HTTP server that pocket core is running. This is referred to as the proxy. We‚Äôll also need to proxy requests made by the Pocket CLI. For example, when we run the command pocket query height, the CLI makes an http request to the node‚Äôs local HTTP server.\nConfig files The nginx configuration files we‚Äôre interested in are located in the /etc/nginx/sites-available/ directory. In that directory there is a default configuration file named default. This is the configuration that is created when you install nginx, but we‚Äôll be creating our own for our node.\nTo configure nginx:\nConfirm the name of your SSL certificate: sudo ls /etc/letsencrypt/live/ Create a new config file with nano: sudo nano /etc/nginx/sites-available/pocket Add the following code but change the hostname values (pokt001.pokt.run) to your node‚Äôs DNS hostname: server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / { try_files $uri $uri/ =404; } } server { add_header Access-Control-Allow-Origin \"*\"; listen 80 ; listen [::]:80 ; listen 8081 ssl; listen [::]:8081 ssl; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name pokt001.pokt.run; location / { try_files $uri $uri/ =404; } listen [::]:443 ssl ipv6only=on; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/pokt001.pokt.run/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/pokt001.pokt.run/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; access_log /var/log/nginx/reverse-access.log; error_log /var/log/nginx/reverse-error.log; location ~* ^/v1/client/(dispatch|relay|challenge|sim) { proxy_pass http://127.0.0.1:8082; add_header Access-Control-Allow-Methods \"POST, OPTIONS\"; allow all; } location = /v1 { add_header Access-Control-Allow-Methods \"GET\"; proxy_pass http://127.0.0.1:8082; allow all; } } Save the change with Ctrl+O. Exit nano with Ctrl+X. Stop nginx with: sudo systemctl stop nginx Disable the default configuration: sudo rm /etc/nginx/sites-enabled/default Enable our new configuration: sudo ln -s /etc/nginx/sites-available/pocket /etc/nginx/sites-enabled/pocket Start nginx: sudo systemctl start nginx Enable UFW We‚Äôre almost done, but before we finish we‚Äôll make our server more secure by setting firewall rules to limit network exposure. The Uncomplicated Firewall (UFW) is a security tool that makes configuring the firewall reasonably simple. We‚Äôll use it to disable unnecessary ports.\nPorts you need to open For running a Pocket node, you‚Äôll need to open the following ports:\n22: SSH 80: HTTP 443: HTTPS 8081: For the Pocket HTTP API 26656: For the Pocket RPC API Use UFW to disable unnecessary ports To use UFW to configure the firewall:\nEnable UFW. When prompted, press y to confirm:\nsudo ufw enable Set the default to deny all incoming connections:\nsudo ufw default deny Allow the SSH port:\nsudo ufw allow ssh Allow port 80:\nsudo ufw allow 80 Allow port 443:\nsudo ufw allow 443 Allow port 8081:\nsudo ufw allow 8081 Allow port 26656:\nsudo ufw allow 26656 That‚Äôs it for the UFW setup. Let‚Äôs just check the status to confirm the ports are open. To do that, run the following command:\nsudo ufw status After confirming only the necessary ports are open, you can move on to the final steps.\n","description":"Configure the proxy for your node. Part 4 of 5 in the Zero to Node tutorial.","tags":null,"title":"Part 4 ‚Äì  Proxy configuration","uri":"/docs-hugo/node/tutorials/zero-to-node/proxy-config/"},{"content":"This section will details the final steps in going live with your node.\nTest everything At this point your Pocket node should be up and running!\nBut you‚Äôll want to test it to confirm. The following are some of the things you can do to test your Pocket Node.\nMake sure the Pocket process is running The first thing to check is that the pocket service is running. You can do that by running the following command:\ntop -b -n 1 | grep pocket You should see output similar to the following:\n44871 root 20 0 1018268 33948 21448 S 0.0 0.4 0:00.17 pocket Block height You‚Äôll want to check that the node is fully synced with the Pocket blockchain. The easiest way is to run the following command:\npocket query height The result should look something like the following.\n{ \"height\": 48161 } Network status Another way to see if your node is fully synced is to check the status with the following command:\ncurl http://127.0.0.1:26657/status The result should look something like the following. Note the highlighted property catching_up which indicates if the node is catching up with the blockchain or fully synced. In the example below, the node is fully synced.\n{ \"jsonrpc\": \"2.0\", \"id\": -1, \"result\": { \"node_info\": { \"protocol_version\": { \"p2p\": \"7\", \"block\": \"10\", \"app\": \"0\" }, \"id\": \"80b80c106115259349df8ef06267cff7bbabd194\", \"listen_addr\": \"tcp://0.0.0.0:26656\", \"network\": \"mainnet\", \"version\": \"0.33.7\", \"channels\": \"4020212223303800\", \"moniker\": \"localhost\", \"other\": { \"tx_index\": \"on\", \"rpc_address\": \"tcp://127.0.0.1:26657\" } }, \"sync_info\": { \"latest_block_hash\": \"F39BBF5C64D9E02E28DDBB8640F84A22CFAE1727CFBC72537982EF5914E4BB25\", \"latest_app_hash\": \"6198835747411135C1F812CB45FA5621D5ADB63342EC0678C20879D7D39F03B5\", \"latest_block_height\": \"50021\", \"latest_block_time\": \"2022-02-04T12:16:10.77575197Z\", \"earliest_block_hash\": \"7D551967CB8BBC9F8C0EAE78797D0576951DDA25CE63DF1801C020478C0B02F8\", \"earliest_app_hash\": \"\", \"earliest_block_height\": \"1\", \"earliest_block_time\": \"2020-07-28T15:00:00Z\", \"catching_up\": false }, \"validator_info\": { \"address\": \"80B80C106115259349DF8EF06267CFF7BBABD194\", \"pub_key\": { \"type\": \"tendermint/PubKeyEd25519\", \"value\": \"ee+o9bKqCbAO13FgWTLmJdi9hhfYg8AHsif5430uz8A=\" }, \"voting_power\": \"0\" } } } Make sure your node is visible to other nodes You‚Äôll also want to make sure your node is accessible to other nodes.\nTo test and confirm your node is visible to other nodes on the public network, you‚Äôll make an HTTP request using the public DNS name for the node. You can use the following command to make that request:\ncurl https://pokt001.pokt.run:8081/v1 Info As always, don‚Äôt forget to change pokt001.pokt.run to the DNS name for your node.\nThis should return something like the following. This is the version of pocket-core that is running.\n\"RC-0.8.2\" Staking your node To earn POKT rewards, you‚Äôll need to stake at least 15,000 POKT. That said, you should stake at least 15,100 POKT or more to be safe. This provides a little extra room in case your node gets slashed (penalized) for some reason.\nWarning Please make sure that you understand the risks associated with staking POKT and running a Pocket node.\nIf you‚Äôre using the Pocket CLI to fund an account, keep in mind that the CLI uses uPOKT (the smallest unit of POKT) for its calculations. The formula for converting POKT to uPOKT is: uPOKT = POKT * 10^6. So, multiplying 15050 POKT by 10^6 (one million) will result in 15050000000 uPOKT.\nAlso keep in mind that there is a cost for every transaction you send. At the moment, that cost is a flat fee of 0.01 POKT, or 10000 uPOKT, but this may be subject to change.\nList your accounts: pocket accounts list Confirm the validator account is set: pocket accounts get-validator Confirm the validator account has enough POKT. This should be at least 15,101 POKT. You‚Äôll want 15,100 to stake and a bit more for network fees: pocket query balance {YourValidatorAddress} Stake your node, making sure to enter the correct details for your setup: pocket nodes stake custodial {YourValidatorAddress} 15100000000 {ChainIDs} https://{hostname}:443 mainnet 10000 true Info The {ChainIDs} placeholder should be a list of relay chain IDs that are defined in your ~/.pocket/config/chains.json file. In this guide we only set up 0001, but if you were relaying to multiple chains, each id would be separated by a comma. For example, 0001,0022,0040.\nInfo As of RC-0.8.2 there are two staking methods: custodial and non-custodial. The custodial method is used in the example above.\nAfter you send the stake command, you‚Äôll be prompted for your passphrase, then you should see something like this:\nhttp://localhost:8082/v1/client/rawtx { \"logs\": null, \"txhash\": \"155D46196C69F75F85791C4190D384B8BAFFBBEFCC5D1311130C54A1C54435A7\" } The actual time it takes to stake will vary depending on when the last block was processed, but generally, it should take less than 15 minutes.\nConfirm your node is live After you‚Äôve staked your node, you can confirm it‚Äôs live by running the following command:\npocket query node {YourValidatorAddress} If you see something like the following, it just means your node is not live yet:\nhttp://localhost:8082/v1/query/node the http status code was not okay: 400, and the status was: 400 Bad Request, with a response of {\"code\":400,\"message\":\"validator not found for 07f5084ab5f5246d747fd1154d5d4387ee5a7111\"} If this happens, please wait a few minutes and try again.\nTutorial complete Congratulations! You‚Äôve successfully set up a Pocket node.\nThere‚Äôs more to running a Pocket node than this, such as maintenance, upgrades, and other administrative tasks, but hopefully this has gotten you started and on the right path. Thank you for doing your part to help decentralize Web3!\n","description":"Final steps for going live with your node. Part 5 of 5 in the Zero to Node tutorial.","tags":null,"title":"Part 5 ‚Äì  Going live","uri":"/docs-hugo/node/tutorials/zero-to-node/going-live/"},{"content":"","description":"","tags":null,"title":"Use Pocket","uri":"/docs-hugo/use/"},{"content":"Decentralizing Web3 Access Web3 is built on incentives.\nBlockchains enable unstoppable validation of transactions by incentivizing validator nodes, with mining/staking rewards, to confirm transactions. However, while this ensures an unstoppable history of transactions, it doesn‚Äôt ensure unstoppable access to read the history or to write new transactions to the history.\nMany blockchain communities have debated incentivizing the RPC nodes that provide this access to the blockchain. Facing quite a complex challenge though, they have rejected on-chain solutions, expecting that altruists would run RPC nodes for the good of the network.\nHowever, in the name of convenience, as RPC nodes have grown more expensive to maintain and developers more specialized, Web3 RPC access has consolidated around centralized gatekeepers. When you use MetaMask to sign transactions in your favorite game or NFT marketplace, assuming you haven‚Äôt already switched your custom RPC to Pocket Network, your data is flowing through a centralized cluster of RPC nodes. This means you are vulnerable to outages.\nPocket Network solves this critical flaw in the Web3 stack by incentivizing a network of RPC nodes to relay your data to any blockchain. DApps send their RPC requests to the nodes, who relay the requests and use Zero-Knowledge Range Proofs to validate the Relay Evidence that determines their POKT block reward. As well as making Web3 access unstoppable, this has the side effect of making Web3 infrastructure cheaper, by eliminating rent-seeking intermediaries, and more private, since each RPC node relays only a fraction of your data.\nLearn more about Pocket Network‚Äôs current protocol.\nLearn more about v1, the future of Pocket Network‚Äôs protocol.\nHow POKT Incentivizes RPC Nodes Pocket Network‚Äôs unstoppable Web3 access is powered by the POKT utility token.\nApplications stake POKT to lock in an RPC relay allowance, then transfer value to nodes through dilution of their stake proportional to the number of relays they request. Meanwhile, RPC nodes are participating in a perpetual fair-launch economy in which tokens are continuously rewarded to the nodes who do the most work.\nThis economic model has the following benefits:\nMinimizes the number of transactions needed to coordinate the network, enabling cheaper RPC access. Per-relay micro-transaction payment models, on the other hand, would needlessly congest block space. Provides extra incentive to apps to be early adopters of Pocket Network. When using Pocket Network, RPC infrastructure becomes an asset, literally. Apps make an upfront investment by staking POKT, which means they don‚Äôt need to worry about monthly bills and their cost-per-relay approaches zero the more relays they use. This makes Pocket Network‚Äôs RPC service very attractive compared to the competition in the long run. Once the POKT ecosystem is mature, when apps can frictionlessly top-up their stakes, and we no longer need bootstrapping incentives, the protocol has a dormant burning mechanism that the DAO can activate to burn app stakes proportional to the number of relays they request. This will have the effect of transforming Pocket Network‚Äôs business model into a standard credit system and making POKT deflationary.\nLearn more about Pocket Network‚Äôs economics and also the future of Pocket with v1.\nüí∏ Decentralizing Infrastructure We posit that application-specific blockchains like Pocket Network have the ability to design greater cost efficiencies at the base protocol layer of the Web3 stack while enhancing security and censorship resistance.\nPocket achieves this through an incentive design that rewards Service Nodes for collectively achieving economies of scale:\nLoad balancing at the protocol level incentivizes decentralization and minimizes the need for buffers Staking and inflation enables more efficient resource allocation Low marginal costs reduce barriers to entry, allowing anyone to participate at any scale Load balancing at the protocol level Due to the protocol using pseudo-random mechanisms to load balance work evenly across all nodes in the network, the optimal deployment strategy for node providers is to horizontally scale the number of Service Nodes they run (rather than to scale vertically by increasing the POKT stake of the Service Nodes they already have) to increase the probability that they‚Äôll receive work. By decreasing the average work per Service Node, participants of all scales are encouraged to provision their computing power to Pocket Network. This aspect of Pocket‚Äôs system design means Pocket Network‚Äôs node counts will increase as it scales.\nTo minimize the marginal cost of each Service Node, it will ultimately become more profitable to run nodes out of homes and local data centers, which will, over time, create a lower-cost, more efficient decentralized network.\nPocket‚Äôs distributed nature makes it redundant-by-design, removing the need for node operators to provision extra infrastructure to handle surges in user traffic. Web2 cloud-powered infrastructure requires large buffers of redundant server capacity, which can increase the costs of coordination borne by Web3 users by up to 50%. Conversely, instead of one entity providing all the work, Pocket Network naturally splits demand up amongst Service Nodes through its Session data structure, tumbling new, pseudo-random nodes every Session to give all Service Nodes the opportunity to provide work. As a result, the buffer that each Service Node must provide is significantly lower. Additionally, because Applications must stake POKT to access the service, Service Nodes can account for all potential requests paid for in aggregate, using Application Stake as a gauge of network capacity.\nStaking and inflation For a decentralized infrastructure service like Pocket Network, on-chain payments via Bitcoin, ETH, or DAI would be inefficient due to the frequency of Relay requests. While state channel implementations do improve the cost of coordination for micropayments, Pocket matches Applications with 5 pseudo-random Service Nodes every 25 blocks for security purposes; creating and breaking on-chain state channels to communicate with each of these nodes would make the cost of coordination impractically high.\nPocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of generalized mining or useful proofs of work, where inflation is directly tied to work validated by the network. Applications stake just once to access the protocol (assuming they don‚Äôt change their throughput), using the native cryptocurrency POKT which is tied for single-use to the Pocket blockchain. Service Nodes batch all requests received in a Session to one Pocket blockchain transaction, a ‚ÄúProof-of-Relay‚Äù that Applications can validate client-side and other nodes can validate in block production, removing the need for Applications to pay constant transaction fees for this work. Once those Proofs-of-Relays are validated by the network, a new block is confirmed, then POKT is minted and issued to the relevant Service Nodes as a reward for their work.\nPocket‚Äôs staking and inflation mechanisms enable a more efficient resource allocation structure by limiting the number of transactions (and thus block validation costs) to one-time staking transactions. All nodes are able to focus primarily on servicing and validating Relay requests by Applications, with minimal energy spent on block validation. By being eventually consistent and tying rewards directly to inflation, Service Nodes are in effect, receiving micropayments for work validated by two parties without the need for constant on-chain fee payments.\nLow marginal costs and participation The marginal cost of running an individual Service Node is only as high as your electricity and bandwidth costs, ensuring a low barrier to entry for new Service Node operators. Because work is load balanced evenly across the protocol, the stake, size, or capabilities of the Service Node does not increase the probability of receiving work, which enables hobbyists and small providers to participate and contribute alongside major infrastructure providers. As smaller Service Node operators scale up, they can then choose to bear the costs of hardware, equipment, and salaries needed to add more Service Nodes to their operation.\nWhile the bulk of work will most likely be serviced by professional infrastructure providers, Pocket also enables a long tail of individuals to participate and increase the resilience of the protocol, with potential for upward mobility for those who choose to purchase more Service Nodes.\n","description":"","tags":null,"title":"Vision","uri":"/docs-hugo/learn/vision/"},{"content":"Overview Pocket uses Proof-of-Stake (PoS) to secure the state machine and falls under the umbrella of generalized mining or useful proofs of work, where inflation is directly tied to work validated by the network.\nService Nodes batch all requests received in a session to one Pocket blockchain transaction, a ‚ÄúProof-of-Relay‚Äù that Applications can validate client-side and other nodes can validate in block production, removing the need for Applications to pay constant transaction fees for this work. Once those Proofs-of-Relays are validated by the network, a new block is confirmed, then POKT is minted and issued to the relevant Service Nodes as a reward for their work.\nService Nodes are pseudo-randomly assigned to a Session. Every Service Node who has staked the required node security deposit has an equal chance of being chosen in every available Session within the protocol regardless of how much POKT they have staked. New Sessions get created every 25 blocks with a new, pseudo-random set of Service Nodes.\nNode Staking Like with applications, when nodes invoke the StakeNode() function, the minimum staking period is 21 days. The minimum stake at launch required to become a Service Node is 15,000 POKT. This node stake keeps nodes honest and incentivized to provide high quality service. Additionally, a node sufficient stake allows nodes to participate in PoS consensus as a Validator Node. Per the changes in RC-0.7.0, not all nodes are validators, but all validators are service nodes. To become a Validator Node, you must be in the top 1,000 node stakes on the network. Validator Nodes can claim a block reward percentage for submitting the block equal to the value of the ProposerAllocation parameter.\nWhile the Minimum Node Stake is 15,000 POKT, we highly recommend staking an amount greater than 15,000 the minimum in case of burning that may be caused by misconfiguration. Node runners have reported a stake of 15,100 POKT is a best practice.\nDistribution of Service Nodes While Pocket Network will depend on professional infrastructure providers to provide the bulk of the infrastructure for applications, due to the low marginal cost of running a full Service Node, we expect there to be a long tail of individuals running Service Nodes. There are two primary objectives that the network will focus on to avoid any stagnation in the number of Service Nodes in the network:\nContinuing to lower the barrier to entry for non-technical users to run full nodes by providing clear documentation as well as technical support in the bootstrapping days of the network Ensuring that the minimum stake to become a Service Node within Pocket is kept low enough to maximize the number of nodes within the network Additional efforts to prevent stagnation include supporting distribution channels such as local mining pools through data centers, run-your-own node distribution partners and the Pocket DAO‚Äôs R\u0026D efforts.\nIncentivizing the long tail of individuals running Service Nodes and keeping barriers to entry low is important to keep large node providers honest, and to minimize the odds of having an entire set of Service Nodes in a Session owned by one entity, which could lead to collusion attempts.\nOptimal Deployment Strategy The optimal economic strategy for node operators is to replicate as many Service Nodes as they can with the amount of POKT they hold, thereby spreading out their POKT holdings. By dispersing their stake amongst many Service Nodes, node operators maximize their chances of being chosen in as many Sessions as possible, providing them with the opportunity to serve Relays within the network. These incentives promote further decentralization, redundancy and the number of nodes available for each blockchain network supported by Pocket.\nCost to Nodes Upfront costs There are two initial costs to becoming a Service Node:\nMinimum Node Stake Hardware (if chosen) Hardware Pocket Network is neutral to the hardware utilized by Service Nodes, meaning that hardware can be a physical server that is run in a home or a local data center, or computing power can be purchased through popular cloud providers. The specs required for a Service Node‚Äôs hardware is dependent on the blockchain(s) that a Service Node chooses to support. For example, if a Service Node were to choose to support Ethereum, the server would need to have at least 1TB of storage (as of writing) to support an archival node for Ethereum.\nStake The minimum stake at launch required to become a Service Node is 15,000 POKT. This minimum stake also allows Service Nodes to participate in PoS consensus. If a Service Node stake falls below the minimum amount through serving incorrect data or incorrect block validation, 20% of the minimum stake for that Service Node will be slashed and jailed. If a Service Node submits a fraudulent Relay batch, 100% of their stake will be slashed. The initial amount of POKT needed to stake as a Service Node is not dynamic, but can be raised or lowered by the Pocket DAO to ensure a stable barrier to entry.\nOnce the initial costs of a Service Node are covered, the only additional cost is electricity and bandwidth for providing the computing power to complete Relays. Marginal costs for Service Nodes are extremely low and increase linearly as work increases.\nRecurring costs Cloud providers Electricity Bandwidth Data center Outside of the fixed costs associated with running a node, Service Node operators will also incur costs like electricity, data center fees, and bandwidth costs for physical hardware. Alternatively, if they opt for a cloud-hosted service, they‚Äôll be paying an all-in fee for hosting. Again, these marginal fees are low, but will play a factor in node profitability and total node counts.\nEconomic Security The initial amount of POKT needed to stake as a Service Node is not dynamic, but can be raised or lowered by the Pocket DAO to ensure a stable barrier to entry.\nJailing and Slashing Jailing a Validator removes them from both protocol service and consensus. Slashing a Validator burns a percentage of the ‚ÄòStaked Tokens‚Äô A Validator is jailed and subsequently slashed for not signing (or incorrectly signing) block proposals. More often than not, this is the reason why Validators are jailed.\nIf a Validator falls below the minimum stake (due to slashing) it will be forcibly removed by the protocol and all Staked Tokens burned. This feature of the protocol highlights the importance of staking ‚Äòwell above‚Äô the minimum stake.\nJailing Penalties A Pocket Validator Node can be jailed for 1 of 2 reasons:\nFails to produce min_signed_per_window amount of blocks over a signed_blocks_window. When jailed because of this reason, a Pocket Validator Node is Slashed a slash_fraction_downtime% of their Stake. For Double Signing a Block. When jailed because of this reason, a Pocket Validator Node is slashed a slash_fraction_double_sign% of their Stake. When a Pocket Validator Node becomes Jailed, it remains in the Staked list of Pocket Validator Nodes, however it becomes ineligible to become for Block Production or participating in Sessions. In order to become Unjailed again, and after waiting downtime_jail_duration nano-seconds, a Node Unjail transaction must be sent to the Pocket Network, and upon approval, the Pocket Validator Node will become Unjailed again.\nIf a Pocket Validator Node is left jailed for max_jailed_blocks blocks, it will be Force Unstaked.\nDouble Sign Penalties 0.0001% percentage of the validator‚Äôs stake that will be slashed upon reporting of double vote Evidence type from Tendermint, where a double vote on a block is/can be a submission for two differing states, transactions, apphashes, etc. and result in a forked network.\nRelay Challenges In order to participate in the network economic incentive mechanism, the Validator must first Claim and then Prove the completed work.\nBurning for Bad Fraud Proofs If a Service Node submits a fraudulent Relay batch, 100% of their stake will be slashed.\nEconomic Incentives For providing infrastructure access to applications, Validators are rewarded proportional to the work they provide. Pocket Core attempts to send a Claim and subsequent Proof transaction automatically after the proof_waiting_period elapses. If both transactions are successful, Tokens are minted to the address of the Validator.\nRead more about Pocket monetary policy.\n","description":"An overview of Pocket Network node economics.","tags":null,"title":"ü§ñ Node Economics","uri":"/docs-hugo/learn/economics/nodes/"},{"content":"The Pocket Network is comprised of 3 components: Applications, Nodes and the Network Layer.\nAn Application submits Relays, or API requests meant to be routed to any public database node. Nodes service these Relays, by submitting them to the public databases they are meant for, and sending the response (if any) back to the Application. The Network Layer is comprised of all the rules, protocols and finality storage that serve as the backbone of the interactions between Applications and Nodes, including (but not limited to), configuration, record tracking, governance and economic policy.\nThe mechanism the Network uses to regulate the interactions between Applications and Nodes are Sessions. Sessions are a data structure that are generated following the established Session Generation Algorithm, which uses data from the finality storage layer of the network to pseudo-randomly group one Application with a set of Nodes which will provide service to it for a limited timeframe.\nTo dive deeper, start by learning more about Sessions.\n","description":"Protocol Introduction","tags":null,"title":"‚õì Protocol","uri":"/docs-hugo/learn/protocol/"},{"content":"Pocket‚Äôs staking and inflation mechanisms enable a more efficient resource allocation structure by limiting the number of transactions (and thus block validation costs) to one-time staking transactions. All nodes are able to focus primarily on servicing and validating Relay requests by Applications, with minimal energy spent on block validation. By being eventually consistent and tying rewards directly to inflation, Service Nodes are in effect receiving micropayments for work validated by two parties without the need for constant on-chain fee payments.\nAllocation of Minted POKT For each Relay served and validated by the protocol, POKT is added to the next block reward according to the mint rate. The following is a breakdown of each participant‚Äôs share of the block reward given no parameter changes.\nParticipant Parameter Name Current Allocation Service Nodes N/A 85% Block Producer ProposerAllocation 5% DAO DAOAllocation 10% Info Current values of these parameters (and all others) can be found on the Protocol Parameters page.\nInfo The value for ProposerAllocation has recently changed. Please see PUP-19 for details.\nAs part of the Proof-of-Stake consensus, each Service Node has a weighted chance of being selected to be the block producer for any given block based on the total amount staked for that given node. The block producer receives a portion of the entire block reward, as does the Pocket DAO, which provides continuous and sustainable funding for supporting the continued adoption and utility of Pocket Network.\nMonetary Phases As the Pocket Network develops, we envision the POKT monetary policy evolving through three stages: Bootstrapping, Growth, and Maturity. The following sections will discuss each of these phases. Note that some of these ideas are forward-thinking and so are subject to change.\nBootstrapping Phase During the bootstrapping phase of the network, it is important to build a strong foundation for the service, securing as many individual entities running nodes as possible. We do this by creating an environment where it is simple and inexpensive for initial Applications to access the network, and significantly profitable for Service Nodes to provide infrastructure.\nApplication usage and traction dictate the initial rewards that the Service Node pool will receive. By decreasing the barrier to entry for Applications (freemium access, low cost), the demand for Relays should be high during the Bootstrapping Phase, providing the initial pool of Service Nodes with ample opportunities to earn the high rate of POKT awarded for Relays serviced in the bootstrapping phase of the network.\nAs inflation and revenue increase per Service Node, the potential for competition increases, as rational, profit-seeking agents discover the protocol. This creates the flywheel to spur the network effects of Service Nodes purchasing and using POKT to participate until an equilibrium is found.\nAs the Protocol Throttling Formula adjusts to market demands, Applications being able to purchase more Relays results in more revenue for Service Nodes, further increasing the incentive for existing Service Nodes to re-stake their earned POKT. Increased participation in Pocket Network from Applications and Service Nodes ultimately benefits all parties by providing new revenue opportunities for Service Nodes and improving the service and resilience of the network for Applications. Due to Pocket Network being a permissionless Proof-of-Stake protocol and Service Nodes having an extremely low marginal cost of operation, the barriers to entry are significantly lower compared to Proof-of-Work mining based protocols. Pocket‚Äôs economic primitives incentivize a diverse set of entities and individuals such as data centers, existing infrastructure providers and hobbyists to participate as node operators within the network.\nGrowth Phase The growth phase is the period from launch which will see the greatest increase in the overall ParticipationRate of the protocol. When Applications stake during the growth phase, they earn more MaxRelays as the network grows (assuming they un-stake and re-stake), and don‚Äôt pay for anything else until the network has matured and the Application Burn is activated.\nOne result of this is inflation. It is a priority of the DAO to manage inflation in a manner that encourages sustainable growth of the Pocket ecosystem, protects rewards against a potential decrease in relays, and sensibly updates rewards as Pocket Network grows.\nIf both sides of the marketplace (Applications and Service Nodes) grow, there will be continuous demand for Relays resulting in Service Nodes spinning up new Pocket nodes to increase the number of Relays they can service.\nEarly Applications will receive more infrastructure throughput as the network grows providing an incentive to early adopters of the network. When both the percentage of POKT staked and Service Node margins begin reaching their equilibrium, the protocol will have entered its maturity phase.\nSee the section below on inflation for more details.\nMaturity Phase While the Growth Phase is inflationary, designed to incentivize active participation and supply-side staking for the security of the network, the Maturity Phase is designed to ensure the long-term sustainability of Pocket. The Maturity Phase is defined as the point in which Pocket Network has crossed equilibrium and the growth in inflation begins outpacing growth in the total staked supply of POKT.\nThis shift to long-term sustainability revolves around burning POKT to ensure the POKT supply is stable doesn‚Äôt lose its value as a form of consideration to Service Nodes. In this phase, Pocket becomes similar to traditional Software as a Service pricing models, where Applications must ‚Äútop up‚Äù their stakes periodically to avoid going below their needed Relay limit.\nThis should result in a decline in the ParticipationRate and Service Node margins due to an imbalance from more supply than demand for POKT.\nIn addition, to ensure the continued sustainability of POKT, to retain reasonable margins for Service Nodes, and to eliminate unnecessary overinflation of POKT, the Pocket DAO may activate an Application Burn Rate (ABR) at the Maturity Phase. This means that any POKT minting is balanced out by Application stake being burned at the same rate.\nOnce activated, the ABR results in a shift from Applications paying through dilution, to Application POKT being burned on a block by block basis to balance the minting of POKT as inflation awards to Service Nodes.\nThe effect of this is a logarithmic decay until the minimum App stake of 1 POKT is reached. Unless an Application increases the number of POKT they have staked, their holdings will fall under their desired amount causing applications to ‚Äútop up‚Äù their stakes turning the network into a self-sustaining SaaS-like infrastructure protocol.\nThe rate of Application burn is determined by using indicators such as the decay in the growth of Application and Service Node stake over time.\nPOKT Inflation Overview As the number of Nodes grows in the Pocket ecosystem, if we assume a constant per-relay payout, it follows that the total amount of POKT generated by the nodes will increase. While POKT was designed to be permanently inflationary, the high rate of inflation which this situation causes has strong repercussions for the network itself.\nThere are plenty of benefits to inflation, such as attractive rewards for new and existing participants, near term buying pressure from new node runners, and the ability to bootstrap new chains more easily. And excitement in the marketplace driven by node rewards can lead to increased adoption.\nHowever, there are many drawbacks to excessive inflation, such as sell pressure which may reduce activity on the network, network underutilization and unnecessary hardware costs, and a general perception of long-term unsustainability.\nWith this in mind, the DAO has voted on implementing and ongoing adjustment to the value of the rewards per relay (in parameter form, known as RelaysToTokensMultiplier).\nInfo For more information and to read the actual DAO proposals on inflation management, please see the following:\nPUP-11: WAGMI Inflation PUP-12: Inflation Stop-Gap Proposal: Double Trouble PUP-13: Initial WAGMI Parameters Inflation management The DAO‚Äôs currently approved inflation management framework is called the Weighted Annual Gross Max Inflation rate (WAGMI).\nA WAGMI target of 100% was implemented on Feb 28, 2022, which corresponds to a per-node reward of 0.008461 POKT/relay. It was previously set to 0.01 POKT/relay.\nWAGMI targets will be stepped down to 50% over the following five months as follows:\nDate WAGMI Target Inflation Rate Feb 28, 2022 100% Mar 26, 2022 90% Apr 25, 2022 80% May 25, 2022 70% Jun 24, 2022 60% Jul 24, 2022 50% The per-node reward (also known by its parameter value RelaysToTokensMultiplier) is calculated using:\nThe 30-day trailing average of daily relays at the time of each adjustment The total supply at the time of the proposal passing (‚ÄúTotal Supply Baseline‚Äù): $$ \\text{Mint rate} = \\frac{\\text{Total Supply Baseline} \\times \\text{Inflation rate}}{\\text{30-day trailing average of daily relays} \\times \\text{365 days}} $$The timestamp of the proposal was Feb 24, 2022, 6:37 GMT (block height: 51909), and the Total Supply Baseline was 945,014,989 POKT.\nAlso note that the DAO is empowered to recalculate the mint rate more frequently than the above monthly schedule in times of sharp increases or decreases in the amount of relays. In this case, a weekly recalculation may occur.\nRecent recalculations:\nDate Target inflation rate Approx. 30-day trailing avg. of daily relays Mint rate RelaysToTokensMultiplier [Initial] N/A N/A 0.010000 10000 Feb 24, 2022 100% 306,000,000 0.008461 8461 Mar 25, 2022 90% 311,000,000 0.007498 7498 Apr 1, 2022 90% 403,000,000 0.005776 5776 Apr 8, 2022 90% 481,000,000 0.004847 4847 Apr 25, 2022 80% 693,000,000 0.002988 2988 May 31, 2022 70% 860,000,000 0.002109 2109 Jun 30, 2022 60% 879,000,000 0.001768 1768 ","description":"An overview of the monetary policy of POKT, including monetary phases and inflation.","tags":null,"title":"üè¶ Monetary Policy","uri":"/docs-hugo/learn/economics/monetary-policy/"},{"content":"In this section, you‚Äôll get information on running a Pocket node.\nThese details are mostly for ‚Äúintermediate‚Äù node runners, who are familiar with running full nodes and have the knowledge required to avoid getting lost. If you would like a more beginner‚Äôs tutorial, visit Zero To Node. You may also want to explore node-hosting services.\nWant to understand the economics of running a node before you dive in? Read about Node Economics.\nRead our guide to decide whether you want your nodes to be operated with custodial staking or non-custodial staking.\nFor a no-frills guide to commands, you should head over to the Pocket Core docs.\n","description":"","tags":null,"title":"Run Nodes","uri":"/docs-hugo/node/"},{"content":"What is POKT? POKT is the native utility token that powers the economics of the protocol. Pocket Network requires both developers and nodes to stake POKT to participate in the network. Nodes earn POKT for fulfilling API requests for apps on a per request basis.\nHow much does it cost to send a relay? This is determined by the BaseRelaysPerPOKT parameter.\nHow much can I earn by running a node? Pocket is quite a unique blockchain network, because there are two ways for nodes to earn POKT:\nServicing: processing requests to/from blockchains on behalf of apps Validating: confirming blocks, which contain proofs of the above relays done Each time a block is validated, POKT is minted according to the RelaysToTokensMultiplier parameter which means, for every relay processed by a node, this amount of POKT is minted.\nThis mint is then divided according to the following percentages:\n1 -(ProposerAllocation+DAOAllocation) to all the nodes who did #1, proportional to the number of relays they did ProposerAllocation to the node who validated the block (#2) DAOAllocation to the DAO So what does this mean in practice?\nCheck out these charts to view the profitability of nodes over the lifetime of the network.\nWhat is the minimum staking amount for a node? The minimum staking amount for nodes is determined by the StakeMinimum parameter.\nHowever, if a node stake falls below this minimum stake the entire stake will be burned by the protocol. Therefore, as a best practice, we recommend staking an extra 7% to 10% buffer of POKT above the minimum stake per node. This is to account for any unforeseen slashing events due to node misconfiguration, bad behavior, natural disaster, or potential accidents.\nWhat determines my odds of being selected to validate a block? The following formula:\nround down (node stake / avg node stake) = # of tickets in the hat for block producer\nIs there an advantage to staking all of my POKT on one node? There is no advantage.\nAll nodes with the minimum stake have an equal chance of being selected to serve an app during a session. Therefore, to maximize the work you are being selected for, you should split your stake across as many nodes as possible, accounting for the minimum stake plus a buffer as described in What is the minimum staking amount for a node?\nSimilarly, tickets for block production are weighted according to POKT staked in comparison to the average, based on the formula above, however it makes no difference to you whether this POKT is all staked on one node or across multiple.\nWhy is the number of staked nodes growing faster than the number of staked apps? While it‚Äôs true that the supply (nodes) of Pocket‚Äôs two-sided market should respond to demand (apps), the important metric is the number of relays, not the number of staked apps.\nNodes are paid proportionally to the relays they process, so if the number of staked apps remains constant while the relays the submit increases, the node supply will grow in response to growing revenue opportunities.\nMany apps use the Pocket Portal to connect to the network, which stakes and integrates with PocketJS on their behalf. The Dashboard can divide the throughput it has staked for across multiple URLs, which means we don‚Äôt need to stake a new account for every new app that uses the Dashboard.\nHow do I buy POKT? Visit this forum post.\nWhat is the supply of POKT? Genesis \u0026 Circulating Supply The initial supply of POKT is 650M, which is divided according to the following genesis distribution:\nThe vast majority of these tokens are non-transferable and subject to use restrictions by the holders, starting from mainnet launch. __\nPrivate Sale 1/2: one-year lockup and use restriction from the date of purchase. Those whose year had already expired pre-mainnet also agreed to an additional lockup according to the following schedule: 50% of tokens unlocked after 6 months, 100% of tokens unlocked after 12 months. Founder Vesting: the founders agreed to restart a 3 year vesting schedule upon mainnet launch, with 10% of their allocations immediately vesting upon mainnet launch and subject to a 1-year lockup and use restriction. __ Pocket Network, Inc. (PNI): Token Sale Pool: fully unlocked at launch and available for direct sale to users of the network. __ Employee/Contractor Pool: already-vested tokens subject to a 1-year lockup and use restriction, with varying vesting agreements per contractor on average of 3-4 years. PNI Reserves: subject to 4 years of vesting and non-transferable for five unbonding periods (105 days total) following mainnet launch. __ Foundation/DAO: Foundation Reserves: subject to 4 years of vesting and non-transferable for five unbonding periods (105 days total) following mainnet launch. __ DAO Funds: fully unlocked at launch and distributed according to DAO grants. All other genesis addresses (e.g. incentivized testnet participants): non-transferable for five unbonding periods (105 days total) following mainnet launch. This all results in the following circulating supply schedule:\nFully Diluted Supply While the initial total supply of POKT is 650M, Pocket Network uses minting to compensate nodes for performing work on the network. For this reason, POKT is permanently inflationary proportional to usage of the network, i.e. proportional to the number of relays being processed by nodes, but the total supply will be capped through a burning mechanism put in place by the DAO (more on this below).\nThe Growth Phase of the network is characterized by relatively high rewards and an increase in the POKT supply designed to subsidize the bootstrapping of the network from a node and application perspective.\nOnce the growth rate of relays begins to decrease because Pocket Network has saturated the broader decentralized infrastructure market, Pocket Network will enter the Maturity Phase. It‚Äôs at this point that the DAO can choose to institute the Application Burn Rate (ABR) which burns developers‚Äô stake at a rate that offsets future inflation - capping the total supply of POKT. The ABR caps the total amount of POKT and ushers in network equilibrium where mint and burn rate is equal. This is reflected in our model by a flattening in the growth in POKT. In all three scenarios, ABR is instituted at the same time but could happen earlier or later as the DAO sees fit.\nYou can read more about these topics in the section on Monetary Policy.\n","description":"Token economics, app/node staking, node profitability, dilution.","tags":null,"title":"üí∞ Pricing \u0026 Economics FAQ","uri":"/docs-hugo/learn/economics/faq/"},{"content":"","description":"","tags":null,"title":"Integrate","uri":"/docs-hugo/integrate/"},{"content":"TL;DR Pocket Network requires both developers and nodes to stake its native utility token, POKT, to participate in the network. Nodes earn rewards for fulfilling API requests for developers on a per request basis. POKT is permanently inflationary, but total supply will be capped through a burning mechanism put in place by the DAO, who controls the monetary policy. The final total supply of POKT will be dictated by the DAO.\nOverview Pocket Network uses a native cryptocurrency (POKT) to create a permissionless, two-sided market between node providers who run full nodes and developers that want to query data from a blockchain for their application/service. POKT is purchased and staked by both developers and node providers to participate in the network. Due to the unique incentives on each side of the market, staking differs between the parties.\nDevelopers, requiring reliable infrastructure and relay amounts for their applications, stake POKT a single time for a guaranteed amount of relays per session for the life of the stake. The amount of POKT required to be staked is directly proportional to the number of relays required. The number of relays allowed per session can be adjusted for price fluctuations of the POKT token through governance mechanisms.\nInfo The current price per relay is called BaseRelaysPerPOKT, and you can find the current value on the Protocol Parameters page.\nWhile paying upfront for infrastructure appears to be burdensome at first glance, it has strong advantages and stickiness that help grow network adoption. The use of a token eliminates recurring payments to legacy infrastructure providers, vastly reducing the cost of infrastructure over the lifecycle of an application - bringing your cost-basis closer to zero the longer the service is used. Further, the upfront purchase of POKT can be viewed as a recoverable expense because the stake can be sold to another user if the service is no longer required helping to recover any costs associated with the network‚Äôs use. Instead of recurring payments, developers‚Äô stakes are diluted over time through the inflation of the supply of POKT.\nNode Providers also stake POKT but do so on a per-node basis. In exchange for servicing relays for applications, nodes are compensated in POKT. Unlike most traditional block rewards, Pocket Network‚Äôs is dynamic; POKT rewards are directly proportional to the number of relays and transaction fees in a given block. A node receives a certain amount of POKT per relay fulfilled and proved, minus certain percentages for both the block producer and the DAO.\nInfo The current block producer percentage is called ProposerAllocation, and you can find the current value on the Protocol Parameters page.\nFurthermore, the DAO allocation of block rewards is called DAOAllocation, and that also can be found on the Protocol Parameters page.\nAll nodes in the network have an opportunity to produce a block, but their chances are proportional to their stake.\nBecause of the way that nodes are incentivized, the Pocket Network economic model is inflationary during the Growth Phase, where the monetary policy is intentionally designed to encourage adoption. At network maturity, the Maturity Phase, a burn rate will initiate for application stakes that will offset the creation of newly minted POKT, stabilizing the total supply of POKT. This economic model encourages early network participation and reduces coordination costs.\nAt launch, the optimal economic strategy for node operators is to replicate as many nodes as possible with the amount of POKT held. By spreading their stake across multiple nodes, node operators maximize their chances of being chosen in as many sessions as possible, providing them with the most opportunity to serve relays within the network. These incentives promote further decentralization, redundancy, and increase the number of nodes available for each blockchain network supported by Pocket Network.\nMaintaining a balance between both sides of the market will be critical to the long-term success of the network. To maintain and secure the future of the protocol, Pocket Network will be run by the Pocket DAO. To accomplish its mission, the DAO receives a certain percentage of block rewards to reinvest in the network. In addition to protocol upgrades, the DAO will dictate the economic policy, making every effort to create sustainable economics that caters to both sides of the market through built-in governance mechanisms. These governance mechanisms allow the DAO to maintain an equilibrium between the two sides of the market and ensure accessibility to new participants.\n","description":"An overview of the economics of Pocket Network","tags":null,"title":"ü™ô Economics","uri":"/docs-hugo/learn/economics/"},{"content":"Pocket Network launched on mainnet on July 28th 2020, with the singular goal of providing a utilitarian economy between Web3 applications and the full nodes that provide access to the data they need. Since launching, Pocket Network has demonstrated that a decentralized alternative to full node infrastructure is not only possible, but with the right architecture could provide a service that is unmatched. Further, the lessons we have learned maintaining the network have highlighted a path towards a truly scalable future for Pocket Network‚Äôs Web3 infrastructure. These are the possibilities that v1 seeks to achieve.\nWhen we started working on Pocket Network, we were a scrappy startup with months of runway. For our vision to survive, we had to build our concept as lean as possible. This is where Tendermint Core came in, a general-purpose framework for building applications that require their own application specific blockchain. This provided us with the minimum viable networking and BFT consensus stack we needed to build a kickstart our vision. But, as we have grown, we have continued to push the limits of Tendermint‚Äôs general-purpose capabilities. We have made so many changes over the years that Pocket Network is now unrecognizable compared to the typical Tendermint ABCI application. These changes have allowed us to scale Pocket Network to the largest Tendermint network out there, exceeding 27,000 nodes while Tendermint was built to handle at most 10,000.\nWe have come to realize that, to reach our true vision of unstoppable Web3 infrastructure network with millions of nodes serving quadrillions of relays, we need to bid farewell to Tendermint and build our own stack from the ground up using all of the lessons we have learned after 1.5 years of mainnet optimized for Pocket‚Äôs use case.\nv1 will contain 4 specialized modules that are optimized for Pocket Network‚Äôs core utility:\nUtility Consensus Peer-to-Peer Persistence v1 will also be the catalyst for an enhanced engineering process that is more inclusive of the community, with robust laboratory infrastructure for responsive experimentation, QA, visibility, tooling and tighter development feedback loops. This is an R\u0026D project with at least 1 year of work anticipated before the launch of v1.0 mainnet. We are revealing our vision to the community at this stage to empower everyone to get involved in our new development cycle:\nYou can follow along the R\u0026D cycle in GitHub. You can post your research ideas in the Pocket Forum. You can chat about anything v1 in Discord. ","description":"","tags":null,"title":"üëÄ Future (v1)","uri":"/docs-hugo/learn/future/"},{"content":"","description":"","tags":null,"title":"Community","uri":"/docs-hugo/community/"},{"content":"Pocket Network has always been designed to do one thing and do it well: provide a utilitarian economy that coordinates unstoppable Web3 access. In the context of the v1.0 Utility Module, this means we are laser-focused on optimizing the existing utility of the network, not expanding the scope of our utility.\nThis means optimizing how effectively we coordinate Web3 access, which can be broken down into two categories:\nRelay Quality: RPC node (Servicer) incentives should be as tightly-coupled as possible to relay quality, so that Pocket Network‚Äôs service not only matches centralized providers‚Äô but provides a level of quality, unique to Pocket‚Äôs architecture, that can‚Äôt be matched Relay Scalability: our protocol should be as scalable as possible, to maximize the number of relays that the network can process and optimize the efficiency (and thus cost) of the service Relay Quality Quality Enforcement v0 ‚Äì Client-side + Layer-2 Enforcement When we first designed Pocket Network, we assumed that service quality would be ensured through a Darwinian competitive dynamic. Indeed, there is a weak incentive to perform better on latency/volume to maximize relays processed, though this is insufficient to ensure quality on all metrics.\nTo address this, we included a simple client-side validation mechanism known as a challenge transaction, which enables Apps to protest the rewards that Servicers earned for low-quality work. However, 1.5 years into mainnet, challenge transactions have never been utilized, likely since the Portal does quality checks before it sends relays. We‚Äôve learned that client-side validation is an insufficient model to rely upon because it 1) results in Apps experiencing quality failures before they are corrected, 2) forces Apps to choose between validating relays and maximizing relay speed.\nThe Portal is our gateway drug. It is a web application that stakes Pocket Apps on behalf of developers, and allows us to provide the simple RPC endpoints that apps have come to expect from centralized providers. Currently, the Portal administers the majority of the protocol‚Äôs App stakes to ensure service quality while we bootstrap new chains. In 2021 we developed various layer-2 cherry-picking methods through the Portal to ensure that Apps receive service from the highest-quality Servicers available in each Session. These methods have laid the groundwork for the on-chain quality enforcement that we will be introducing in v1.0.\nv1.0 ‚Äì On-chain Enforcement The Portal is a service that builds on the Pocket Network, managing app stakes on behalf of Apps and providing quality of service checks. Maintaining this core service has shown us how critical quality assurance is to our core utility, so we decided to take these lessons and move them on-chain.\nWe have considered a world in which other people deploy their own Portals and compete to provide the best layer-2 quality enforcement. However, we realized that Portals would fall to the tragedy of the commons; they are simultaneously expensive to run and inherently altruistic. The only way this could be resolved off-chain is through economies of scale and extractive pricing. Sound familiar? If we went down this route, we would no longer be solving the incentive problem we saw in the full node ecosystem, we‚Äôd simply be pushing it further up the stack.\nTo solve this in a manner compatible with our trustless vision, the protocol needs to directly incentivize actors on-chain to enforce quality according to a standardized ruleset. Enter the Fishermen. These are a new set of actors who can disguise themselves as Apps and sample the quality provided by Servicers.\nFishermen measure the quality of relays across three key metrics according to a standardized sampling protocol:\nAvailability: Since Fishermen, Apps, and Servicers are all time-synced according to the session protocol, time-based sampling can be used to assess the availability of the Servicer. If no signed response can be collected from a Servicer, a null sample is recorded for the sample time slot. The more null samples the worse the Servicer‚Äôs availability score. Latency: The time it takes for the Fisherman to receive a signed response from the Servicer (i.e. Round Trip Time) is another metric that is tracked. Due to normal variances in latency to be expected from the varying geographical distance between Apps and Servicers, these metrics are used to disincentivize high-average latency rather than explicitly rewarding the highest-performing Servicers. Consistency: In addition to time-based sampling, it is mandatory for Fishermen to sample all Servicers in a session at once. The Fishermen can then compare responses and measure data consistency without needing their own comparative Web3 datasource. Fishermen compile these samples into test scores for each Servicer, which are averaged out across Fishermen over time, ultimately determining the proportion of block rewards that Servicers receive. Fishermen are not incentivized to influence test scores because they are paid based on the quantity and completeness of their reports, not the content of the metrics being reported.\nQuality Incentives v0 ‚Äì Quantity-based 89% of v0 block rewards are distributed to Servicers proportional to the volume of relays they served. This means Pocket Network‚Äôs incentives currently optimize for the quantity of work done, not the quality of work done.\nv1.0 ‚Äì Quality-based v1.0 prioritizes quality over quantity; block rewards are distributed to Servicers according to the aggregate test scores submitted by Fishermen.\nThe total salary for Servicers is still proportional to the volume of relays performed on aggregate. However, this is divided between Servicers in proportion to their test scores. Each Servicer above the MinimumReportCardThreshold is eligible for an equal salary from the total pool for their RelayChain or GeoZone but has their allocation burned by the difference between their ReportCard% and 100%.\nThese incentives enable Pocket Network to probabilistically guarantee a Service Level Agreement for applications.\nRelay Scalability Proving Relays v0 ‚Äì Pessimistic Proofs of Relays v0 is pessimistic about proving work done; guilty until proven innocent. To validate the volume of relays they completed, Servicers must generate plasma merkle trees, store relay evidence, and create merkle proofs, which will then be validated by Validators, as part of a multi-step Zero Knowledge Range Proof.\nThis works very well as secure cryptography but it scales linearly because plasma merkle trees have O(n log(n)) space complexity, where n is the number of relays, and the branch must be included in every proof transaction. In practice, this means proofs get more expensive to process in proportion to relays, which contributes to higher CPU loads and longer block processing times.\nIf Pocket Network is to grow to serve quadrillions of relays, the relay proof lifecycle must be fundamentally restructured.\nv1.0 ‚Äì Optimistic Proofs of Samples Work payments in v1.0 are optimistic, more like a salary compared to v0‚Äôs unit-based payments.\nThe total salary pool is still proportional to the volume of relays performed on aggregate. To determine the size of this total available reward, Fishermen probabilistically estimate volume using probabilistic hash collisions rather than counting up (and proving) every relay.\nThe Fishermen samples themselves are also optimistic. Fishermen only need to submit test scores on a pseudorandom schedule and only need to verify a single pseudorandomly selected non-null sample. Since the Fishermen (and Servicers) can‚Äôt predict which test scores will be submitted or which samples will need to be verified, the monitoring system remains a secure deterrent of bad behavior while avoiding the cost that would come from validating every test score.\nBy switching to an optimistic model, we reduce both the frequency and size of proofs, which should allow relays to scale exponentially rather than linearly.\nCreating \u0026 Validating Proofs v0 ‚Äì Unified Actors In v0, until recently, Validators and Servicers were bundled together. This meant that the scalability of Servicers was bound by Validators, for two reasons:\nValidators are subject to the scalability of the BFT consensus algorithm, which is arguably the least scalable component of our protocol by design Servicers are burdened with performing expensive Validator tasks, even though these aren‚Äôt necessary to perform Servicer tasks We have already begun moving away from this model with the separation of Validators and Servicers in v0.7. Limiting Validators to the top 1,000 by stake has allowed our Servicer count to grow to almost 25,000 without impacting the health of our blockchain. v1.0 will take this a step further.\nv1.0 ‚Äì Task-based Specialization of Actors We have already agreed that Servicers shouldn‚Äôt need to validate proofs. Taking this a step further, why should they need to prove their own work? In v0, Servicers must constantly store claims and proofs if they want to get paid, which presents a computational burden that distracts them from optimizing on their most important tasks: relaying RPC requests.\nIn v1.0, we are more explicitly separating actors according to their tasks. We are introducing the Fisherman, whose sole responsibility is to prove the quality of work done. This narrows the scope of Servicer work to just performing relays, which should make it cheaper to perform relays and thus dramatically enhance the efficiency of the network‚Äôs core task.\nv1.0 Utility Roadmap 1. Proto-Fish We will begin live-testing the Fisherman sampling methods in v0, using the Portal as a low-risk supervised environment.\n2. Castaway When v1.0 launches, we will begin with a single DAO-governed Fisherman. This will enable us to adopt all the benefits of v1.0, with the Fisherman actor being the only trusted actor in the network.\n3. Fishermen We will then transition to a multi-Fisherman model, wherein DAO governance can appoint and remove Fishermen, burning them to penalize bad behavior.\n4. Cast-Net Finally, Fishermen will become truly trustless actors as the monitoring/enforcement of their behavior is moved entirely on-chain.\nMore Details Read more details about the v1.0 Utility module spec.\n","description":"","tags":null,"title":"ü™ô Utility","uri":"/docs-hugo/learn/future/utility/"},{"content":"Pocket Network is an open-source multi-stakeholder community. Therefore, the best way to contact us is to join our community in Discourse and Discord.\nDiscord You can join our Discord. We recommend doing this if you want to keep your finger on the pulse.\nBe sure to start in the üëãwelcome channel, where you can choose the topics you‚Äôre interested in.\nDiscourse (Pocket Forum) Ask for help Report a bug Request a feature Submit a proposal Ask for feedback Find or advertise node hosting services Find or advertise work in the Pocket ecosystem Social Media You can find us on the following sites:\nTwitter YouTube Twitch Pocket Blog ","description":"","tags":null,"title":"üí¨ More Information","uri":"/docs-hugo/more-info/"},{"content":"Off-Chain USDRelayTargetRange Current Value: $0.00036‚Äì0.00059 per relay\nThe range of USD/relay prices the DAO doesn‚Äôt want the real price of a relay to exceed, accounting for the USD price of POKT.\nReturnOnInvestmentTarget Current Value: 10 months\nHow long the DAO wants it to take for the USD/relay price to be achieved, since the cost basis of a relay decreases over the lifetime of an app stake.\nApplication Module ApplicationStakeMinimum Current Value: 1000000\nThe minimum stake required of an app, denominated in StakeDenom. This does not have the same economic security requirements as a node‚Äôs minimum stake because an app‚Äôs access to the network (relay throughput) is already proportional to the stake.\nAppUnstakingTime Current Value: 1814400000000000\nThe time, in nanoseconds, that an app must wait after initiating an unstake before they can use the POKT for anything else.\nBaseRelaysPerPOKT Current Value: 7014\nThe number of relays that an app is entitled to for every POKT it stakes, multiplied by 100.\nThe formula for calculating the MaxRelays an app is entitled to is\n$$ MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput) $$Where BaseThroughput is\n$$ (BaseRelaysPerPOKT/100) * StakedPOKT $$The /100 is included in the formula to enable the DAO to make more granular adjustments, since the protocol is unable to use decimal numbers.\nIn practice, this means if the BaseRelaysPerPOKT parameter is 100 then the baseline throughput that apps are entitled to is 1 relay per POKT.\nMaxApplications Current Value: 2295\nThe number of staked applications that the protocol allows.\nMaximumChains Current Value: 15\nAn app can only be configured for up to this many chains on one stake.\nParticipationRateOn Current Value: false\nThe protocol may adjust an application‚Äôs MaxRelays at the time of staking according to network-wide stake rates, where the ParticipationRate acts as a proxy for utilization of the network on a block by block basis.\n$$ MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput) $$This parameter was set to false at genesis and will only be activated if the DAO decides.\nStabilityAdjustment Current Value: 0\nThe DAO may manually adjust an application‚Äôs MaxRelays at the time of staking to correct for short-term fluctuations in the price of POKT, which may not be reflected in ParticipationRate.\n$$ MaxRelays = StabilityAdjustment + (ParticipationRate * BaseThroughput) $$When this parameter is set to 0, no adjustment is being made.\nPoS (Node) Module BlocksPerSession Current Value: 4\nThe number of blocks allowed before a Session tumbles.\nDAOAllocation Current Value: 10\nThe DAO treasury earns this proportion of the total POKT block reward. Value is a percentage. See also ProposerAllocation for another beneficiary of the block reward.\nDAOOwner Current Value: a83172b67b5ffbfcb8acb95acc0fd0466a9d4bc4\nThe account which has the permission to submit governance transactions on behalf of the DAO.\nDowntimeJailDuration Current Value: 3600000000000\nThe amount of time (in nanoseconds) before a node can unjail and resume service.\nMaxEvidenceAge Current Value: 120000000000\nThe amount of time (in nanoseconds) a node has to submit their Tendermint evidence in memory before it expires.\nMaximumChains Current Value: 15\nA node can only be configured for up to this many chains on one stake.\nMaxJailedBlocks Current Value: 37960\nThe amount of time (in blocks) a node has to unjail before being force unstaked and slashed.\nWarning: Reaching MaxJailedBlocks will result in a node‚Äôs entire stake being slashed.\nMaxValidators Current Value: 1,000\nThe number of staked nodes that are eligible to be selected for producing blocks. Any staked nodes outside of the top MaxValidators staked validators will still be eligible to service relays.\nMinSignedPerWindow Current Value: 0.6\nThe minimum proportion of the SignedBlocksWindow that a node must sign to stay out of jail.\nInfo If SignedBlocksWindow is 10 and MinSignedPerWindow is 0.6, this means a node can miss up to 4 blocks out of every 10 blocks before it is jailed.\nProposerAllocation Current Value: 5\nBlock proposers earn this proportion of the total POKT block reward. Value is a percentage. See also DAOAllocation for another beneficiary of the block reward.\nRelaysToTokensMultiplier Current Value: 1768\nThe amount of POKT, denominated in StakeDenom, that is minted as block rewards per relay.\nNote that this value will change over time. Please see the section on POKT inflation for more information.\nSignedBlocksWindow Current Value: 10\nThe number of consecutive blocks within which the MinSignedPerWindow proportion of blocks must be signed by a node to stay out of jail.\nInfo If SignedBlocksWindow is 10 and MinSignedPerWindow is 0.6, this means a node can miss up to 4 blocks out of every 10 blocks before it is jailed.\nSlashFractionDoubleSign Current Value: 0.000001\nThe % of a node‚Äôs stake that is burned for double signing, where 1 is 100%.\nSlashFractionDowntime Current Value: 0.000001\nThe % of a node‚Äôs stake that is burned for downtime, where 1 is 100%.\nStakeDenom Current Value: upokt\nPOKT amounts are defined by the protocol. Read more about POKT denominations.\nStakeMinimum Current Value: 15000000000\nThe minimum stake required of a node, denominated in StakeDenom, for the economic security of the protocol.\nUnstakingTime Current Value: 1814000000000000\nThe time, in nanoseconds, that a node must wait after initiating an unstake before they can use the POKT for anything else.\nPocket Core Module ClaimExpiration Current Value: 120\nThe amount of time (in blocks) a node has to submit a proof for an already existing claim.\nClaimSubmissionWindow Current Value: 3\nThe window of time (in Sessions) a node can submit a claimTx for RelayEvidence collected in the most recently ended session, before the claimTx expires. In addition, it is also the minimum amount of time a node must wait to submit a proof for an existing claim.\nMinimumNumberOfProofs Current Value: 10\nThe minimum number of relays a node must have for a claim and proof to be payable.\nReplayAttackBurnMultiplier Current Value: 3\nThe multiplier slash factor for submitting a replay attack. The base slash is directly proportional to the amount of relays claimed.\nSessionNodeCount Current Value: 24\nThe number of nodes an app will be matched with in a session.\nSupportedBlockchains List of currently supported blockchains\nOnly blockchains with sybil-resistant demand from apps are whitelisted to generate revenue for nodes.\nAuth Module FeeMultiplier Current Value: 1\nThe multiplier factor for each transaction type. The base transaction fee is universally set at 10,000 uPOKT.\nMaxMemoCharacters Current Value: 75\nThe character limit of transaction memos.\nTxSigLimit Current Value: 8\nThe maximum number of signatures that a multi-sig account can have.\n","description":"","tags":null,"title":"üéö Protocol Parameters","uri":"/docs-hugo/learn/protocol-parameters/"},{"content":"The consensus module coordinates Validators to come to agreement that the transactions in a block are legitimate before the block is added to the blockchain. Currently, v0 inherits its consensus implementation from Tendermint. While Tendermint provides a great framework for building applications that can handle arbitrary computation, it is not optimized for Pocket Network‚Äôs singular focus of coordinating unstoppable Web3 access.\nSome of the major changes to the consensus module for v1.0 include:\nReplacing Tendermint BFT with HotStuff BFT Migrating from a Round Robin leader selection process to a blind, pseudorandom leader selection process Allowing the Block Proposer to validate transactions against the mempool before including them in a block For the network as a whole, these changes will enable more consistent block times. For those running nodes, these changes will allow for:\nLess bandwidth and compute resources spent communicating with other nodes during consensus Less storage usage, as invalid transactions will no longer be included in blocks Block creation rewards proportional to the amount staked. A Primer on Consensus The two most popular types of consensus algorithms are Nakamoto and Byzantine Fault Tolerance (BFT).\nNakamoto In Nakamoto consensus, the network chooses to follow the longest chain. This is the consensus mechanism that Bitcoin, Ethereum 1.0, and most Proof of Work chains currently use. As long as someone can submit a valid proof of work, they can add a block to the chain.\nIn case the block added was fraudulent, whether maliciously or accidentally, whoever submits the next block can choose to do so from whichever point they wish, creating a fork in the chain. If the network adopts this new chain enough that it becomes the longest, this results in what‚Äôs known as a chain reorganization. This is why applications that make transactions on these chains often wait for a number of ‚Äúconfirmations‚Äù, because the chain can potentially reorganize at any point. This process of waiting for transactions accomplishes something called probabilistic finality.\nProbabilistic finality works well for coming to consensus on events that have already occurred, however, since Pocket Network uses the current state of the blockchain to determine which Servicers to match Apps with, Nakamoto consensus is incompatible with the Utility module.\nBFT In BFT consensus algorithms, Validators must come to agreement before adding any blocks to the chain. The name comes from the ‚ÄúByzantine generals problem‚Äù, a thought experiment that dealt with how a group of military generals, who could not communicate directly with each other, could come to a decision about whether to attack or flee. This issue doesn‚Äôt just deal with the case of the general being a malicious actor, but also the case of the messenger being the one who changed the vote, or simply not being able to deliver the message. In a computer system, Byzantine faults are used to describe errors that can occur from an actor either being compromised or faulty. These types of consensus mechanisms, while useful for blockchain consensus, were originally developed to enable aircraft to rely upon their sensor data to make software decisions as long as a certain threshold of their sensors were always in agreement.\nWhere Nakamoto consensus can probabilistically resolve fraudulent blocks through its longest-chain selection process, BFT instead opts to require consensus on the next block before moving forward with the chain. Since Pocket Network‚Äôs Utility module requires a single state from which to maintain coordination between Servicers and Apps, BFT is the obvious choice.\nThe Consensus Algorithm v0 ‚Äì Exponential Communication Complexity The Tendermint BFT consensus algorithm has served Pocket Network well but will hold us back because communication complexity scales exponentially in proportion to the number of nodes, for two reasons:\nNetwork-Wide Random Gossip: Every node in the network must pass on what every other node has told them, including Servicers. The more nodes there are, the more node-node messages must be sent and received, resulting in an exponential volume of messages. If Pocket Network is to continue scaling to hundreds of thousands of nodes, this gossip process must be fundamentally restructured, otherwise the communication bandwidth required will become insurmountable. Pessimistic Responsiveness: When voting on a block, the network must wait for all nodes to vote (or wait a minimum period of time) before moving on, even if enough votes have already been cast to reach consensus. This can make the network more vulnerable to chain halts if not enough nodes can keep up with the voting process. v1.0 ‚Äì Linear Communication Complexity We will be solving these issues in v1.0 by switching to our own implementation of the HotStuff BFT consensus algorithm: HotPocket. The biggest advantage of this algorithm is that it uses validator-specific structured gossip and optimistic responsiveness to significantly reduce communication complexity.\nValidator-Specific Structured Gossip: HotPocket selects a small group of nodes to be responsible for listening for messages and then broadcasting gossip to everyone. This means instead of sharing messages with everyone, nodes only have to share with the selected listeners, which allows communication bandwidth to scale exponentially with the number of Validators. Optimistic Progress: HotPocket introduces a new phase in the consensus process. During this phase, Validators must acknowledge that they have seen the block proposal going up for a vote. When it comes to the voting phase, any Validators who did not acknowledge the proposal can be dismissed and the chain can move on with majority consensus as long as the present Validators approve it. Along with this, we have a custom pacemaker module that ensures consistent block times, which are critical for the time-synced mechanisms in the Utility module. The Leader Selection Process v0 ‚Äì Round Robin Tendermint uses Round Robin to determine the next leader who will propose the next block. This makes the blockchain vulnerable to DDoS attacks since we know exactly who the next leaders are going to be and when. We have already modified Tendermint‚Äôs Round Robin to use a pseudorandom selection algorithm where the hash of the previous block determines the next leader.\nv1.0 ‚Äì VRF + CDFs In v1.0, we are leveraging Verifiable Random Functions (VRFs) for more secure pseudo-random leader selection that is unpredictable before the block production, yet deterministic and computationally cheap to verify afterwards. Whereas v0 uses the previous block hash to generate leaders, v1.0 uses the VRF secret keys of other Validators which are impossible for the proposer to know. VRFs are combined with Cumulative Distribution Functions (CDFs) to enable selection to be weighted based on the amount staked by the Validator. Because it is probabilistic, it is possible for the VRF to generate 0 proposers, in which case we fallback to the v0 Round Robin process.\nHandling Invalid Transactions v0 ‚Äì Block Proposer Can‚Äôt Validate Since Tendermint was designed to support arbitrary computation, there were risks for them allowing the block proposer to validate transactions against the mempool. Since the state of the mempool changes as transactions come in, there is currently no way for the block proposer to know if transactions are valid before proposing them in a block. For chained and dependent transactions that rely on ordering, this can cause problems of unexpected failed transactions. Since transactions aren‚Äôt validated until they‚Äôre included in the block, this leads to the chain being bloated with meaningless failed transactions, which makes indexing and processing transactions harder, ultimately wasting resources.\nv1 ‚Äì Block Proposer Can Validate Since Pocket Network isn‚Äôt a blockchain built for arbitrary computation, and instead built for a specific purpose, we can make guarantees about what computations would occur if the block proposer tried to validate transactions against the mempool. This means that it is possible for the block proposer to filter invalid transactions before proposing a block. This will greatly help to reduce the storage requirements of the chain as well as making it easier to index and process transactions.\nMore Details Read more details about the v1.0 Consensus module spec.\n","description":"","tags":null,"title":"ü§ù Consensus","uri":"/docs-hugo/learn/future/consensus/"},{"content":"The Peer-to-Peer (P2P) module is responsible for handling how all the nodes in the network communicate with each other when new transactions need to be added to a block and when the new block gets added to the chain. Currently, v0 pairs peers together randomly. This random pairing was chosen to ensure redundancy across the network, however, as Pocket Network continues to grow, the redundancy and complexity of random pairing require more bandwidth as more nodes come online ‚Äì with a good chunk of that bandwidth being used to retrieve copies of information the nodes have already seen.\nIn v1.0, the P2P module will transition from random communication to structured communication. For those running nodes, this transition means a significant reduction in bandwidth usage. For the network as a whole, this means more efficient and scalable communication, while maintaining the required redundancy. This will move the P2P system from having low visibility and a large amount of message duplication to having high visibility and less message duplication.\nA Primer on P2P There are three primary components of the P2P system that all contribute to the reliability and speed of the network. Those components include Event Dissemination which handles how nodes will be paired to communicate with each other, Membership and Churn which handles knowing when nodes either come online or go offline, and the Transport Layer which controls the mechanism used to actually send and receive messages between peers. Some of these problems are problems that can apply to networking across the board, while others are unique to P2P networks specifically. The requirements of building an effective P2P communication network include:\nEfficiency and Scalability ‚Äì making sure that more peers can connect without a major impact to the network performance Fault and Partition Tolerance ‚Äì despite any number of breakdowns that happen between nodes, the network can continue to operate Managing Membership and Churn ‚Äì effectively communicating when a peer both joins and leaves the network. While there are a large variety of existing P2P implementations out in the wild, each implementation has made design decisions based on specific needs that don‚Äôt translate to the needs of Pocket. In choosing the design for the v1.0 implementation, it was important to understand the fundamental needs of Pocket Network. There are three types of communications that are fundamental to how Pocket Network operates.\nServicers need to be able to inform the network of transactions made Validators need to be able to communicate with each other during consensus and with the whole network when a new block is created Archival nodes need to be informed of new blocks, as well as handling and making requests for new blocks. From these three main types of communication, we can specifically say that the P2P module of Pocket Networks needs to be able to:\nCommunicate blocks and transactions across the network Restrict communications to only the groups who are needed for those communications. Event Dissemination v0 ‚Äì Random Gossip Currently, Pocket Network communicates information about blocks and transactions through random gossip. When a node learns of a new piece of information, they pass that information along randomly to other nodes in the network. This random process ensures that the data can make its way through the network, regardless of failures between certain pairs of nodes. This process, while ensuring redundancy, does so in a way that requires nodes to spend bandwidth and resources receiving the same message multiple times.\nBuilding on this, because nodes randomly select other nodes to share this information with, nodes will share and receive information regardless of whether that is information they need. Gossip about the consensus process is only relevant to nodes who are acting as Validators. Gossiping with every Servicer and Archival node about the validation process not only takes away resources from those nodes but it slows down the gossip phase of the consensus process.\nv1.0 ‚Äì Structured Gossip RainTree is a gossip protocol that leverages the efficiency that Binary Trees provide for lookups of sorted, randomly-distributed data. RainTree provides the mechanism to ensure delivery, offer redundancy against non-participation without needing retries or acknowledgements, and perform a cleanup to ensure 100% message propagation in all cases.\nThe process starts with a node that wishes to gossip a message to all other peers in the network. Once the node has a sorted list of all other peers in the network, it needs to:\nBuild a binary tree based off the sorted list, with the left branch being the peer at 33%, and the right branch being the peer at 66%, with a third branch that points back to itself Determine its own and max depth of the tree Gossip messages to all depths of the tree. The peers on the left and right branches then build their own subsections of the tree using the above, and the process continues. This third branch is there to add redundancy. When the node begins gossiping down the tree, it will, eventually, reach the point where it has to send itself the message. Once it has reached this point, the node is able to send it to not just the left and right as expected but also every other node in the originally sorted list.\nSince networks are vulnerable to nodes dropping out at any point, if one of the branches does not acknowledge that it received the message, the node that tried to communicate with them will then readjust and send the message to the children that would have received the message from the unresponsive parent.\nTo be 100% certain that all functional nodes received the message, the Double-Daisy-Chain (DDC) cleanup layer provides a reliability mechanism that‚Äôs used in other gossip algorithms, including epidemic communications. Once the message propagation has reached the next to last layer of the tree, the nodes in the final layer are sent a special ‚ÄúI Got You Want?‚Äù (IGYM) message that expects either a Yes/No answer. If the answer is a Yes, the node is forwarded along the full message and they continue said process. If the answer is No, or there is no answer, that node is skipped and the next node in the chain is selected for the same process.\nGossip Restrictions v0 ‚Äì Everyone Communicates Everything In the current system, all nodes communicate any information to all other nodes regardless of whether the information is relevant to that node. This means that Servicers must actively listen and share information about the consensus process, despite the fact that they are not participating. In networks that primarily consist of Validators, this doesn‚Äôt cause many issues, but since Pocket Network contains other specialized actors such as Servicers and Fishermen, scaling these actors should not impact the communication of processes irrelevant to their input. If we don‚Äôt scale actor communication independently, scaling Servicers and Fishermen will slow down consensus, resulting in longer block times.\nv1.0 ‚Äì Restricted to Relevant Parties The gossip protocol in the Consensus module is a specialized version of RainTree designed for that specific case. As Pocket Network already keeps a list of the current Validators, it‚Äôs possible to leverage RainTree for this process. This allows the consensus process to take advantage of the optimizations and redundancy of RainTree. Even more importantly, since the tree will be constructed from only the list of Validators, this means that gossip related to consensus can occur only between those that are involved in the process. This means that the consensus process isn‚Äôt held up by trying to communicate with the entire network and that other actors are now unburdened from gossip that isn‚Äôt relevant to them.\nMore Details Read more details about the v1.0 Peer To Peer module spec.\n","description":"","tags":null,"title":"üí¨ Peer to Peer","uri":"/docs-hugo/learn/future/peer-to-peer/"},{"content":"Application The base consumer of the decentralized infrastructure of Pocket Network.\nApplication‚Äôs stake POKT into the protocol in order to access the decentralized infrastructure.\nApplication Authentication Token (AAT) An Application Authentication Token (AAT) is needed for each client to authorize the use of an allocated ‚Äúthroughput.‚Äù\nApplication Authentication Tokens are similar in function to JSON Web Tokens (JWT) and provide security guarantees for the use of the service.\nAn AAT is generated after a client acquires \u0026 stakes POKT for an application.\nThere are two design patterns recommended for AAT usage:\nOptimizing for Safety: __ A simple backend server that distributes signed AAT‚Äôs using the clients Pocket Account. Though this pattern is of higher effort for the Application, it provides the highest security guarantee around their AAT Optimizing for Performance: Embed a token production system within the Application code. This guarantees the smoothest UX for the clients and easiest setup for the Application. However, reverse engineering a source code level token generator can be trivial if obfuscation methods are not applied. The upside to this approach is not having the need to have an additional component in the Application that generates the AAT dynamically while keeping the Application private key secure. Block Hash The SHA3-256 hash of a Block.\nJail A Pocket Validator Node can be Jailed for 1 of 2 reasons:\nFails to produce min_signed_per_window amount of blocks over a signed_blocks_window. When jailed because of this reason, a Pocket Validator Node is Slashed a slash_fraction_downtime% of their Stake. For Double Signing a Block. When jailed because of this reason, a Pocket Validator Node is Slashed a slash_fraction_double_sign% of their Stake. When a Pocket Validator Node becomes Jailed, it remains in the Staked list of Pocket Validator Nodes, however it becomes ineligible to be selected for Block Production or participating in Sessions. In order to become Unjailed again, and after waiting downtime_jail_duration nano-seconds, a Node Unjail transaction must be sent to the Pocket Network, and upon approval, the Pocket Validator Node will become Unjailed again.\nIf a Pocket Validator Node is left jailed for max_jailed_blocks blocks, it will be Force Unstaked.\nPOKT The native cryptocurrency to Pocket Network.\nRelay A Relay is a blockchain API request and response transmitted through the Pocket Network.\nA Relay Request is broken down into 3 sections:\nRequest Payload Metadata Proof (of Relay) A Relay Response is broken down into 2 sections:\nResponse Payload Servicer Signature Requests are signed by the Client of the Application and responses are signed by the servicing Validator.\nThis 1 for 1 signature scheme enables the protocol to validate all parties that participate in the servicing cycle.\nRelay Chain A single database instance, typically a blockchain, provided by a Validator that makes up the Pocket Network decentralized infrastructure.\nRelay Evidence Provable evidence of a Relay completed, backed by digital signatures from an Application client.\nServiceURI The endpoint where Validators host the Pocket RPC.\nA static URI (or IP) that you have assigned to your node, which applications can use to send relays to your node, NOT your blockchain node URL.\nSession The relationship between an Application and the Validator(s) that service it at any point in time.\nEvery Application will only have one single Session per Relay Chain it is staked for. Meaning following an Application stake event, there will always be a corresponding Session for the Application for each Relay Chain until it unstakes.\nSession Block Some number of blocks, marking session beginning/ends.\nValidator Validators are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each validator‚Äôs private key.\nValidators stake POKT into the protocol to participate in Servicing and Consensus.\n","description":"","tags":null,"title":"Glossary","uri":"/docs-hugo/learn/glossary/"},{"content":"Pocket Portal The Pocket Portal lets you create an endpoint for the chain you want in just a few clicks and provides you with the features you‚Äôve come to expect in centralized API services, such as usage/uptime metrics and notifications/alerts.\nSetup Guide Go to the Pocket Portal, sign up and verify your email.\nOnce you‚Äôve done so, log in and you‚Äôll be greeted by the Network Overview section.\nInfo In this section, you‚Äôll see all the important parts of the network: how many relays are being served daily, the overall success rate of the network, and the number of apps, nodes, and POKT staked. A summary of chains being served by the network is also available.\nHead over to the ‚ÄúMy Apps‚Äù section and create your app.\nInfo In this section, you‚Äôll be able to select one of the available chains that are currently available. More will be made available depending on demand.\nOnce you‚Äôve hit ‚ÄúLaunch Application‚Äù, all is done and you can start using your endpoint! You should be greeted by the main application screen, which will show all the metrics, which as soon as you start submitting requests, should start appearing.\nThe view you see is the main view for your application. Here, you‚Äôll see key details:\nOn the top left, you‚Äôll see and will be able to copy your endpoint URL. On the right, first you‚Äôll see key information about your Pocket application: The app status, which indicates if the app is currently staked or unstaked. The app must be staked in order to be eligible for service. The amount of POKT staked, which will be enough to add up to the free tier. The max amount of relays you can send per day, which currently is 1M as per the free tier. On the bottom right, you‚Äôll see important identifying information: The Gateway ID, used by the Dashboard to fetch your app‚Äôs information. It‚Äôs part of your endpoint URL as well. The App‚Äôs public key, which will let you inspect your application on-chain. The Secret Key, which is a security feature you can use to make your Pocket Dashboard endpoint more secure. On the left side, you‚Äôll see all the metrics available for your app. Setting Up Notifications Turning on notifications is a great way to stay up to date with your app. We respect our users‚Äô privacy, and therefore we only send important emails, such as usage notifications. To activate them:\nClick on the ‚ÄúNotifications‚Äù button on your app‚Äôs dashboard, and you‚Äôll see the notifications screen. Turn on any notifications you‚Äôre interested in receiving, and then click ‚ÄúSave changes‚Äù when you‚Äôre done. Securing your Application For securing your endpoint, you can go to the ‚ÄúApp Security‚Äù section of the Portal. This section of the app contains all the security settings you‚Äôll have at your disposal for security. We provide whitelisting for both origins and user agents and also let you enable and disable secret key usage.\nWhitelisting User Agents Mainly useful for mobile apps, whitelisting user agents lets you limit requests to only the ones you‚Äôve put in the whitelist. An example user agent would be com.example.bobapp. This would let Bob‚Äôs mobile app use the endpoint as his user agent would be whitelisted. If Alice, with user agent com.example.aliceapp tried to use the endpoint, she wouldn‚Äôt be able to, as her requests would be blocked before they‚Äôre sent to the network.\nWhitelisting Origins To whitelist origins, just write the URL of the domain you want to allow. All requests from other domains will be blocked. This is a very effective way to only use your app in production, staging, or test environments and to stop malicious users from stealing your endpoint and using it in their project.\nFor origins, we support wildcard domains as well as normal domains. An example URL would be https://portal.pokt.network.\nUsing your Secret Key Every application has a secret key associated with it, which can be enabled so that every request has to send it using HTTP Basic Authentication to be accepted. An example cURL request with the secret key enabled would be:\nmacOS/Linux Windows curl --user :YOUR-SECRET-KEY \\\\ ... https://\u003cNETWORK\u003e.gateway.pokt.network/v1/YOUR-GATEWAY-ID curl --user :YOUR-SECRET-KEY ^ ... https://\u003cNETWORK\u003e.gateway.pokt.network/v1/YOUR-GATEWAY-ID This is a truncated example of a call that does not actually send a request. See below for a more detailed example.\nTesting your Endpoint Once you‚Äôve set up your endpoint as per your liking, you can test it however you‚Äôd like. In the main application view of the dashboard, you‚Äôll be able to see and copy your endpoint to the clipboard. The way endpoints are used in terms of content sent in the body will depend on the chain.\nFor EVM-based chains (Ethereum, BSC, and others), which see the majority of traffic in Pocket Network, you can refer to the official JSON-RPC specification. Below we have a few examples of requests for Pocket compatible chains.\nEthereum, BSC and EVM-based chains macOS/Linux Windows curl -X POST \\\\ -H \"Content-Type: application/json\" \\\\ --data '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"eth_blockNumber\", \"params\": []}' \\\\ \"https://\u003cNETWORK\u003e.gateway.pokt.network/v1/\u003cYOUR-GATEWAY-ID\u003e\" curl -X POST ^ -H \"Content-Type: application/json\" ^ --data \"{\\\"jsonrpc\\\": \\\"2.0\\\", \\\"id\\\": 1, \\\"method\\\": \\\"eth_blockNumber\\\", \\\"params\\\": []}\" ^ \"https://\u003cNETWORK\u003e.gateway.pokt.network/v1/\u003cYOUR-GATEWAY-ID\u003e\" How Endpoints are Constructed All endpoints have a similar structure, as they all have:\nThe network prefix; see the RelayChainIDs here The main URL (gateway.pokt.network/v1/) If it‚Äôs a load-balanced endpoint, it will also have the LB prefix (/lb/) The Gateway ID. Switching Chains If you ever need to switch chains for your endpoint, you have the ability to do so once a week. Click on the ‚ÄúSwitch chains‚Äù button to do so.\nEarn Trophies, Join the DAO You can earn a vote in the DAO and help shape the future of Pocket Network, including deciding which ecosystem tooling our treasury supports and how we configure important on-chain parameters such as the cost of a relay.\nOnce you‚Äôve sent 1k relays through the Portal, join our Discord and report this in the üèÜtrophies channel.\nThis is your first trophy on the path to earning a vote in the DAO on the App Developer path:\n‚ô¶ Use EthersJS You can use Pocket as your node provider with this complete and compact Ethereum library\nFirst, you need to get an endpoint from the Pocket Portal.\nThen you need to get the Gateway ID\nand insert it like so\nethers.providers.PocketProvider('homestead', process.env.GatewayID) üì≤ Endpoint FAQ I just want an endpoint, where can I get one? The Pocket Portal stakes on your behalf and generates the endpoint you need.\nHow does the Pocket Portal work? The Pocket Portal is tasked with connecting to the Pocket Network through PocketJS on your behalf‚Äîessentially doing the integration work for you. The only thing that changes here is the layer of abstraction between you, the developer, and the nodes. You are still ultimately being served by a decentralized network of thousands of nodes.\nIs there a more ‚Äúdecentralized‚Äù solution? Yes! You can integrate with PocketJS directly, which would be the most censorship-resistant way to connect to our network of full nodes. All of the functionality we built into the Pocket Portal, including ‚Äúload-balanced‚Äù endpoints, are 100% reproducible using only PocketJS. In fact, we anticipate competing dashboards to emerge. Get started with PocketJS at the link below:\nWhat does it mean for an endpoint to be ‚Äúload-balanced‚Äù? This means that there‚Äôs more than one Application behind your endpoint, where an Application is defined as the account staking into the network for the purpose of submitting relay requests. For each request you need to submit, one of these app stakes gets chosen pseudorandomly and is used to make the request to the network. We have several algorithms in place to cherry-pick the best-performing app stakes for each session, based on the nodes they‚Äôve been matched with, and ensure the best QoS.\nWhat can I do if I exceed my allotted requests? If you ever exceed the amount of daily (or per-session) amount of requests, contact the sales team or jump into our Discord to let us know; we‚Äôll work something out!\n","description":"","tags":null,"title":"Get An Endpoint","uri":"/docs-hugo/use/get-endpoint/"},{"content":"The Persistence module is responsible for ensuring that the data continues to persist over time, across deployments, and throughout software changes. Currently, V0 handles data persistence through Tendermint. Tendermint uses a similar mechanism to most other blockchains, storing the different state data that needs to persist in Merkle trees. The roots of these trees are included in the block, and then for each block, each of the trees is stored as a file.\nThis design simplifies the computational overhead a new client would need to get up to sync with the current block, however, it does so at the cost of storage. While this decision was made to ensure that the barrier to entry of acting as a validator of a network is low, it fails to consider how critical full nodes, nodes that maintain copies of the data to be accessed and queried by applications, are as infrastructure for production applications.\nAs the core mission of Pocket Network is to provide access to high quality, decentralized infrastructure, the role of the full node needs to be considered as a priority and not an afterthought. Some of the changes that are being made to the persistence layer in V1 include:\nMoving from a Key Value Filesystem DB to an SQL based Tamper Proof Hybrid Mutable DB Decoupling the persistence layer to allow for a Client Server Architecture between pocket-core and persistence. For those interacting with the network, these changes will mean significantly faster access to any state data that would have relied on a query to access.\nFor those running nodes, these changes will not only make the current experience better, but it will also open the door to more control and options when it comes to deployment configurations. These changes will:\nDrastically reduce the storage needs (80%) for storing the blockchain data. Drastically reduce the amount of resources needed to query state data. (10+ seconds -\u003e milliseconds) Enable better data portability, making it easier to quickly spawn up additional databases as needed Enable individual scalability, making it easier to kill off and replace a failed process. Allow for an additional layer of fault tolerance, since the choice for database engine can be replaced. Enable for multi-process concurrency, making it possible to horizontally scale pocket-core without worrying about the storage cost for doing so. Underlying Database V0 ‚Äì Key Value Filesystem Currently, at each block, the data that represents the current state is stored as a tree in a file. While this provides some benefits, such as being able to simply move a directory to move the data, and easily being able to store arbitrary data, these benefits come with significant downsides. For one, regardless if anything has changed in the state between blocks, an entire copy of that tree is written again. There is no process for currently managing data deduplication.\nThe other issues come from using a filesystem as a production database. Out of the box, Linux cannot handle the amount of simultaneously open files needed to manage a system in this manner, hence needing to make sure the ulimit is properly specified before running a node. Using the filesystem also means that data access is almost entirely reliant on the I/O speeds of the system. When you add in how querying through old state would mean opening multiple files, this means that queries dependent on I/O are the slowest part of the system.\nV1 ‚Äì Tamper Proof Hybrid Mutable DB SQL provides a mature, optimized, battle-hardened solution to the data storage problem. One issue with SQL is it requires a well-defined data schema, and so it‚Äôs well suited for arbitrary data storage. Since Pocket Network does not handle arbitrary computation, and instead serves a defined application specific purpose, SQL provides the opportunity for significant storage and speed optimizations.\nA Persistence Client Middleware will communicate between pocket-core and a generic database engine, to define what needs to happen to define, persist, update, and query the datasets it stores. This mechanism will define the following to ensure consistency:\nVersioning of the state dataset Byte-perfect consistency of the data encoding Schema definition mechanism Deterministic write mechanism Idempotent Dataset Updates To ensure that the data is tamper proof, the Patricia Merkle Tree can be stored in the state dataset for each block, and can be used to verify the validity of each block. As the operations on the data are ACID and idempotent, any change to the underlying data is detectable.\nSystem Deployment V0 ‚Äì Data Duplication The current system requires that each pocket-core process needs access to an independent copy of the data to run. If a node needs to increase resources, whether that be to handle more traffic, or more data access, the only option is to start another process that needs a full copy of the data to run.\nV1 ‚Äì Client-Server Architecture Breaking the core and persistence layers into a client server architecture gives node runners the ability to scale and manage the respective processes more efficiently. While keeping the persistence layer on the same machine as the pocket-core process would allow for the least latency, it also restricts the node runner from configuring their infrastructure in a way that best serves the needed demand.\nSome of the examples that node runners now have access to include:\nSpawning up multiple pocket-core processes on behalf of the same identity to scale to handle more demand. Connecting multiple pocket-core processes that represent at least two nodes in close physical proximity to the same database. Connecting multiple pocket-core process that represent multiple nodes to a database cluster to allow a collection of nodes to efficiently scale-up storage needs Since nodes know the maximum amount of relays that the applications it‚Äôs serving can request, this gives node runners the ability to save costs by allocating resources only as needed.\nMore Details Read more details about the v1.0 Persistence module spec.\n","description":"","tags":null,"title":"üóÑ Persistence","uri":"/docs-hugo/learn/future/persistence/"},{"content":"{% embed url=‚Äúhttps://youtu.be/9SNGe2tfmmw\" %}\nWe have created a public Avalanche RPC endpoint with up to 1M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for Avalanche C-Chain, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Avalanche Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://avax-mainnet.gateway.pokt.network/v1/lb/605238bf6b986eea7cf36d5e/ext/bc/C/rpc Put the hexadecimal 0xa86a or decimal 43114 in the ChainID field Write AVAX as the Symbol Add https://cchain.explorer.avax.network/ as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the Avalanche (AVAX) network in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Avalanche \\(AVAX\\)","uri":"/docs-hugo/use/public-rpc/avax/"},{"content":"How to Customize Your Endpoint (e.g. MetaMask) To change your endpoint in MetaMask, do the following, filling in the fields from the table below:\nClick on the Networks drop-down menu, then press Add Network Under the Network Name field, write \u003cNetwork Name\u003e Pocket Portal Within the New RPC URL field, copy and paste \u003cRPC URL\u003e (Optional) Put \u003cChainID\u003e in the ChainID field (Optional) Write \u003cSymbol\u003e as the Symbol (Optional) Add \u003cExplorer URL\u003e as the Block Explorer URL Don‚Äôt forget to save Info If you receive this error message from MetaMask Invalid number. Enter a decimal or '0x'-prefixed hexadecimal number then leave the optional fields blank.\n{% embed url=‚Äúhttps://www.youtube.com/watch?v=8ruuz3u2V2E\u0026list=PLYpSL-5AOmwq4x0Kxw_p4v93mEYLmT5HJ\" %}\nEndpoints Network Name RPC URL ChainID Symbol Explorer URL Ethereum Mainnet https://eth-rpc.gateway.pokt.network 1 ETH https://etherscan.io Avalanche https://avax-mainnet.gateway.pokt.network/v1/lb/605238bf6b986eea7cf36d5e/ext/bc/C/rpc 43114 AVAX https://cchain.explorer.avax.network/ xDAI https://xdai-rpc.gateway.pokt.network 100 xDAI https://blockscout.com/poa/xdai Fuse https://fuse-rpc.gateway.pokt.network/ 122 Fuse https://explorer.fuse.io Polygon https://poly-rpc.gateway.pokt.network/ 137 Matic https://polygonscan.com BSC https://bsc-mainnet.gateway.pokt.network/v1/lb/6136201a7bad1500343e248d 56 BNB https://bscscan.com Harmony Mainnet Shard 0 https://harmony-0-rpc.gateway.pokt.network 1666600000 ONE https://explorer.harmony.one EVMos https://evmos-testnet.gateway.pokt.network/v1/lb/61aabb3495d548003aebfd1c 9000 PHOTON https://evm.evmos.org/ Boba Mainnet https://boba-mainnet.gateway.pokt.network/v1/lb/6258298b981a0200395864f0 288 ETH https://blockexplorer.boba.network/ IoTex Mainnet https://iotex-mainnet.gateway.pokt.network/v1/lb/6176f902e19001003499f492 4689 IOTX https://iotexscan.io/ DFK Chain https://avax-dfk.gateway.pokt.network/v1/lb/6244818c00b9f0003ad1b619/ext/bc/q2aTwKuyzgs8pynF7UXBZCU7DejbZbZ6EUyHr3JQzYgwNPUPi/rpc 53935 JEWEL https://explorer.dfkchain.com/ Fantom https://fantom-mainnet.gateway.pokt.network/v1/lb/6261a8a154c745003bcdb0f8 250 FTM https://ftmscan.com Swimmer Network Mainnet https://avax-cra-rpc.gateway.pokt.network/ 73772 TUS https://explorer.swimmer.network/ ","description":"We've staked POKT on your behalf to provide public RPC endpoints for all of the networks that Pocket supports. Use these endpoints in any DApp that lets you use a custom endpoint.","tags":null,"title":"Public RPC Endpoints","uri":"/docs-hugo/use/public-rpc/"},{"content":"{% embed url=‚Äúhttps://youtu.be/fLTvtBtOEg0\" %}\nWe have created a public BSC RPC endpoint with up to 1M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for BSC, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write BSC Pocket Portal Within the New RPC URL field, copy and paste this endpoint URLhttps://bsc-mainnet.gateway.pokt.network/v1/lb/6136201a7bad1500343e248d Put the decimal 56 in the ChainID field Write BNB as the Symbol Add https://bscscan.com as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add Binance Smart Chain (BSC) in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Binance Smart Chain \\(BSC\\)","uri":"/docs-hugo/use/public-rpc/bsc/"},{"content":"","description":"","tags":null,"title":"Pocket-Powered dApps","uri":"/docs-hugo/use/dapps/"},{"content":"For those who play Defi Kingdoms, you can use Pocket‚Äôs public RPC endpoint for DFK Chain and take advantage of Pocket‚Äôs decentralized infrastructure.\nThere are two ways to connect your MetaMask wallet to DFK Chain. Choose whichever method you prefer.\nChainlist Navigate to https://chainlist.org/?search=dfk, or go to Chainlist and search for ‚Äúdfk‚Äù. Click the down arrow under DFK Chain to expand the entry. In the row with the URL that begins with htps://avax-dfk.gateway.pokt.network... click Connect Wallet. (You may need to scroll the window to the right to see this.) Click Add to MetaMask. When prompted, click Approve in the MetaMask interface. Add manually In MetaMask, click the Networks drop-down menu, then select Custom RPC. Under the Network Name field, type DFK Chain POKT. Within the New RPC URL field, copy and paste this endpoint URL: https://avax-dfk.gateway.pokt.network/v1/lb/6244818c00b9f0003ad1b619//ext/bc/q2aTwKuyzgs8pynF7UXBZCU7DejbZbZ6EUyHr3JQzYgwNPUPi/rpc In the ChainID field, type 53935. For the Symbol, type JEWEL. For the Block Explorer URL, add https://subnets.avax.network/defi-kingdoms/dfk-chain/explorer. Save changes. ","description":"How to add the DeFi Kingdoms blockchain subnet in MetaMask with a Pocket RPC endpoint","tags":null,"title":"Connecting MetaMask to DFK Chain","uri":"/docs-hugo/use/public-rpc/dfk-chain/"},{"content":"This section will detail the hardware and software needed to run a Pocket node.\nHardware Hardware Requirements: 4 CPU‚Äôs (or vCPU‚Äôs) | 16 GB RAM | 200GB Disk\nInfo These are just the hardware requirements for your Pocket node. You‚Äôll also need to run the full nodes of other blockchains, which may have their own hardware requirements that surpass Pocket‚Äôs.\nSoftware There are three ways to install the software you need to run Pocket Network.\nSource Install your dependencies\ngo go environment GOPATH \u0026 GOBIN git Create source code directory\nmkdir -p $GOPATH/src/github.com/pokt-network \u0026\u0026 cd $GOPATH/src/github.com/pokt-network Download the source code\ngit clone https://github.com/pokt-network/pocket-core.git \u0026\u0026 cd pocket-core Checkout the latest release\nCommand Example git checkout tags/\u003crelease tag\u003e git checkout tags/RC-0.8.2 Make sure you have $GOPATH setup\nCommand Response (Mac) echo $GOPATH /Users/\u003cyour username\u003e/go Build your binary and put it in the $GOPATH/bin directory\nCommand Example go build -o \u003c$GOPATH/bin directory\u003e \u003csource code directory\u003e/... go build -o $GOPATH/bin/pocket $GOPATH/src/github.com/pokt-network/pocket-core/app/cmd/pocket_core/main.go Test your installation\nCommand Response pocket version \u003e RC-0.8.2 Info Check your version number against the latest release here.\nHomebrew Install your dependencies\ngo go environment GOPATH \u0026 GOBIN Homebrew (Mac or Linux) Install using Homebrew\nbrew tap pokt-network/pocket-core \u0026\u0026 brew install pokt-network/pocket-core/pocket Test your installation\nCommand Response pocket version \u003e RC-0.8.2 Docker See pokt-network/pocket-core-deployments\nEnvironment Reverse Proxy: For SSL termination and request management Ports: Expose Pocket RPC (Default :8081) and P2P port (Default: 26656) SSL Cert: Required for Validator‚Äôs serviceURI Set your Open Files Limit ulimit -Sn 16384 Warning This Open Files Limit is set based on the standard config provided with Pocket Core in \u003cdatadir\u003e/config/config.json. If you modify your config, you will need to ensure that you modify your Open Files Limit too, according to the formula below.\nThe required ulimit can be calculated using this formula:\n({ulimit -Sn} \u003e= {MaxNumInboundPeers} + {MaxNumOutboundPeers} + {GRPCMaxOpenConnections} + {MaxOpenConnections} + {Desired Concurrent Pocket RPC connections} + {100 (Constant number of wal, db and other open files)}\nSecure your Server Make sure the server that hosts your node is protected by up-to-date anti-virus and anti-malware software. Protect your node with a firewall but make sure to maintain login access for yourself and keep the above ports open.\n","description":"","tags":null,"title":"Environment Setup","uri":"/docs-hugo/node/environment/"},{"content":"{% embed url=‚Äúhttps://youtu.be/8ruuz3u2V2E\" %}\nWe have created a public Ethereum RPC endpoint with up to 10M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for Ethereum mainnet, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Ethereum Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://eth-rpc.gateway.pokt.network Put the decimal 1 in the ChainID field Write ETH as the Symbol Add https://etherscan.io as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the Ethereum (ETH) network in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Ethereum \\(ETH\\)","uri":"/docs-hugo/use/public-rpc/ethereum/"},{"content":"Deploy Your Validator \u0026 Full Nodes Create an account An account is needed to participate at any level of the network.\nCommand Response pocket accounts create \u003e Enter Passphrase \u003e Account generated successfully: \u003e Address: \u003caddress\u003e Info Alternatively, you can create your account using the Wallet app, then use the encrypted import command to import the account into your node environment:\npocket accounts import-armored \u003c/path/to/ppk.json\u003e Backup the account Backup your private key to an encrypted and ASCII armored json file, to the specified --path , using the secure export command. After you hit enter, you will be prompted for the decrypt passphrase and an encryption passphrase for the exported account. You will also have the option to add a hint to help remember your passphrase.\nCommand Example pocket accounts export \u003caddress\u003e --path \u003cpath\u003e pocket accounts export 59f08710afbad0e20352340780fdbf4e47622a7c --path /$HOME/super-secret-dir Warning Do not use your node‚Äôs account as your personal account address. Since the node‚Äôs private key is stored in plaintext on the server, the key is as secure as your server is. Regularly sweep your node‚Äôs rewards and transfer them to a more secure account stored offline.\nFor more details on securely managing your POKT accounts, see here:\n{% content-ref url=\"../buy-store-and-stake-pokt/\" %} buy-store-and-stake-pokt {% endcontent-ref %}\nFund the account To stake a Validator in Pocket Network, the account must have a balance above the minimum stake:\n15,000 POKT or 15,000,000,000 uPOKT\nThe absolute minimum node stake (15,000 POKT) is not practical for real-world usage. 15,100 is a reasonable buffer against operational slashes which can occur on seemingly properly configured nodes as well as misconfigured and misbehaving ones.\nSend POKT with the following command:\npocket accounts send-tx \u003cfromAddr\u003e \u003ctoAddr\u003e \u003cuPOKT amount\u003e mainnet 10000 \"\" You won‚Äôt be able to send POKT using your CLI until you have a Validator set up. Until then, you can use the Wallet app.\nIf you‚Äôre using the testnet, you can fund your account using the Testnet Faucet.\nSet the account as Validator pocket accounts set-validator \u003caddress\u003e Info Check that it worked with pocket accounts get-validator\nSet Relay Chains A Relay Chain is the blockchain that Validators are running full nodes for in service of Applications. Apps access Relay Chains through the serviceURI, the endpoint where Validators publicly expose the Pocket API.\nCommand Response pocket util generate-chains \u003e Enter the chain of the network identifier: \u003cRelay Chain ID\u003e (Example: 0001) \u003e Enter the URL of the network identifier: \u003cSecure URL to Relay Chain\u003e Would you like to enter another network identifier? (y/n) n Info RelayChainIDs can be found here.\nSetup the Genesis Configuration File Genesis files can be found here:\nMainnet Genesis File Testnet Genesis File The appropriate genesis file should be placed at $HOME/.pocket/config/genesis.json\nMainnet Setup Testnet Setup mkdir -p \"$HOME\"/.pocket/config curl -o \"$HOME\"/.pocket/config/genesis.json https://raw.githubusercontent.com/pokt-network/pocket-network-genesis/master/mainnet/genesis.json mkdir -p \"$HOME\"/.pocket/config curl -o \"$HOME\"/.pocket/config/genesis.json https://raw.githubusercontent.com/pokt-network/pocket-network-genesis/master/testnet/genesis.json Test your node Test that your node is configured correctly by simulating a relay.\npocket start --simulateRelay Then send a curl request to your validator URL http://\u003cyour node\u003e:\u003cyour pocket rpc port\u003e/v1/client/sim to test if your node responds.\ncurl -X POST --data '{\"relay_network_id\":\"\u003crelay chain ID from chains.json\u003e\",\"payload\":{\"data\":\"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_getBalance\\\",\\\"params\\\":[\\\"0xe7a24E61b2ec77d3663ec785d1110688d2A32ecc\\\", \\\"latest\\\"],\\\"id\\\":1}\",\"method\":\"POST\",\"path\":\"\",\"headers\":{}}}' \u003cyour node URL\u003e:8081/v1/client/sim 200 OK ‚Äì your transaction has gone through\n400 Bad Request ‚Äì you either have incorrect/missing parameters in the request or bad formatting in the data field\nFinally, stop your node. If you don‚Äôt, you‚Äôll be leaving ‚ÄìsimulateRelay running, which means anyone will have unfiltered access to your node.\nDownload the Latest Snapshot Downloading from the latest snapshot will drastically shorten the time it takes to sync the blockchain. The easiest way is by downloading with wget and extracting the archive as it downloads.\nmkdir -p \"$HOME\"/.pocket/data wget -qO- https://snapshot.nodes.pokt.network/latest.tar.gz | tar -xz -C \"$HOME\"/.pocket/data Other options for downloading the latest snapshot can be found in the pocket-snapshotter repo.\nSync the blockchain Command Example pocket start --seeds=\u003cseeds\u003e --mainnet pocket start --seeds=\"64c91701ea98440bc3674fdb9a99311461cdfd6f@node1.mainnet.pokt.network:21656\" --mainnet See the section on seeds for more details.\nWarning Ensure the node is all the way synced before proceeding to the next step.\nStake the Validator Stake the account to participate in the Network as a Validator. Staking a Validator locks up POKT tokens that can be burned as a security mechanism for bad acting.\nCommand Example pocket nodes stake custodial \u003caddress\u003e \u003camount\u003e \u003crelay_chains\u003e \u003cserviceURI\u003e mainnet 10000 false pocket nodes stake custodial 3ee61299d5bbbd2974cddcc194d9b547c7629546 20000000000 0001,0002 https://pokt.rocks:443 mainnet 10000 true Info Read more about custodial versus non-custodial staking.\nYou should leave 1 POKT liquid (unstaked) to pay the transaction fees for your node‚Äôs claim and proof transactions.\nAll node runners must always maintain a liquid (unstaked) balance of at least 0.02 POKT in order to submit the claim and proof transactions (which each have a transaction fee of 0.01 POKT) that generate their rewards. If a node successfully submits both the claim and proof, they will earn enough POKT to submit the next claims and proofs, and so on. However, if a node falls below a liquid balance of 0.02 POKT, their revenue will be halted.\nClaim transactions have 3 sessions, the ClaimSubmissionWindow, to be successfully submitted after the conclusion of the session in which the work was done, otherwise they are lost. If a claim transaction fails, Pocket Core will auto-repeat the transaction once in each new session, until the claim is lost. This means your node will automatically take 3 attempts to submit the claim. There is a claim submission window because the global secret key that determines the required proof leaf is revealed once that window closes. Extending the claim submission window would delay the time at which the corresponding proof can be sent and rewards earned.\nIf you manage to successfully submit the claim transaction, you then have 120 blocks, the ClaimExpiration period, to submit the corresponding proof transaction, otherwise the pending claim expires. There is a claim expiration date because otherwise the claims would remain in the state and bloat the blockchain.\nWarning Bad Behavior Warning: Pre-staking\nPre-staking is the act of a node runner staking on a RelayChainID prior to spinning up the RelayChain node. This behavior has an extremely negative impact on the quality of service for new chains due to apps being matched in sessions with Pocket nodes that don‚Äôt actually have RelayChain nodes connected to them. If you do this, your node will be challenged and slashed. You should always deploy your RelayChain node and simulate relays before staking your Pocket node for the RelayChainID.\nIf your stake falls below 15,000 POKT your node will be force-unstake burned. We recommend having a buffer above the 15,000 minimum (e.g. 15,100-16,000) so that minor slashing doesn‚Äôt result in loss of the entire stake.\nüèÜ Achievement Unlocked\nIf you staked your node successfully, you just earned your first trophy. See here to find out how earning more trophies will ultimately earn you a vote in our DAO.\nUpgrade Your Node Release-specific Changes Each release may have specific modifications you need to make. This is just a general guideline for the steps you‚Äôll typically take to upgrade your node. Check the release notes for release-specific details.\n1. Shutdown Pocket Core Stop your Pocket Core instance running by submitting the shutdown command.\npocket stop Warning Once you shutdown Pocket Core, you will have 4 blocks (60 minutes) to complete the upgrade and start Pocket Core again before your node gets jailed for downtime.\n2. Backup Your Blockchain Data Backing up your blockchain data will ensure a faster resync when you restart your node.\nNavigate inside your $HOME/.pocket/ dir and save data/ (the entire directory):\ncp -r ~/.pocket/data ~/backup/data In the event of a corrupted database you can delete the bad data rm -r ~/.pocket/data and replace it with your backup cp -r ~/backup/data ~/.pocket/data.\nInfo If you don‚Äôt have a backup, a temporary backup datadir may be provided alongside a release.\n3. Ensure the Latest Golang Version Check your golang version. The release notes will specify which version it should be.\ngo version If you need to upgrade, use this guide.\nAlternatively, if you use g, you can just run\nsudo apt-get update g install \u003cversion number\u003e 4. Rebuild or Upgrade Your Binary Source Navigate into pocket-core directory\ncd ~/go/src/github.com/pokt-network/pocket-core Checkout the latest release\ngit pull git checkout tags/\u003crelease tag\u003e Rebuild the binary\ngo build -o $GOPATH/bin/pocket ./app/cmd/pocket_core/main.go Homebrew Pull the latest tap\nbrew upgrade pokt-network/pocket-core/pocket Docker Pull the latest container image\nOption 1 Option 2 docker pull poktnetwork/pocket-core:RC-0.8.2 docker pull poktnetwork/pocket:RC-0.8.2 5. Upgrade Your config.json Run the update-configs command, which creates a new config file (DATADIR/config/config.json) and backs up the old config file (DATADIR/config/config.json.bk).\npocket util update-configs You‚Äôll need to manually compare your backup file with the new file to copy over your personal config details.\n6. Start Pocket Start pocket running again.\npocket start Earn Trophies, Join the DAO You can earn a vote in the DAO and help shape the future of Pocket Network, including deciding which ecosystem tooling our treasury supports and how we configure important on-chain parameters such as node revenue.\nOnce you‚Äôve staked your node successfully, join our Discord and report this in the üèÜtrophies channel.\nThis is your first trophy on the path to earning a vote in the DAO. Learn more on the Node Runners page.\n","description":"","tags":null,"title":"Node Setup","uri":"/docs-hugo/node/setup/"},{"content":"New in version 0.8.0\nPocket has added the ability for node runners to set up their nodes to run with ‚Äúnon-custodial‚Äù staking. This means that the Pocket address that is associated with staking and running the node is not the recipient of the funds once the node is unstaked.\nThis feature is currently inactive, and will be set to be active at a later date.\nNode runners who staked their nodes prior to this activation date will have one opportunity to decide if they want their nodes to have custodial staking or non-custodial staking. After this point, if they wish to switch between the two options, they will need to unstake/restake their node.\nCustodial staking Custodial staking is the process of having the operator of the node be the recipient of the rewards of that node. This is true regardless of whether the node is a servicer or a validator.\nIn this scenario, only one Pocket account is needed to run a node. This account handles all aspects of node maintenance such as staking, editing the stake, unjailing, and unstaking.\nPrior to version 0.8.0, this was the only option that node runners had.\nNon-custodial staking Non-custodial staking is the process of having the operator of the node be a different account from the account that receives the rewards.\nIn this scenario, there are two Pocket accounts necessary to the staking of a node. One account, the operator account, performs the staking, and can perform any and all node maintenance. The other account, known as the ‚Äúoutput‚Äù account, is designated to receive the rewards that are unlocked when a node is unstaked. The output account can also initiate the staking.\nIn addition, this output account has much the same authority over the node as the operator account. The output account can also run node transactions (stake, unstake, unjail, etc.).\nBenefits of non-custodial staking An operator address must reside in a ‚Äúhot‚Äù wallet on the node. This could potentially represent a security risk when the server is operated by a third-party. As third-party node hosting is common, there has arisen a need to have the recipient wallet for rewards not be on the same server as the node.\nNon-custodial staking allows for this. All you need to specify is the wallet (‚Äúoutput‚Äù) address, which is denoted when staking the node. The wallet can reside off the server.\nAnother benefit to non-custodial staking is the ability to pool rewards into a single account. Since each node has to have a distinct operator account, this would previously have resulted in rewards being split across multiple wallets, which is inconvenient for a node runner with many nodes.\nCommands The command for staking a node was updated for version 0.8.0 and includes extra parameters. Note that before non-custodial staking becomes active, the custodial command is the only one that will be successful.\nCustodial staking:\npocket nodes stake custodial \u003cfromAddr\u003e \u003camount\u003e \u003crelayChainIDs\u003e \u003cserviceURI\u003e \u003cnetworkID\u003e \u003cfee\u003e \u003cisBefore8.0\u003e Non-custodial staking:\npocket nodes stake non-custodial \u003coperatorPublicKey\u003e \u003coutputAddress\u003e \u003camount\u003e \u003cRelayChainIDs\u003e \u003cserviceURI\u003e \u003cnetworkID\u003e \u003cfee\u003e \u003cisBefore8.0\u003e Some notes on these commands:\nThe parameter custodial or non-custodial sets this permanently on your node. You can‚Äôt change this later unless you unstake.\nThe flag \u003cisBefore8.0\u003e is boolean. It exists as a transitional variable to denote whether or not the non-custodial activation has occurred. Before activation, you need to set this to true. After activation, you will need to set this to false. Failure to set this correctly will result in the transaction being rejected, with a delay of upwards of one block time to see this rejection.\nBe aware that the non-custodial command takes the \u003coperatorPublicKey\u003e as the argument, not the operator address (\u003cfromAddr\u003e) like in the custodial command. The reason why the public key is used and not the address is for the situation where the owner of the output address is doing the staking, but does not also have ownership of the operator account. In this case, they may only have the public key for that account.\nThe non-custodial command adds \u003coutputAddress\u003e as the recipient of the staking rewards.\nFor more information on the full usage of these commands, please see the Pocket Core docs.\nImportant for existing nodes If you have a node that was staked prior to the activation of non-custodial staking, you have only one opportunity to switch to non-custodial staking.\nAny pocket node command successfully issued (for example, to adjust the stake) will ‚Äúlock‚Äù the node into custodial, unless a non-custodial command is issued with a valid output address. Following this, the only way to switch between custodial and non-custodial is to unstake/restake the node (and recall that there is a 21 day unstake period).\nImportant for all nodes Be very careful entering the output address. You cannot change the output address after it is set. If you accidentally mistype the output address, your funds and your stake will be sent to that address and will be lost forever.\nIf you wish to change your output address, you can first unstake the node, and the rewards will be sent to that address. Then you can restake the node with a new output address.\nMore information PIP-9 Consensus Rule Change Pocket Core docs Pocket Core releases ","description":"With non-custodial staking, node runners have additional options for managing nodes and rewards.","tags":null,"title":"Custodial and non-custodial staking","uri":"/docs-hugo/node/staking/"},{"content":"We have minted a public Evmos RPC endpoint with up to XM requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for Evmos, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Evmos Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://evmos-testnet.gateway.pokt.network/v1/lb/61aabb3495d548003aebfd1c Put the decimal 9000 in the ChainID field Write PHOTON as the Symbol Add https://evm.evmos.org/ as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the Evmos network in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Evmos","uri":"/docs-hugo/use/public-rpc/evmos/"},{"content":"Seed nodes enable newly configured nodes to find peers on the network and store them in their local address book.\nMainnet 03b74fa3c68356bb40d58ecc10129479b159a145@seed1.mainnet.pokt.network:20656 64c91701ea98440bc3674fdb9a99311461cdfd6f@seed2.mainnet.pokt.network:21656 0057ee693f3ce332c4ffcb499ede024c586ae37b@seed3.mainnet.pokt.network:22856 9fd99b89947c6af57cd0269ad01ecb99960177cd@seed4.mainnet.pokt.network:23856 f2a4d0ec9d50ea61db18452d191687c899c3ca42@seed5.mainnet.pokt.network:24856 f2a9705924e8d0e11fed60484da2c3d22f7daba8@seed6.mainnet.pokt.network:25856 582177fd65dd03806eeaa2e21c9049e653672c7e@seed7.mainnet.pokt.network:26856 2ea0b13ab823986cfb44292add51ce8677b899ad@seed8.mainnet.pokt.network:27856 a5f4a4cd88db9fd5def1574a0bffef3c6f354a76@seed9.mainnet.pokt.network:28856 d4039bd71d48def9f9f61f670c098b8956e52a08@seed10.mainnet.pokt.network:29856 5c133f07ed296bb9e21e3e42d5f26e0f7d2b2832@poktseed100.chainflow.io:26656 361b1936d3fbe516628ebd6a503920fc4fc0f6a7@seed.pokt.rivet.cloud:26656 pocket start --seeds=\"03b74fa3c68356bb40d58ecc10129479b159a145@seed1.mainnet.pokt.network:20656,64c91701ea98440bc3674fdb9a99311461cdfd6f@seed2.mainnet.pokt.network:21656,0057ee693f3ce332c4ffcb499ede024c586ae37b@seed3.mainnet.pokt.network:22856,9fd99b89947c6af57cd0269ad01ecb99960177cd@seed4.mainnet.pokt.network:23856,f2a4d0ec9d50ea61db18452d191687c899c3ca42@seed5.mainnet.pokt.network:24856,f2a9705924e8d0e11fed60484da2c3d22f7daba8@seed6.mainnet.pokt.network:25856,582177fd65dd03806eeaa2e21c9049e653672c7e@seed7.mainnet.pokt.network:26856,2ea0b13ab823986cfb44292add51ce8677b899ad@seed8.mainnet.pokt.network:27856,a5f4a4cd88db9fd5def1574a0bffef3c6f354a76@seed9.mainnet.pokt.network:28856,d4039bd71d48def9f9f61f670c098b8956e52a08@seed10.mainnet.pokt.network:29856,5c133f07ed296bb9e21e3e42d5f26e0f7d2b2832@poktseed100.chainflow.io:26656,361b1936d3fbe516628ebd6a503920fc4fc0f6a7@seed.pokt.rivet.cloud:26656\" --mainnet Testnet 3487f08b9e915f347eb4372b406326ffbf13d82c@testnet-seed-1.nodes.pokt.network:4301 27f4295d1407d9512a25d7f2ea91d1a415660c16@testnet-seed-2.nodes.pokt.network:4302 0beb1a93fe9ce2a3b058b98614f1ed0f5ad664d5@testnet-seed-3.nodes.pokt.network:4303 8fd656162dbbe0402f3cef111d3ad8d2723eef8e@testnet-seed-4.nodes.pokt.network:4304 80100476b67fea2e94c6b2f72e40cf8f6062ed21@testnet-seed-5.nodes.pokt.network:4305 370edf0882e094e83d4087d5f8801bbf24f5d931@testnet-seed-6.nodes.pokt.network:4306 57aff5a049846d14e2dcc06fdcc241d7ebe6a3eb@testnet-seed-7.nodes.pokt.network:4307 545fb484643cf2efbcf01ee2b7bc793ef275cd84@testnet-seed-8.nodes.pokt.network:4308 pocket start --seeds=\"3487f08b9e915f347eb4372b406326ffbf13d82c@testnet-seed-1.nodes.pokt.network:4301,27f4295d1407d9512a25d7f2ea91d1a415660c16@testnet-seed-2.nodes.pokt.network:4302,0beb1a93fe9ce2a3b058b98614f1ed0f5ad664d5@testnet-seed-3.nodes.pokt.network:4303,8fd656162dbbe0402f3cef111d3ad8d2723eef8e@testnet-seed-4.nodes.pokt.network:4304,80100476b67fea2e94c6b2f72e40cf8f6062ed21@testnet-seed-5.nodes.pokt.network:4305,370edf0882e094e83d4087d5f8801bbf24f5d931@testnet-seed-6.nodes.pokt.network:4306,57aff5a049846d14e2dcc06fdcc241d7ebe6a3eb@testnet-seed-7.nodes.pokt.network:4307,545fb484643cf2efbcf01ee2b7bc793ef275cd84@testnet-seed-8.nodes.pokt.network:4308\" --testnet ","description":"","tags":null,"title":"üå± Seeds","uri":"/docs-hugo/node/seeds/"},{"content":"{% embed url=‚Äúhttps://youtu.be/sSg8QWgR_T8\" %}\nWe have created a public Fuse RPC endpoint with up to 3M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for Fuse, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Fuse Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://fuse-rpc.gateway.pokt.network/ Put the hexadecimal 0x7a in the ChainID field Write FUSE as the Symbol Add https://explorer.fuse.io as the Block Explorer URL Don‚Äôt forget to save ","description":"How to Add the network FUSE in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Fuse","uri":"/docs-hugo/use/public-rpc/fuse/"},{"content":"{% embed url=‚Äúhttps://youtu.be/9nfL7l6YtkU\" %}\nWe have minted a public Gnosis RPC endpoint to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for xDAI, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Gnosis Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://gnosischain-rpc.gateway.pokt.network/ Put the hexadecimal 0x64 in the ChainID field Write XDAI as the Symbol Add https://blockscout.com/poa/xdai as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the Gnosis Chain in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Gnosis Chain (xDAI)","uri":"/docs-hugo/use/public-rpc/gnosis-chain/"},{"content":"This section contain tutorials for various actions a typical user may wish to undertake.\nThe following tutorial, Zero To Node, wlil show you a step-by-step way to set up a Pocket Node on hosted hardware.\n","description":"","tags":null,"title":"Node Tutorials","uri":"/docs-hugo/node/tutorials/"},{"content":"The following services can help automate your node deployments:\nNode Pilot DAppNode PoktRokt Warning: Use at your own risk. These links are not directly associated with Pocket Network and do not constitute an endorsement, guarantee, warranty, or recommendation by Pocket Network, Inc., Pocket Network Foundation, or the Pocket DAO. Do conduct your own due diligence before deciding to use any third party services.\n","description":"","tags":null,"title":"Automated Deployments","uri":"/docs-hugo/node/automated-deployments/"},{"content":"{% embed url=‚Äúhttps://youtu.be/w9ZziTu0ROo\" %}\nWe have created a public Harmony RPC endpoint for applications and end-users to utilize!\nTo get started connecting to Pocket‚Äôs infrastructure for Harmony Mainnet Shard 0, do the following: Click on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Harmony Mainnet 0 POKT Portal Within the New RPC URL field, copy and paste this endpoint URL https://harmony-0-rpc.gateway.pokt.network Put the decimal 1666600000 in the ChainID field Write ONE as the Symbol Add https://explorer.harmony.one as the Block Explorer URL Don‚Äôt forget to save Use the provided RPC URL of Shard 0 if you want to send/receive transactions from exchanges or do any staking transaction type.\nFor information on how to use Metamask with Harmony, please reference Harmony‚Äôs documentation.\n","description":"How to add Harmony Mainnet Shard 0 in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Harmony","uri":"/docs-hugo/use/public-rpc/harmony/"},{"content":"{% embed url=‚Äúhttps://youtu.be/XXzlplnOR7M\" %}\nWe have minted a public IoTeX RPC endpoint with up to 1M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nTo get started connecting to Pocket‚Äôs infrastructure for IoTeX, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write IoTeX Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://iotex-mainnet.gateway.pokt.network/v1/lb/6176f902e19001003499f492 Put the decimal 4689 in the ChainID field Write IOTX as the Symbol Add https://iotexscan.io as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the IoTeX network in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"IoTeX","uri":"/docs-hugo/use/public-rpc/iotex/"},{"content":"If you are interested in staking your POKT in a node but don‚Äôt have the time or technical know-how, below you will find a link to the available options to have your node operated by a third-party.\nList of Node-Hosting Services If you don‚Äôt have enough POKT for the minimum node stake, you should consult this Overview of Pooling Services.\nWarning: Use at your own risk. The appearance of third party descriptions and hyperlinks on the above linked sites does not constitute an endorsement, guarantee, warranty, or recommendation by Pocket Network, Inc., Pocket Network Foundation, or the Pocket DAO. Do conduct your own due diligence before deciding to use any third party services.\n","description":"","tags":null,"title":"Node-Hosting Services","uri":"/docs-hugo/node/hosting-services/"},{"content":"The following pages contains common questions regarding running nodes.\n‚öô Node Configuration Does my blockchain node need to be synced before I start my Pocket node? Yes. Every node on the Pocket Network needs to have the most up to date information of the blockchain they are supporting. If you start joining sessions before your node has caught up to the current block height, you will be returning incorrect data, and if incorrect data is being returned, your node will be slashed.\nHow many blockchains can one node support? Your node can support up to the number of chains defined by the MaximumChains parameter. This limit is not definitive and can be changed by the DAO.\nCan I add a load balancer address in my chains.json if I have multiple blockchains under one domain? Yes you can! Just make sure you have the necessary ports open to be able to successfully send relays to the proper network.\nHow can I add more blockchains to my node? Unstake your node, add the new RelayChainIDs to your chains.json file, then restake your node.\nFind the RelayChainIDs here\nCan I continue earning POKT while I‚Äôm unstaking? No, for the duration of the unstaking process as determined by the UnstakingTime parameter, your node will not be eligible for sessions.\nDo each of my nodes need a unique IP address? You need a dedicated domain for each node, but the nodes can be on the same machine, behind the same IP address. It would take properly configuring your Reverse Proxy and Firewall/Router, but it can be done.\nHow do I set my ulimit? Where to set the ulimit As a best practice, do not use root to run the pocket process. When you set the ulimit for your instance, it‚Äôs important to set it in the user profile that is running the pocket-core instance.\nWarning Make sure that you‚Äôre setting the ulimit for the specific account that‚Äôs running the pocket process.\nConfiguring the ulimit system-wide might vary depending on your OS. Here‚Äôs a basic tutorial on setting them for linux: https://rtcamp.com/tutorials/linux/increase-open-files-limit/\nHow to calculate the ulimit To calculate the ulimit, you will have to define a few parameters as shown below:\n({ulimit -Sn} \u003e= {MaxNumInboundPeers} + {MaxNumOutboundPeers} + {GRPCMaxOpenConnections} + {MaxOpenConnections} + {Desired Concurrent Pocket RPC connections} + {100 (Constant number of wal, db and other open files)}\nBreakdown:\nulimit -Sn: = is a soft number of open files that need to be open GRPCMaxOpenConnections = is the number of RPC connections connections your node can relay MaxOpenConnections = max number of connections you want your node to service You will need to increase your ulimit to the calculated number. To do so, go into your .bashrc in your $HOME dir and enter:\nulimit -Sn 16384 Once you save your file, enter:\nsource ~/.bashrc\nWhat do I do if my node needs to go down for an extended period, such as during a machine migration? To opt out of being selected for work, you should deliberately jail your node, which lets the network know you are not ready to receive any relays. Once the machine is back up and running, you can unjail your node again.\n‚ùå Node Troubleshooting Why is my node not earning POKT? See the section below on Maximizing your POKT earnings.\nHow do I check my Pocket node status? Make sure your node is connected to the network by executing:\ncurl http://\u003cyour node ip\u003e:26657/status Lookout for latest_block_height and latest_block_time to make sure it‚Äôs updated to the current time in UTC.\nExample Output:\n{ \"jsonrpc\": \"2.0\", \"id\": \"\", \"result\": { \"node_info\": { \"protocol_version\": { \"p2p\": \"7\", \"block\": \"10\", \"app\": \"0\" }, \"id\": \"4930289621aefbf9252c91c4c729b7f685e44c4b\", \"listen_addr\": \"tcp://0.0.0.0:26656\", \"network\": \"pocket-testet-playground\", \"version\": \"0.32.7\", \"channels\": \"4020212223303800\", \"moniker\": \"pocket-core-testnet-55f59f6c8-5njbx\", \"other\": { \"tx_index\": \"on\", \"rpc_address\": \"tcp://0.0.0.0:26657\" } }, \"sync_info\": { \"latest_block_hash\": \"090C3B9C3B9F1BB10C6825D5230A45759E19A9BCC1503B80314F93B69162C712\", \"latest_app_hash\": \"AB5838AA434FD36B48B759E62C596F4145F4C086B07FB45D2CCFCFFF21F5F937\", \"latest_block_height\": \"49\", \"latest_block_time\": \"2020-02-10T23:17:59.161691821Z\", \"catching_up\": false }, \"validator_info\": { \"address\": \"4930289621AEFBF9252C91C4C729B7F685E44C4B\", \"pub_key\": { \"type\": \"tendermint/PubKeyEd25519\", \"value\": \"9i9322nUSMG1bzVAxjPylNI8za8AK/azdtBYoAtRz6o=\" }, \"voting_power\": \"1000\" } } } I keep getting ‚Äútoo many open files‚Äù when my node is syncing? What does this mean? This means that your ulimit is set too low on your node. Find instructions on how to set your ulimit above.\nWhy does my node keep crashing? Your node can crash due to the following reasons:\nHaving too many open files Resource limitations Too Many Open Files Make sure your ulimit is set correctly on your user profile. Find instructions on how to set your ulimit above.\nResource Limitations Make sure your node meets the minimum hardware requirements for both a Pocket node and the blockchain nodes you‚Äôre servicing. Details are above on this page.\nWill my node be slashed for downtime? There are negligible burns at this stage of the network, determined by the SlashFractionDowntime parameter. As the network matures, the rate will probably be increased to push for better service.\nü§ë Maximizing your Pocket earnings So you‚Äôve spun up your Pocket node but you‚Äôre not earning as much as you thought you would. On this page, we debunk some common misconceptions and explain how to maximize your earnings.\nMy node is functional but doesn‚Äôt seem to be earning POKT - is it configured incorrectly? There are a couple of reasons why your node may not be rewarding you with POKT. There are many great community members and Pocket teammates that are eager to help you triage this, but first, ask yourself, ‚Äúis your node configured correctly?‚Äù. Don‚Äôt assume it is. Use the troubleshooting steps listed above.\nThe next thing to check is if your node is offline or jailed‚Ä¶or both. Reasons include:\nReturning incorrect data Missing blocks Being offline serviceURI is not publicly reachable If you suspect that this may be happening to your node, you can do a historical search on your nodes. We have a great community member who created this script to help you determine how long you were jailed for a specific period of time.\nChecking your node status is one of the first steps towards maximizing your POKT earnings.\nConversely, how will I know if my node is working correctly? Checking the block height is the easiest way to know if you‚Äôre synced up to the network. You can simply query your node to get this height and compare it to the latest block displayed on the Explorer.\npocket query height The above command tells you if your Pocket node is synced up, but you‚Äôre probably running at least one other node for the external blockchains (referred to on this page as blockchain data nodes) that you‚Äôre serving to apps. You should make sure these are also synced up to their respective networks.\nFor example, you can check the block height of your Geth Ethereum node by submitting this query to your node, which returns the latest height of geth-mainnet known by the node.\ncurl --request POST --header 'Content-Type: application/json' --data-raw '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":83}' --user [authentication] [GETH NODE URL] When will I find out if I have made POKT rewards? To check if you‚Äôre earning rewards, you can simply monitor the balance of your node.\npocket query balance \u003caddress\u003e This way is very manual and you would need to track your balance over time to understand the change in the amounts.\nThe good news is there are several options for tracking your node rewards such as POKT ROKT, which tracks the last 24 hours of earnings in its CLI dashboard, or Sandwalker which tracks historical rewards by day and month.\nWhy don‚Äôt I just connect my Pocket node to [insert third-party provider here]? On the surface, this seems like a great idea. Use a free tier of another service (e.g. Infura) and you don‚Äôt have to pay for any blockchain data node costs.\nFirst off, free tiers by third-party providers are capped, which limits your upside. To make matters worse, if you use a third-party provider instead of running your own blockchain data node, you won‚Äôt make enough POKT to cover the server costs of your Pocket node.\nPlus, that doesn‚Äôt jive with our ethos now, does it?\nWhy wouldn‚Äôt I make enough POKT with a third-party? Using third-party providers slows you down. Slower nodes make less revenue.\nWhy does the third-party slow you down? Increasing the distance between your Pocket node and the third-party blockchain data node increases the number and length of hops that an end-user‚Äôs request has to make.\nHere is an illustration:\nIn this example, the Pocket nodes (pink) are on the other side of the US from the Blockchain data nodes (orange). The end-user is using the Portal to communicate with the network. The path the end-user‚Äôs request must take is: End-user ‚Üí Portal ‚Üí Pocket Node ‚Üí Blockchain Data Node ‚Üí Pocket Node ‚Üí Portal ‚Üí End-user\nThe end-user‚Äôs request must hop back and forth across the US 4 times and that‚Äôs not including the hops between the user and the Portal. As a result, it may take up to 1 second for a user to receive something as simple as a balance query. That‚Äôs not very good service.\nAren‚Äôt there data centers around the world for this exact reason? Correct. However, this works against you in this scenario.\nMost third-party providers will have their servers in standard cloud regions situated around the world labeled such as East, West, EU, and Singapore. Load balancers are standard. For example, if a user is in Australia, they will be redirected to the nearest server in Singapore.\nThe challenge with using a third-party provider for your blockchain data node is that, by default, your Pocket Node will not always be in the same data center or machine as the third-party blockchain data node. If your Pocket Node is in US West, while you may have lesser latency from users who are hitting those servers, your node will *never* be as fast as it could be.\nYour node will likely be in a different datacenter, where even a couple of hops will add somewhere between 30ms - 50ms. This becomes exacerbated when a user is coming from US East or the EU. With a full node on US West, you‚Äôre adding up to 200ms per request for these users.\nWhy does the latency matter? While Pocket Network doesn‚Äôt discriminate (yet) between the speed of requests, the Portal does. The Portal filters out slow nodes to ensure the protocol is providing the best service possible to apps.\nThe vast majority of the requests on the network today come through the Portal. This means that faster nodes = more POKT.\nIn the long run, your setup matters not only for your earnings but also for ensuring a quality service for end-users (which will ultimately be crucial for the growth of the network).\nThen how can I maximize my node revenue? The following are some best practices that will give you an edge over the majority of node runners.\nKnow where the users are located‚Ä¶ and locate your nodes accordingly. The Pocket Portal is currently in US-West-2, US-East-2, EU-West-1, AP-SE-1. The most underserved geographic area on Pocket is currently the Asia Pacific region. Minimize the distance between your Pocket Nodes and your blockchain data nodes. Having your blockchain data nodes next to your Pocket nodes in the same rack is ideal. Load-balance your blockchain data nodes. Use a Peering Tower to reduce P2P gossip on the network. Visit the ü§ñnode-runner channel on Discord for more information. Use physical hardware at home or data centers; you will have faster nodes and lower costs over time by owning your hardware and co-locating it. Monitor your nodes for both health and sync ‚Äì being online is only the first step, you must keep your blockchain data nodes in sync or they will not service relays. Use services like the Performance Explorer to monitor your node‚Äôs performance in comparison to other nodes. ","description":"","tags":null,"title":"Node FAQ","uri":"/docs-hugo/node/faq/"},{"content":"{% embed url=‚Äúhttps://youtu.be/C0jDq20pBYQ\" %}\nWe have created a public Polygon RPC endpoint with up to 5M requests per day to give people who use Metamask the opportunity to connect to Pocket‚Äôs decentralized, censorship-resistant infra.\nMore details here:\nhttps://forum.matic.network/t/pocket-network-creates-free-polygon-rpc-community-endpoints/1597\nTo get started connecting to Pocket‚Äôs infrastructure for Polygon, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write Polygon Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://poly-rpc.gateway.pokt.network/ Put the decimal 137 in the ChainID field Write MATIC as the Symbol Add https://polygonscan.com as the Block Explorer URL Don‚Äôt forget to save ","description":"How to add the Polygon network in MetaMask with a Pocket-powered RPC Endpoint","tags":null,"title":"Polygon","uri":"/docs-hugo/use/public-rpc/polygon/"},{"content":"We have minted a public G√∂rli RPC endpoint with up to 10M requests per day to give players who are exploring the Conquest metaverse the opportunity to connect to Pocket‚Äôs decentralized, resilient infra!\nTo get started connecting to Pocket‚Äôs infrastructure for G√∂rli testnet, do the following:\nClick on the Networks drop-down menu, then press Custom RPC Under the Network Name field, write G√∂rli Pocket Portal Within the New RPC URL field, copy and paste this endpoint URL https://eth-goerli.gateway.pokt.network/v1/lb/619f72f64df71a00392de6d9 Put the decimal 5 in the ChainID field Don‚Äôt forget to save For instructions on how to get started with Conquest, check out their documentation and video:\n{% embed url=‚Äúhttps://www.loom.com/share/787e5abf99384cbd8546ad40bd30a4bc\" %}\nJoin Etherplay‚Äôs discord for early alpha access to the Conquest game!\n","description":"How to connect G√∂rli network in MetaMask with a Pocket-powered RPC endpoint","tags":null,"title":"Conquest.eth","uri":"/docs-hugo/use/dapps/conquest-eth/"},{"content":"","description":"","tags":null,"title":"SDKs","uri":"/docs-hugo/integrate/sdk/"},{"content":"The Native POKT Blockchain Token POKT is the native token of the Pocket Blockchain. Its lowest, indivisible unit is uPOKT.\nPOKT and uPOKT POKT is a 6 decimals token: 1*10^6 uPOKT = 1 POKT\nAll numbers displayed through RPC calls on the Pocket blockchain are displayed in uPOKT, and all transactions use uPOKT.\nGenerating Accounts and Sending Transactions Account Generation and Validation Transaction Construction Transaction Verification ","description":"","tags":null,"title":"Accounts and Transactions","uri":"/docs-hugo/integrate/accounts-transactions/"},{"content":"{% embed url=‚Äúhttps://youtu.be/jxfOc4XjJaw\" %}\nWe have issued an xDAI RPC endpoint that grants up to 50M requests per day (\u0026 250 nodes per hour) just for Dark Forest players!\nTo get started connecting to Pocket‚Äôs node infrastructure for xDAI in Dark Forest, do the following:\nClick on the gear icon to open the settings page If it doesn‚Äôt open automatically, click on ‚Äú+‚Äù icon to expand the settings page Scroll down until you see the ‚ÄúChange RPC Endpoint‚Äù section Copy and paste this endpoint URL into the text boxhttps://poa-xdai.gateway.pokt.network/v1/lb/60b13899d3279c22da2a444d`` Click ‚ÄúChange RPC URL‚Äù to Save Make a move! ","description":"How to add Pocket-powered xDAI RPC endpoint in the Dark Forest blockchain game","tags":null,"title":"Dark Forest","uri":"/docs-hugo/use/dapps/dark-forest/"},{"content":"Pocket Network is a pioneer in a new era of democratically-governed digital public goods. Our Decentralized Autonomous Organization (DAO) means that you, our community, will control all aspects of our protocol and ecosystem.\nPocket uses off-chain governance because it‚Äôs the most flexible and future-proof way for us to organize our DAO. For more on our reasoning behind this, check out our Lean Governance Thesis.\nTo learn how to earn a vote in the DAO and decide the future of Pocket Network, see the section on trophies.\nInfo You don‚Äôt need a vote in the DAO to submit proposals or participate in discussions! Everyone is free to share their opinions. Head over to the forum to see what decisions are being debated.\nTo learn how to submit a proposal to the DAO, see the section on proposals.\nAll approved decisions get submitted to the blockchain by the Pocket Network Foundation, which is fully accountable to the DAO. To learn more about how this is, read the DAO Constitution and the Foundation‚Äôs Articles of Association.\n","description":"","tags":null,"title":"üëë Governance","uri":"/docs-hugo/community/governance/"},{"content":"{% embed url=‚Äúhttps://youtu.be/LTVNN3SBuik\" %}\nMyCrypto is an open-source, client-side tool for generating Ethereum wallets, handling ERC-20 tokens, and interacting with the blockchain more easily. Developed by and for the community since 2015, they‚Äôre focused on building awesome products that put the power in people‚Äôs hands.\nThis is why we want to give users an opportunity to connect to our own infrastructure!\nOpen the MyCrypto desktop application, if you don‚Äôt have it yet, then download it here: https://download.mycrypto.com Find ‚ÄúChange Network‚Äù on the bottom left-hand side of the menu, then click on it. Under ‚ÄúShow Other Networks‚Äù, click ‚Äú+Add Custom Node‚Äù to bring up the ‚ÄúSet Up Your Custom Node‚Äù menu. In the ‚ÄúNode Name‚Äù field, write Pocket Network Gateway Keep the Network set to ETH (a.k.a Ethereum) Then, copy and paste in the Endpoint URL: https://eth-mainnet.gateway.pokt.network/v1/5f46739e2164c49f99af2480 Do not check the HTTP Basic Authentication box Then, press the ‚ÄúSave \u0026 Use Custom Node‚Äù button Use Decentralized Infra ","description":"","tags":null,"title":"MyCrypto","uri":"/docs-hugo/use/dapps/mycrypto/"},{"content":"Rotki is an open-source portfolio tracker and accounting/analytics tool that protects your privacy.\nWe‚Äôve sponsored a public Ethereum RPC endpoint for Rotki users in order to add an extra layer of privacy when using the application.\nTo get started connecting to Pocket‚Äôs censorship-resistant infrastructure for Ethereum, do the following:\n1. Open and login into your local application.\n2. Toggle to account, then open settings.\n3. Scroll down to the Local Nodes section, then delete the default RPC endpoint.\n4. Copy \u0026 Paste this URL into the Ethereum Node RPC Endpoint field:\nhttps://eth-mainnet.gateway.pokt.network/v1/lb/615541c96ad539003506595e\nReference the Rotki User Guide for additional support.\n","description":"How to add a Pocket-powered Ethereum RPC endpoint within your local Rotki application","tags":null,"title":"Rotki","uri":"/docs-hugo/use/dapps/rotki/"},{"content":"How to Contribute Submit an RFP ‚Äì¬†Highlight a Need An RFP is a Request for Proposal. You would use this when you know that something is needed but you are unsure of exactly what the solution is or are unable to build it yourself. Posting an RFP should serve as a signal to other community members that there might be demand for their contributions.\nFor example, this Node Deployment Solutions RFP which led to the successful PEP (POKT grant) for an automated deployment tool called Node Pilot.\nTo submit an RFP, head to the RFP forum category and click New Topic.\nSubmit a PEP ‚Äì¬†Earn a POKT Grant for Your Work A PEP is a type of proposal that requests a POKT grant from the DAO treasury. You could get a POKT grant for contributions to the Pocket Network ecosystem.\nRead more about submitting a proposal.\nSubmit a PR - Become an Active Pocket v1 Contributor You can become an open-source contributor by submitting contributions to the Pocket protocol specifications or the main v1 Pocket implementation.\nAll the issues are documented and tagged on Github, and the ‚Äústarter task‚Äù tag can be used to filter for simpler issues to get you acquainted with the codebase.\nAll of these contributions are under the MIT license but may be partially rewarded by the scholarship fund. Larger contributions from repeat contributors will be evaluated by the DAO through separate proposals.\nIn addition to contributing to the future of Web3, you will also get mentorship and experience by working with the core Pocket team, as well as present and discuss your work in our weekly contributor hours.\nCheck out the #v1-research and #v1-dev channels in Discord to connect with the team.\n","description":"","tags":null,"title":"ü¶∏ Contribute","uri":"/docs-hugo/community/contribute/"},{"content":"Welcome to Zero To Node! This is a step-by-step guide for setting up a Pocket validator node. While there are many different ways to set up a node, the focus of this tutorial is on keeping things simple and with the minimum of steps, while still focusing on security and stability.\nThis guide is broken down into five parts:\nPart 1: Server setup Part 2: Software installation Part 3: Pocket configuration Part 4: Proxy configuration Part 5: Going live Background The main utility of a Pocket node is to relay transactions to other blockchains. So, Pocket nodes need access to other nodes for the blockchains they‚Äôll be relaying to. However, the focus of this guide is just on setting up a Pocket node that will relay to the Pocket network, essentially, through itself. Setting up nodes for other blockchains such as Harmony, Ethereum, or any of the other supported blockchains is beyond the scope of this guide.\nAfter completing the steps outlined here, you‚Äôll have a fully functional Pocket node up and running. If you choose, you can also opt to stake your node and earn rewards. We‚Äôll cover that here, but staking is not required unless you want to earn rewards.\nWho is this guide for? This guide is for anyone interested in running Pocket nodes. While the goal is to keep things simple, the assumption is that you have some general blockchain and computer networking knowledge, and some Linux terminal experience.\nWhat you‚Äôll need In order to complete this guide, you‚Äôll need:\nA server connected to the internet A domain name The ability to add DNS records for your domain 15,100 POKT (if you want to stake your node) About 2-4 hours to complete and test everything ","description":"","tags":null,"title":"Introduction","uri":"/docs-hugo/node/tutorials/zero-to-node/"},{"content":"Claim Your Vote!\nThe DAO onboarding process has been designed to assign governance powers to the most engaged, knowledgeable, and experienced members of the Pocket Network community.\nThe steps for obtaining a vote are as follows‚Ä¶\n1. Get Qualified First, you need to prove your knowledge of and participation in the Pocket Network by earning trophies.\nThere are four paths that you can take on this journey:\nApp Developers Node Runners Community Shepherds Governor/Contributors You will complete a series of quests and report your completion of these quests in the üèÜtrophies channel in Discord. Follow the path guides above to see which quests are up next and how many you need to evolve.\nOnce you have evolved to the 3rd level of any path, you have qualified for a vote in the DAO. Type !qualify in the üèÜtrophies channel to obtain the Qualified role.\n2. Get Verified If you want to be verified by our existing Voters, and obtain the Verified role, you must do both of the following:\nPost a selfie to the #‚úÖverify channel holding a piece of paper with your Discord username (e.g. username#1234) and the day‚Äôs date Post a message to the #‚úÖverify channel with the following template: !verify\nMy favorite thing about Pocket Network:\nWhy I want to be a Voter:\nOnce you have done this, if existing Voters are comfortable you are not a malicious agent, they will approve you. If 33% of existing Voters approve you in the next 7 days, you‚Äôll be officially verified and one step closer to obtaining your own vote in our DAO.\n3. Claim Your Vote Type !claim-vote in the üèÜtrophies channel. This will only work if you got both the Qualified and Verified roles.\nThen DM jackal to claim your POKTDAO token airdrop (our airdrop bot is currently out of commission).\nInfo The token is non-transferable so you should choose a MetaMask or WalletConnect wallet that you‚Äôre happy holding the token in forever.\n4. Vote and Subscribe Vote in our governance dashboard by connecting the wallet you chose for your POKTDAO airdrop. Subscribe to üì•proposals (click Follow) to make sure you don‚Äôt miss anything! ","description":"","tags":null,"title":"üó≥ Trophies","uri":"/docs-hugo/community/trophies/"},{"content":"The simplest way to generate new accounts, or addresses, on the POKT blockchain is to use the official Pocket client, PocketJS.\nCreating a New Account To create a new account on the POKT blockchain and export it:\nimport { Pocket } from '@pokt-network/pocket-js' // PocketJS must always be initialized with at least one dispatcher. const POCKET_DISPATCHER = 'https://dispatch-1.nodes.pokt.network:4201' const pocket = new Pocket(POCKET_DISPATCHER) // The passphrase used to encrypt the private key while in memory: const PASSPHRASE = 'foobar' const account = await pocket.keybase.createAccount(PASSPHRASE) // The result of successful account creation: console.log(account) // Using the exportAccount function, you can obtain a plaintext private key. const exportedAccountPrivateKey = await pocket.keybase.exportAccount( account.address.toString('hex'), PASSPHRASE ) // This plaintext private key should be encrypted before storage. console.log(exportedAccountPrivateKey.toString('hex')) // You can also export an encrypted JSON version of the same private key. // The passphrase used to encrypt this JSON file is separate from the // previous PASSPHRASE. const exportedPPK = await pocket.keybase.exportPPK( exportedAccountPrivateKey, // The PPK passphrase used to encrypt the JSON file 'foo', // A hint for the PPK passphrase 'what comes before bar' ) console.log(exportedPPK) Importing an Existing Account To import an existing account using either the raw private key or the encrypted JSON PPK:\nimport { Pocket } from '@pokt-network/pocket-js' // PocketJS must always be initialized with at least one dispatcher. const POCKET_DISPATCHER = 'https://dispatch-1.nodes.pokt.network:4201' const pocket = new Pocket(POCKET_DISPATCHER) // The passphrase used to encrypt the private key while in memory: const PASSPHRASE = 'foobar' const PRIVATE_KEY = '...' // Import an existing account using the raw private key: const importedAccount = await pocket.keybase.importAccount( PRIVATEKEY, // The passphrase to encrypt the private key while in memory PASSPHRASE ) // Import an account using the encrypted JSON PPK: const importedPPKAccount = await pocket.keybase.importPPK( // The PPK passphrase used when the key was exported 'foo', exportedPPK.salt, exportedPPK.secParam, exportedPPK.hint, exportedPPK.cypherText, // The passphrase to encrypt the private key while in memory PASSPHRASE, ) Verifying an Address To verify a POKT blockchain address, public key, or raw private key:\nimport { validateAddressHex, validatePrivateKey, validatePublicKey } from '@pokt-network/pocket-js' // Validate a POKT blockchain address: returns undefined if valid. // This should be wrapped in a try / catch block as it will throw the // appropriate error if the address is not valid. try { const isValidAddress = !( validateAddressHex(account.addressHex) instanceof Error ) } catch (e) { // Handle the error } // Validate a public key: returns true or false. const isValidPublicKey = validatePublicKey(account.publicKey.toString('hex')) // Validate a private key: returns true or false. const isValidPrivateKey = validatePrivateKey(privateKey) ","description":"Generate and validate accounts on the native POKT blockchain.","tags":null,"title":"Account Generation and Validation","uri":"/docs-hugo/integrate/accounts-transactions/account-generation-validation/"},{"content":"Sending a Transaction To send a transaction on the POKT blockchain:\nimport { Pocket } from '@pokt-network/pocket-js' const RECEIVER_ADDRESS = '...' const SENDER_ADDRESS = '...' const SENDER_PRIVATE_KEY = '...' // The passphrase used to encrypt the private key while in memory: const PASSPHRASE = 'foobar' // PocketJS must always be initialized with at least one dispatcher. const POCKET_DISPATCHER = 'https://dispatch-1.nodes.pokt.network:4201' // To send a transaction, you can use one of the public RPCs or // your own Pocket node. const POCKET_RPC = 'https://mainnet-1.nodes.pokt.network:4201' const pocket = new Pocket(POCKET_DISPATCHER, POCKET_RPC) // If you are using Pocket Mainnet, make sure to disable legacyCodec pocket.configuration.useLegacyTxCodec = false; // Create a transaction signer using the `withPrivateKey` method: const txSigner = pocket.withPrivateKey( SENDER_PRIVATE_KEY ) const transactionResponse = await txSigner.send( // Origin address for the send SENDER_ADDRESS, // Receiver address RECEIVER_ADDRESS, // 10 POKT '10000000' ).submit( 'mainnet', // The transaction fee is always 10,000 uPOKT '10000' ) // Check if the transaction returned an error: if (typeGuard(transactionResponse, RpcError)) { throw new Error(transactionResponse.message) } // You will be able to look up this transaction through this hash after the // next block clears. const { hash } = transactionResponse console.log(hash) Creating a Signed SEND Transaction Offline To create a signed transaction that can be sent immediately or stored:\nimport { Pocket } from '@pokt-network/pocket-js' const RECEIVER_ADDRESS = '...' const SENDER_ADDRESS = '...' const SENDER_PRIVATE_KEY = '...' // The passphrase used to encrypt the private key while in memory: const PASSPHRASE = 'foobar' // PocketJS must always be initialized with at least one dispatcher. const POCKET_DISPATCHER = 'https://dispatch-1.nodes.pokt.network:4201' const pocket = new Pocket(POCKET_DISPATCHER) // If you are using Pocket Mainnet, make sure to disable legacyCodec pocket.configuration.useLegacyTxCodec = false; // Create a transaction signer using the `withPrivateKey` method: const txSigner = pocket.withPrivateKey( SENDER_PRIVATE_KEY ) // Now use the transaction signer to create a signed SEND transaction const txSignerWithSendTransaction = txSigner.send( // Origin address for the send SENDER_ADDRESS, // Receiver address RECEIVER_ADDRESS, // 10 POKT '10000000' ) // Generate offline signed send transaction const sendTx = await txSignerWithSendTransaction.createTransaction( 'mainnet', // The transaction fee is always 10,000 uPOKT '10000' ) console.log('Offline signed send transaction:', sendTx) After calling .sendTransaction(), you will get back a response with this format:\nRawTxRequest { address: \"1e829f34ce5533c913638310408632242f6fbd43\", txHex: \"d1010a4....bf8970d\" } Calculate transaction hash from raw transaction bytes const crypto = require('crypto'); // This is the raw transaction bytes obtained from offline signed transaction const txHex = 'd1010a4....bf8970d' const txHash = crypto.createHash('sha256').update(Buffer.from(txHex, 'hex')).digest('hex'); console.log(txHash) Deserialize offline signed SEND transaction You can also decode the raw transaction bytes generated offline (only works for SEND transactions):\n// Only supported for versions \u003e= 0.7.1 const { ProtoTxDecoder } = require('@pokt-network/pocket-js') const ENCODED_TX_BYTES = Buffer.from('d1010a4....bf8970d', 'hex') const protoTxDecoder = await pocket.withProtoTxDecoder() const protoStdTx = await protoTxDecoder.unmarshalStdTx(ENCODED_TX_BYTES) const data = await protoTxDecoder.decodeStdTxData(protoStdTx) console.log('Deserialized transaction:', data) ","description":"","tags":null,"title":"Transaction Construction","uri":"/docs-hugo/integrate/accounts-transactions/transaction-construction/"},{"content":"Confirming that Funds have been Received // The 64-character transaction hash is necessary to retrieve the transaction: const tx = await pocket.query.getTX(hash) if (typeGuard(tx, RpcError)) { throw new Error(tx.message) } // The retrieved transaction object: console.log(tx) The return code of the transaction must be 0 ‚Äî indicating success:\n\"tx_result\": { \"code\": 0, \"codespace\": \"\", \"data\": null, \"events\": null, \"info\": \"\", \"log\": \"\", \"message_type\": \"send\", \"recipient\": \"...\", \"signer\": \"...\" } Consult the error types in Pocket Core for information on failed transactions.\n","description":"","tags":null,"title":"Transaction Verification","uri":"/docs-hugo/integrate/accounts-transactions/transaction-verification/"},{"content":"Submitting proposals to the DAO is pretty easy and anyone can do it.\nThere are 3 types of proposals:\nPIP: Pocket Improvement Proposal PEP: Pocket Ecosystem Proposal PUP: Pocket Update Proposal Posting your proposal to Discourse puts it up for consideration and debate by the DAO. To kickstart a vote, you need a voter to submit it to our governance dashboard on your behalf.\nü¶æ PIP ‚Äì Pocket Improvement Proposal Pocket Improvement Proposals (PIPs) include any proposals that aim to level up the Pocket Network ecosystem, through:\nUpgrading the Pocket Network protocol Upgrading the governance of the DAO and the Pocket Network Foundation Adding/removing permission holders within the existing governance structure of the DAO PIP votes will last 7 days and pass with Majority Approval (50% yes votes by participating voters) unless otherwise specified in the Constitution.\nTo submit a PIP, head to the forum here, then click New Topic to generate a template for your proposal.\nüí∞ PEP ‚Äì Pocket Ecosystem Proposal Pocket Ecosystem Proposals (PEPs) include proposals to distribute funds to or form agreements with Contributors to the Pocket Network ecosystem, in the form of:\nImbursements ‚Äì payments for future work Reimbursements ‚Äì compensation for previous work Bounties ‚Äì rewards for work that don‚Äôt yet have specified workers Transfers ‚Äì transferring funds between DAO-owned accounts Agreements ‚Äì forming new DAO relationships, including non-financial in nature Info How is the DAO funded?\nThe DAO earns continuous revenue in the form of the DAOAllocation, which is a % that the DAO receives for every RelaysToTokensMultiplier minted in the block reward. This is proportional to the number of relays being processed for app developers, which means the more traction Pocket Network gets, the more wealthy the DAO becomes!\nPEP votes will last 7 days and pass with Majority Approval (50% yes votes by participating voters) unless otherwise specified in the Constitution.\nTo submit a PEP, head to the forum here, then click New Topic to generate a template for your proposal.\nüéö PUP ‚Äì Parameter Update Proposal Parameter Update Proposals (PUPs) include any proposals to modify the value of the [protocol parameters]((../../learn/protocol-parameters.md).\nPUP votes will last 7 days and pass with Majority Approval (50% yes votes by participating voters) unless otherwise specified in the Constitution.\nTo submit a PUP, head to the forum here, then click New Topic to generate a template for your proposal.\nThe following parameters are delegated to the Foundation to manage the parameter on the DAO‚Äôs behalf:\nSupportedBlockchains (PIP-6.2) MaxApplications (PIP-6.2) BaseRelaysPerPOKT StabilityAdjustment ","description":"","tags":null,"title":"Proposals","uri":"/docs-hugo/community/governance/proposals/"},{"content":"The PEP-31 Scholarship Fund was approved by the DAO in June 2022 to allocate an accumulating monthly allowance of 10,000 POKT per month to contributors, students, learners, speakers, educators and others in the Pocket community.\nRecipients June 2022 Tyler Kell (@relyt29) is the first recipient of the Pocket Scholarship for his presentation Academic Cryptocurrency Research Space - An Overview, Spring 2022 at Infracon 2022 - Pocket‚Äôs inaugral conference.\nThe slides are available online here and a PDF export is available in the repo here. A sum of 10,000 POKT was awarded in for this work via the following transaction: 6F9EA955FBD509E91B7EC38A6474555E846540090197816A634A03486B133C8C!\n","description":"","tags":null,"title":"Scholarships","uri":"/docs-hugo/community/contribute/scholarships/"},{"content":"Netizen So you want to be a full-fledged Cyberpunk? Joining our elite is not for the faint of heart. You must first prove your worth as a Netizen by completing the following bounty and by providing evidence in the üèÜtrophies channel on Discord.\nTo claim your new Netizen role once you‚Äôve done this, type !become-netizen.\nGateway Get a Pocket Portal endpoint and send at least 1,000 relays. You can sign up for a Pocket Portal endpoint here.\nInfo To verify the number of relays sent by you through the Portal, you need to send an email to jack at pokt dot network, using the same email you used to sign up for the Portal, with the subject as ‚ÄúGateway Quest‚Äù and your applicationPublicKey in the body.\nSavant So you aren‚Äôt a poser! Now let‚Äôs see if you‚Äôre worthy to join the ranks of the Savants. To earn this title, you must complete at least 5 out of 9 of the following bounties, once again providing evidence in the üèÜtrophies channel on Discord.\nTo claim your new Savant role once you‚Äôve done this, type !become-savant.\nMaintenance Build your own tooling or have an approved PR on existing Pocket-related open-source application tooling.\nLoadtest Participate in load testing nodes with at least 1m relays in Pocket testnets.\nQA Create or contribute (non-grammatical) improvements to Pocket application technical documentation or open-source application tooling documentation.\nBootcamp-Dev Create or contribute (non-grammatical) improvements to a guide on how to use Pocket for other app developers.\nMentor Help another app developer get started using Pocket.\nTorrent This bounty is split into 4 parts, each worth 1 point towards your 5/9 target:\nSend 2.5 million relays through Pocket Network. Send 5 million relays Send 7.5 million relays Send 10 million relays Qualified! Once you‚Äôve reached Savant, you‚Äôre now qualified for a vote in our DAO.\nCyberpunk Well done Savant, we recognize the trials you have taken on and the skills you have acquired to reach this point. The bounties at this point are the ones that will build lasting resilience and autonomy for the future we seek to create. Complete all bounties from every rank of the App Developer path then submit the !become-cyberpunk command to enter the elite of the elite, the pantheon of Cyberpunks.\nToken-Handler Build tooling for AAT management and have 3 Verified Savants or Pocket core team members vouch for the tool‚Äôs quality.\nOptimizer Build tooling for optimizing app stake prices and have 3 Verified Savants or Pocket core team members vouch for the tool‚Äôs quality.\nFounded Create or take ownership of an application, SDK, or tool that is vouched for by at least 3 (BrightID) Verified Savants or Pocket core team members.\nVentured Submit an application-oriented PEP and receive a POKT grant from the DAO.\n","description":"","tags":null,"title":"üèÜ App Developers","uri":"/docs-hugo/community/trophies/app-developers/"},{"content":"Nod√©g√© Greetings aspiring Node Runner, we have heard your call to join us in the battle against the corporate node overlords. In order to earn the Nod√©g√© rank, you must complete 3/3 of the following assignments, providing evidence in the üèÜtrophies channel, then submit the !become-nodege command.\nServer Stake your node successfully in Pocket testnet or mainnet.\nInfo To verify that you own the account, you must sign a message using the following CLI command, removing the \u003c\u003e and the \"\"\npocket accounts sign \u003caccount address\u003e \"account address\" Then send your address, public key, and the signature that was generated by the command to the üèÜtrophies channel.\nTransmission Successfully submit a proof transaction in Pocket testnet or mainnet.\nJailbreak Avoid getting jailed for 7 days (672 consecutive blocks) in Pocket testnet or mainnet.\nNodemad Congratulations Nod√©g√©, lesser nodes have not made it this far, we are pleased with your progress. To earn the Nodemad rank, you must complete 5/8 of the following assignments, providing evidence in the üèÜtrophies channel, then submit the !become-nodemad command.\nDatacenter Avoid getting jailed for 1 month (2880 consecutive blocks) in Pocket mainnet.\nBroadcast Submit successful proof transactions of 50k relays in Pocket mainnet.\nOverseer Help another community member set up their node.\nToolkit Build and open source your own tooling or have an approved PR on existing Pocket-related open source node tooling.\nBetakey Participate in beta testing for a new Pocket Core version and submit the results of at least one useful test, as vouched for by the Pocket Core developers.\nDocument Create or contribute (non-grammatical) improvements to Pocket node technical documentation or open source node tooling documentation.\nBootcamp-Node Create or contribute (non-grammatical) improvements to a guide on how to run a Pocket node.\nUpgrade Upgrade your node before the DAO‚Äôs chosen upgrade height.\nQualified! Once you‚Äôve reached Nodemad, you‚Äôre now qualified for a vote in our DAO.\nNode Runner You‚Äôve proven yourself a key member of our node army. Complete all assignments from every rank of the Node Runner path then submit the !become-node-runner command to cement your legacy in the pantheon of our greatest Node Runners.\nCloud Avoid getting jailed for 3 months (8640 consecutive blocks), for at least 5 Pocket nodes, in Pocket mainnet.\nLivestream Submit successful proof transactions of 1M relays in Pocket mainnet.\nInfrared Submit an infrastructure-oriented PEP and receive a POKT grant from the DAO.\nTestkit Participate in beta testing for 3 Pocket Core versions (excluding the one you did for the Betakey quest) and submit the results of at least one useful test, as vouched for by the Pocket Core developers.\nSatellite Maintain a dispatch node and have 3 Verified Netizens or Pocket core team members vouch that they have included you in their dispatch list.\nSeedbank Maintain a seed node and have 3 Verified Nod√©g√©s or Pocket core team members vouch that they have included you in their seed list.\nRelay-Station Submit successful proof transactions of 50k relays in all whitelisted RelayChainIDs in Pocket Mainnet.\n","description":"","tags":null,"title":"üèÜ Node Runners","uri":"/docs-hugo/community/trophies/node-runners/"},{"content":"Farmer Namaste aspiring Shepherd, we kindly thank you for your willingness to nurture this community into one that is regenerative and ripe with autonomous agents. While our allies in the Node Runner and App Developer paths are fortifying our outposts and advancing our objectives, the jobs on this ranch serve to replenish our ecosystem. To join the rank of Farmers, complete 6/8 of the following jobs, providing evidence in the üèÜtrophies channel, then submit the !become-farmer command.\nSeed-Pouch Swap the RPC endpoints on your wallets with Pocket. (Find your network information here.)\nInfo To verify that you used the app, screen record yourself submitting an on-chain action (e.g. submitting a transaction or querying chain data), with your Discord username somewhere on the screen, then share the screen recording to üèÜtrophies when you report the quest completion.\nQuick-Repair Highlight (and fix where possible) inconsistencies/bugs or other improvements in Pocket‚Äôs website, documentation, social channels or content.\nBird-Seed Tweet about Pocket in a meaningful way, retweeted by 3 Verified Shepherd‚Äôs or Pocket core team members.\nSwarm Identify and share 3 relevant (unshared) tweets that other Farmhands can respond to.\nDogfood Confirm that you have used two community apps.\nInfo To verify that you used the app, screen record yourself submitting an on-chain action (e.g. submitting a transaction or querying chain data), with your Discord username somewhere on the screen, then share the screen recording to üèÜtrophies when you report the quest completion.\nSeedling Generate 1 unique idea for future iterations of the trophy system.\nLeaflet Create a Pocket meme and get at least 5 dab reacts from Verified Shepherd‚Äôs or Pocket core team members.\nFertilizer Purchase Discord Nitro and boost Pocket Network‚Äôs community server.\nShepherd At this point you have now familiarized yourself with the ways of the Farmers. Your studies at this level will seek to align you more deeply with the vision and mission that has brought us together. Completing 4/6 of the following jobs will earn you a flight to the Shepherd‚Äôs station. Provide proof of your work in the üèÜtrophies channel, then submit the !become-shepherd command.\nInfolink Attend a Pocket workshop or community call.\nBiomimicry Make notes/takeaways from a Pocket workshop or community call.\nNanobee Help to organize a Pocket workshop or community call.\nForaging Collect and organize user feedback/questions for the Pocket core team.\nCultivation Mentor anyone into achieving the Farmer rank.\nPath-of-Least-Resistance Create educational content for Pocket.\nQualified! Once you‚Äôve reached Shepherd, you‚Äôre now qualified for a vote in our DAO.\nRegen ‚ÄúDe lo mio‚Äù, Shepherd. In our homeland, this term of endearment means ‚Äúone of mine‚Äù. Because you have made it here, we consider you to be one of our closest allies in a mission yet unfulfilled. But there is little time for frivolities, the enemy has expanded into the farthest reaches of Web3 and we must continue to cultivate the lands upon which our node and dev allies will fight them. The work of Shepherds requires the softest of touches, as you will be venturing out to guide others towards the regenerative path of true decentralization. Complete every job in all ranks of the Community Shepherd path then submit the !become-regen command to earn enlightenment in the pantheon of Regens.\nTelepathy Create meaningful content about Pocket Network, vouched for by 3 Verified Shepherd‚Äôs or Pocket core team members.\nTopographics Translate content on Pocket‚Äôs website, blog or docs.\nWool-Clipper Successfully onboard an app developer into Pocket Network.\nShepherds-Crook Successfully onboard a node runner into Pocket Network.\nSheep-Dog Successfully onboard 5 node runners into Pocket Network.\nSeed-Fund Submit a community-orientated PEP and receive a POKT grant from the DAO.\nAssurance QA and document a Pocket library, product or pre-release.\n","description":"","tags":null,"title":"üèÜ Community Shepherds","uri":"/docs-hugo/community/trophies/community-shepherds/"},{"content":"Biohacker Greetings fledgling DAOist and aspiring Biohacker. It is now time to augment your skills via the cybernetic system, Pocket DAO, to truly enhance this community‚Äôs mission. You will be considered a true Biohacker if you acquire 2/3 of the following augments, providing evidence in the üèÜtrophies channel, then submit the !become-biohacker command.\nAnode Author any successful proposal\nNeurolink Successfully claim a vote.\nSentinel Successfully challenge an action.\nWarning This quest can‚Äôt be completed currently because our proposal challenge system isn‚Äôt live yet.\nCyborg We‚Äôre impressed with your augmentation capabilities, but to truly become a Cyborg you‚Äôll need to acquire 3/5 of these augments, providing evidence in the üèÜtrophies channel, then submit the !become-cyborg command.\nCybernetic-Arm Author a successful PIP (independent of the Anode quest).\nCybernetic-Leg Author a successful PUP (independent of the Anode quest).\nImplanted-Rebreather Author a successful PEP (independent of the Anode quest).\nFeedback-Loop Author a successful constitutional amendment.\nRegulated-Nervous-System Join the Aragon Court.\nWarning This quest can‚Äôt be completed currently because Aragon Court isn‚Äôt live yet.\nSingularity Qualified! You‚Äôre now qualified for a vote in our DAO. Follow the rest of the steps outlined here to claim your vote:\nSo you have ventured where few still dare to go. Your current augments allow for deeply integrated communications with our cybernetic organization. Acquire every augment from all ranks in the Governor path then submit the !become-singularity command and you may just unlock infinite power‚Ä¶ The Singularity is near‚Ä¶\nNanobots Author 3 successful PEPs (independent of previous quests).\nMachine-Learning Author 3 successful PUPs (independent of previous quests).\nArtificial-Intelligence Author 3 successful PIPs (independent of previous quests).\nQuantum-Resistance Author 3 constitutional amendments (independent of previous quests) or successfully challenge 3 actions.\nWarning The latter option of this quest can‚Äôt be done currently because our proposal challenge system isn‚Äôt live yet.\n","description":"","tags":null,"title":"üèÜ Governor/Contributors","uri":"/docs-hugo/community/trophies/contributors/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/docs-hugo/categories/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/docs-hugo/tags/"}]