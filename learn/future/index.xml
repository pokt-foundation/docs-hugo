<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>üëÄ Future (v1) on Pocket Network</title><link>https://pokt-foundation.github.io/docs-hugo/learn/future/</link><description>Recent content in üëÄ Future (v1) on Pocket Network</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pokt-foundation.github.io/docs-hugo/learn/future/index.xml" rel="self" type="application/rss+xml"/><item><title>ü™ô Utility</title><link>https://pokt-foundation.github.io/docs-hugo/learn/future/utility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pokt-foundation.github.io/docs-hugo/learn/future/utility/</guid><description>Pocket Network has always been designed to do one thing and do it well: provide a utilitarian economy that coordinates unstoppable Web3 access. In the context of the v1.0 Utility Module, this means we are laser-focused on optimizing the existing utility of the network, not expanding the scope of our utility.
This means optimizing how effectively we coordinate Web3 access, which can be broken down into two categories:
Relay Quality: RPC node (Servicer) incentives should be as tightly-coupled as possible to relay quality, so that Pocket Network‚Äôs service not only matches centralized providers‚Äô but provides a level of quality, unique to Pocket‚Äôs architecture, that can‚Äôt be matched Relay Scalability: our protocol should be as scalable as possible, to maximize the number of relays that the network can process and optimize the efficiency (and thus cost) of the service Relay Quality Quality Enforcement v0 ‚Äì Client-side + Layer-2 Enforcement When we first designed Pocket Network, we assumed that service quality would be ensured through a Darwinian competitive dynamic.</description></item><item><title>ü§ù Consensus</title><link>https://pokt-foundation.github.io/docs-hugo/learn/future/consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pokt-foundation.github.io/docs-hugo/learn/future/consensus/</guid><description>The consensus module coordinates Validators to come to agreement that the transactions in a block are legitimate before the block is added to the blockchain. Currently, v0 inherits its consensus implementation from Tendermint. While Tendermint provides a great framework for building applications that can handle arbitrary computation, it is not optimized for Pocket Network&amp;rsquo;s singular focus of coordinating unstoppable Web3 access.
Some of the major changes to the consensus module for v1.</description></item><item><title>üí¨ Peer to Peer</title><link>https://pokt-foundation.github.io/docs-hugo/learn/future/peer-to-peer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pokt-foundation.github.io/docs-hugo/learn/future/peer-to-peer/</guid><description>The Peer-to-Peer (P2P) module is responsible for handling how all the nodes in the network communicate with each other when new transactions need to be added to a block and when the new block gets added to the chain. Currently, v0 pairs peers together randomly. This random pairing was chosen to ensure redundancy across the network, however, as Pocket Network continues to grow, the redundancy and complexity of random pairing require more bandwidth as more nodes come online ‚Äì with a good chunk of that bandwidth being used to retrieve copies of information the nodes have already seen.</description></item><item><title>üóÑ Persistence</title><link>https://pokt-foundation.github.io/docs-hugo/learn/future/persistence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pokt-foundation.github.io/docs-hugo/learn/future/persistence/</guid><description>The Persistence module is responsible for ensuring that the data continues to persist over time, across deployments, and throughout software changes. Currently, V0 handles data persistence through Tendermint. Tendermint uses a similar mechanism to most other blockchains, storing the different state data that needs to persist in Merkle trees. The roots of these trees are included in the block, and then for each block, each of the trees is stored as a file.</description></item></channel></rss>